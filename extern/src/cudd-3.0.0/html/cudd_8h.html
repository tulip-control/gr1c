<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cudd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudd.h File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The University of Colorado decision diagram package.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cudd.h:</div>
<div class="dyncontent">
<div class="center"><img src="cudd_8h__incl.png" border="0" usemap="#cudd_2cudd_8h" alt=""/></div>
<map name="cudd_2cudd_8h" id="cudd_2cudd_8h">
<area shape="rect"  title="The University of Colorado decision diagram package." alt="" coords="5,5,105,32"/>
<area shape="rect"  title=" " alt="" coords="12,80,99,107"/>
</map>
</div>
</div>
<p><a href="cudd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af397eb0f37256c48b181c5f02e5cb128"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:af397eb0f37256c48b181c5f02e5cb128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab114f6415a719b17d825ad1ca5ba4119"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab114f6415a719b17d825ad1ca5ba4119">CUDD_FALSE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab114f6415a719b17d825ad1ca5ba4119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f40d6c6354b5b1475537cd2431ab4"><td class="memItemLeft" align="right" valign="top"><a id="aea3f40d6c6354b5b1475537cd2431ab4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aea3f40d6c6354b5b1475537cd2431ab4">CUDD_OUT_OF_MEM</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:aea3f40d6c6354b5b1475537cd2431ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value returned my many functions when memory is exhausted. <br /></td></tr>
<tr class="separator:aea3f40d6c6354b5b1475537cd2431ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5898eb92cde4c11e117bb88330b50019"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5898eb92cde4c11e117bb88330b50019">CUDD_UNIQUE_SLOTS</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a5898eb92cde4c11e117bb88330b50019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43ddb042121362b558a2ff66dd829ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae43ddb042121362b558a2ff66dd829ed">CUDD_CACHE_SLOTS</a>&#160;&#160;&#160;262144</td></tr>
<tr class="separator:ae43ddb042121362b558a2ff66dd829ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51def84b8444e5a922b5859fca6674cf"><td class="memItemLeft" align="right" valign="top"><a id="a51def84b8444e5a922b5859fca6674cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CUDD_RESIDUE_DEFAULT</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a51def84b8444e5a922b5859fca6674cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c32e7ebb7bc5341db1dabfa6709bc5"><td class="memItemLeft" align="right" valign="top"><a id="ae8c32e7ebb7bc5341db1dabfa6709bc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CUDD_RESIDUE_MSB</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae8c32e7ebb7bc5341db1dabfa6709bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321dfaa195780e5752e6fa09bd092385"><td class="memItemLeft" align="right" valign="top"><a id="a321dfaa195780e5752e6fa09bd092385"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CUDD_RESIDUE_TC</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a321dfaa195780e5752e6fa09bd092385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ef8d39e760eaabae6d58d9a5ddbfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a352ef8d39e760eaabae6d58d9a5ddbfc">Cudd_Not</a>(node)&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) ^ (uintptr_t) 01))</td></tr>
<tr class="memdesc:a352ef8d39e760eaabae6d58d9a5ddbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complements a DD.  <a href="#a352ef8d39e760eaabae6d58d9a5ddbfc">More...</a><br /></td></tr>
<tr class="separator:a352ef8d39e760eaabae6d58d9a5ddbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae870da95e89a703e939161fe08b899f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae870da95e89a703e939161fe08b899f9">Cudd_NotCond</a>(node,  c)&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) ^ (uintptr_t) (c)))</td></tr>
<tr class="memdesc:ae870da95e89a703e939161fe08b899f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complements a DD if a condition is true.  <a href="#ae870da95e89a703e939161fe08b899f9">More...</a><br /></td></tr>
<tr class="separator:ae870da95e89a703e939161fe08b899f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbecf4f6f78f92518f4d0a477d870b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afbbecf4f6f78f92518f4d0a477d870b6">Cudd_Regular</a>(node)&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) &amp; ~(uintptr_t) 01))</td></tr>
<tr class="memdesc:afbbecf4f6f78f92518f4d0a477d870b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the regular version of a pointer.  <a href="#afbbecf4f6f78f92518f4d0a477d870b6">More...</a><br /></td></tr>
<tr class="separator:afbbecf4f6f78f92518f4d0a477d870b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4575f4314998362765264f64eccfe0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac4575f4314998362765264f64eccfe0c">Cudd_Complement</a>(node)&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) | (uintptr_t) 01))</td></tr>
<tr class="memdesc:ac4575f4314998362765264f64eccfe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complemented version of a pointer.  <a href="#ac4575f4314998362765264f64eccfe0c">More...</a><br /></td></tr>
<tr class="separator:ac4575f4314998362765264f64eccfe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35322518c24f65f44eda9623083cb62c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a35322518c24f65f44eda9623083cb62c">Cudd_IsComplement</a>(node)&#160;&#160;&#160;((int) ((uintptr_t) (node) &amp; (uintptr_t) 01))</td></tr>
<tr class="memdesc:a35322518c24f65f44eda9623083cb62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if a pointer is complemented.  <a href="#a35322518c24f65f44eda9623083cb62c">More...</a><br /></td></tr>
<tr class="separator:a35322518c24f65f44eda9623083cb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0122cc772ed6f3012bcac42fac0c0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2c0122cc772ed6f3012bcac42fac0c0c">Cudd_ReadIndex</a>(dd,  index)&#160;&#160;&#160;(<a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976">Cudd_ReadPerm</a>(dd,index))</td></tr>
<tr class="memdesc:a2c0122cc772ed6f3012bcac42fac0c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position in the order of variable index.  <a href="#a2c0122cc772ed6f3012bcac42fac0c0c">More...</a><br /></td></tr>
<tr class="separator:a2c0122cc772ed6f3012bcac42fac0c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13069593b0d4de4d16493b956de38a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6">Cudd_ForeachCube</a>(manager,  f,  gen,  cube,  value)</td></tr>
<tr class="memdesc:af13069593b0d4de4d16493b956de38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the cubes of a decision diagram.  <a href="#af13069593b0d4de4d16493b956de38a6">More...</a><br /></td></tr>
<tr class="separator:af13069593b0d4de4d16493b956de38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ce1bc5df95326f9eabcfeca1e7ded"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6b1ce1bc5df95326f9eabcfeca1e7ded">Cudd_ForeachPrime</a>(manager,  l,  u,  gen,  cube)</td></tr>
<tr class="memdesc:a6b1ce1bc5df95326f9eabcfeca1e7ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the primes of a Boolean function.  <a href="#a6b1ce1bc5df95326f9eabcfeca1e7ded">More...</a><br /></td></tr>
<tr class="separator:a6b1ce1bc5df95326f9eabcfeca1e7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb7e015a5d710dc3086b194193549f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2">Cudd_ForeachNode</a>(manager,  f,  gen,  node)</td></tr>
<tr class="memdesc:aeeb7e015a5d710dc3086b194193549f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the nodes of a decision diagram.  <a href="#aeeb7e015a5d710dc3086b194193549f2">More...</a><br /></td></tr>
<tr class="separator:aeeb7e015a5d710dc3086b194193549f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afa2381aa1f60094b325b10c0a5baa1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7afa2381aa1f60094b325b10c0a5baa1">Cudd_zddForeachPath</a>(manager,  f,  gen,  path)</td></tr>
<tr class="memdesc:a7afa2381aa1f60094b325b10c0a5baa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the paths of a ZDD.  <a href="#a7afa2381aa1f60094b325b10c0a5baa1">More...</a><br /></td></tr>
<tr class="separator:a7afa2381aa1f60094b325b10c0a5baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a84a6539cc165870dccbd296fe29ea880"><td class="memItemLeft" align="right" valign="top"><a id="a84a6539cc165870dccbd296fe29ea880"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a></td></tr>
<tr class="memdesc:a84a6539cc165870dccbd296fe29ea880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the value of a terminal node. <br /></td></tr>
<tr class="separator:a84a6539cc165870dccbd296fe29ea880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113dbfe7d93a38b91a4214e214af7ec7"><td class="memItemLeft" align="right" valign="top"><a id="a113dbfe7d93a38b91a4214e214af7ec7"></a>
typedef struct <a class="el" href="structDdNode.html">DdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a113dbfe7d93a38b91a4214e214af7ec7">DdNode</a></td></tr>
<tr class="memdesc:a113dbfe7d93a38b91a4214e214af7ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the decision diagram node. <br /></td></tr>
<tr class="separator:a113dbfe7d93a38b91a4214e214af7ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cee862ffaa35c53ec0e1b5afeca632c"><td class="memItemLeft" align="right" valign="top"><a id="a6cee862ffaa35c53ec0e1b5afeca632c"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6cee862ffaa35c53ec0e1b5afeca632c">DdNodePtr</a></td></tr>
<tr class="memdesc:a6cee862ffaa35c53ec0e1b5afeca632c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a decision diagram node. <br /></td></tr>
<tr class="separator:a6cee862ffaa35c53ec0e1b5afeca632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210314f445a7b5d719abbce16e8b24d"><td class="memItemLeft" align="right" valign="top"><a id="ad210314f445a7b5d719abbce16e8b24d"></a>
typedef struct <a class="el" href="structDdManager.html">DdManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad210314f445a7b5d719abbce16e8b24d">DdManager</a></td></tr>
<tr class="memdesc:ad210314f445a7b5d719abbce16e8b24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDD manager. <br /></td></tr>
<tr class="separator:ad210314f445a7b5d719abbce16e8b24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dcf43f58dcfdc0112e08cd962ff68d"><td class="memItemLeft" align="right" valign="top"><a id="ae2dcf43f58dcfdc0112e08cd962ff68d"></a>
typedef struct <a class="el" href="structDdGen.html">DdGen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae2dcf43f58dcfdc0112e08cd962ff68d">DdGen</a></td></tr>
<tr class="memdesc:ae2dcf43f58dcfdc0112e08cd962ff68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDD generator. <br /></td></tr>
<tr class="separator:ae2dcf43f58dcfdc0112e08cd962ff68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232f2c556e9387699aa619167ba4fd5"><td class="memItemLeft" align="right" valign="top"><a id="a0232f2c556e9387699aa619167ba4fd5"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a></td></tr>
<tr class="memdesc:a0232f2c556e9387699aa619167ba4fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an arbitrary precision integer "digit.". <br /></td></tr>
<tr class="separator:a0232f2c556e9387699aa619167ba4fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8dbc87f1aa0e0c783fa3eb20f7eeab"><td class="memItemLeft" align="right" valign="top"><a id="ace8dbc87f1aa0e0c783fa3eb20f7eeab"></a>
typedef <a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a></td></tr>
<tr class="memdesc:ace8dbc87f1aa0e0c783fa3eb20f7eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an arbitrary precision intger, which is an array of digits. <br /></td></tr>
<tr class="separator:ace8dbc87f1aa0e0c783fa3eb20f7eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0707285ea52e1973b46d113392eb48b"><td class="memItemLeft" align="right" valign="top"><a id="af0707285ea52e1973b46d113392eb48b"></a>
typedef <a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a></td></tr>
<tr class="memdesc:af0707285ea52e1973b46d113392eb48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a const-qualified arbitrary precision integer. <br /></td></tr>
<tr class="separator:af0707285ea52e1973b46d113392eb48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee817945068186156e2439a5d921a56"><td class="memItemLeft" align="right" valign="top"><a id="abee817945068186156e2439a5d921a56"></a>
typedef struct <a class="el" href="structDdTlcInfo.html">DdTlcInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#abee817945068186156e2439a5d921a56">DdTlcInfo</a></td></tr>
<tr class="memdesc:abee817945068186156e2439a5d921a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for function computing two-literal clauses. <br /></td></tr>
<tr class="separator:abee817945068186156e2439a5d921a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0b162633be038685ce87dac7a57382"><td class="memItemLeft" align="right" valign="top"><a id="a1a0b162633be038685ce87dac7a57382"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, const char *, void *)</td></tr>
<tr class="memdesc:a1a0b162633be038685ce87dac7a57382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hook function. <br /></td></tr>
<tr class="separator:a1a0b162633be038685ce87dac7a57382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaac0abf7189a0db3e7ecd729c93188b"><td class="memItemLeft" align="right" valign="top"><a id="afaac0abf7189a0db3e7ecd729c93188b"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afaac0abf7189a0db3e7ecd729c93188b">DD_PRFP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, int, <a class="el" href="structDdNode.html">DdNode</a> **, <a class="el" href="structDdNode.html">DdNode</a> **, <a class="el" href="structDdNode.html">DdNode</a> **)</td></tr>
<tr class="memdesc:afaac0abf7189a0db3e7ecd729c93188b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of priority function. <br /></td></tr>
<tr class="separator:afaac0abf7189a0db3e7ecd729c93188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa941e1d7fbaa50cae391a6dfd229b8"><td class="memItemLeft" align="right" valign="top"><a id="a2aa941e1d7fbaa50cae391a6dfd229b8"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2aa941e1d7fbaa50cae391a6dfd229b8">DD_AOP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, <a class="el" href="structDdNode.html">DdNode</a> **, <a class="el" href="structDdNode.html">DdNode</a> **)</td></tr>
<tr class="memdesc:a2aa941e1d7fbaa50cae391a6dfd229b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of apply operator. <br /></td></tr>
<tr class="separator:a2aa941e1d7fbaa50cae391a6dfd229b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8296f4822b35f456afd928f40ea7ff46"><td class="memItemLeft" align="right" valign="top"><a id="a8296f4822b35f456afd928f40ea7ff46"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8296f4822b35f456afd928f40ea7ff46">DD_MAOP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, <a class="el" href="structDdNode.html">DdNode</a> *)</td></tr>
<tr class="memdesc:a8296f4822b35f456afd928f40ea7ff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of monadic apply operator. <br /></td></tr>
<tr class="separator:a8296f4822b35f456afd928f40ea7ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55488f14ee0664be0dee3f2004f5fd6"><td class="memItemLeft" align="right" valign="top"><a id="af55488f14ee0664be0dee3f2004f5fd6"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af55488f14ee0664be0dee3f2004f5fd6">DD_CTFP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, <a class="el" href="structDdNode.html">DdNode</a> *, <a class="el" href="structDdNode.html">DdNode</a> *)</td></tr>
<tr class="memdesc:af55488f14ee0664be0dee3f2004f5fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of two-operand cache tag functions. <br /></td></tr>
<tr class="separator:af55488f14ee0664be0dee3f2004f5fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176dbe7f76ff8aae03a42411e4ab3110"><td class="memItemLeft" align="right" valign="top"><a id="a176dbe7f76ff8aae03a42411e4ab3110"></a>
typedef <a class="el" href="structDdNode.html">DdNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a176dbe7f76ff8aae03a42411e4ab3110">DD_CTFP1</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, <a class="el" href="structDdNode.html">DdNode</a> *)</td></tr>
<tr class="memdesc:a176dbe7f76ff8aae03a42411e4ab3110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of one-operand cache tag functions. <br /></td></tr>
<tr class="separator:a176dbe7f76ff8aae03a42411e4ab3110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b4676c7e2dd36567b3749740ca8b60"><td class="memItemLeft" align="right" valign="top"><a id="ab7b4676c7e2dd36567b3749740ca8b60"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>) (size_t)</td></tr>
<tr class="memdesc:ab7b4676c7e2dd36567b3749740ca8b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of memory-out function. <br /></td></tr>
<tr class="separator:ab7b4676c7e2dd36567b3749740ca8b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0e9a5df0e281a5bcb55b92b70710c"><td class="memItemLeft" align="right" valign="top"><a id="ae4e0e9a5df0e281a5bcb55b92b70710c"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae4e0e9a5df0e281a5bcb55b92b70710c">DD_QSFP</a>) (const void *, const void *)</td></tr>
<tr class="memdesc:ae4e0e9a5df0e281a5bcb55b92b70710c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of comparison function for qsort. <br /></td></tr>
<tr class="separator:ae4e0e9a5df0e281a5bcb55b92b70710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19edd4d89e40f721e04dbdeb3e36684"><td class="memItemLeft" align="right" valign="top"><a id="ab19edd4d89e40f721e04dbdeb3e36684"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab19edd4d89e40f721e04dbdeb3e36684">DD_THFP</a>) (const void *)</td></tr>
<tr class="memdesc:ab19edd4d89e40f721e04dbdeb3e36684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of termination handler. <br /></td></tr>
<tr class="separator:ab19edd4d89e40f721e04dbdeb3e36684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dd2f7df5ab2f9df7e9e5c969adc0aa"><td class="memItemLeft" align="right" valign="top"><a id="a55dd2f7df5ab2f9df7e9e5c969adc0aa"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a>) (<a class="el" href="structDdManager.html">DdManager</a> *, void *)</td></tr>
<tr class="memdesc:a55dd2f7df5ab2f9df7e9e5c969adc0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of timeout handler. <br /></td></tr>
<tr class="separator:a55dd2f7df5ab2f9df7e9e5c969adc0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8ff397cb64855989d6ad62a491e20dde"><td class="memItemLeft" align="right" valign="top"><a id="a8ff397cb64855989d6ad62a491e20dde"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> { <br />
&#160;&#160;<b>CUDD_REORDER_SAME</b>, 
<b>CUDD_REORDER_NONE</b>, 
<b>CUDD_REORDER_RANDOM</b>, 
<b>CUDD_REORDER_RANDOM_PIVOT</b>, 
<br />
&#160;&#160;<b>CUDD_REORDER_SIFT</b>, 
<b>CUDD_REORDER_SIFT_CONVERGE</b>, 
<b>CUDD_REORDER_SYMM_SIFT</b>, 
<b>CUDD_REORDER_SYMM_SIFT_CONV</b>, 
<br />
&#160;&#160;<b>CUDD_REORDER_WINDOW2</b>, 
<b>CUDD_REORDER_WINDOW3</b>, 
<b>CUDD_REORDER_WINDOW4</b>, 
<b>CUDD_REORDER_WINDOW2_CONV</b>, 
<br />
&#160;&#160;<b>CUDD_REORDER_WINDOW3_CONV</b>, 
<b>CUDD_REORDER_WINDOW4_CONV</b>, 
<b>CUDD_REORDER_GROUP_SIFT</b>, 
<b>CUDD_REORDER_GROUP_SIFT_CONV</b>, 
<br />
&#160;&#160;<b>CUDD_REORDER_ANNEALING</b>, 
<b>CUDD_REORDER_GENETIC</b>, 
<b>CUDD_REORDER_LINEAR</b>, 
<b>CUDD_REORDER_LINEAR_CONVERGE</b>, 
<br />
&#160;&#160;<b>CUDD_REORDER_LAZY_SIFT</b>, 
<b>CUDD_REORDER_EXACT</b>
<br />
 }</td></tr>
<tr class="memdesc:a8ff397cb64855989d6ad62a491e20dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reordering algorithm. <br /></td></tr>
<tr class="separator:a8ff397cb64855989d6ad62a491e20dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2572b778b7e8bd68afcd4aa1f0ce33"><td class="memItemLeft" align="right" valign="top"><a id="a8b2572b778b7e8bd68afcd4aa1f0ce33"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a> { <br />
&#160;&#160;<b>CUDD_NO_CHECK</b>, 
<b>CUDD_GROUP_CHECK</b>, 
<b>CUDD_GROUP_CHECK2</b>, 
<b>CUDD_GROUP_CHECK3</b>, 
<br />
&#160;&#160;<b>CUDD_GROUP_CHECK4</b>, 
<b>CUDD_GROUP_CHECK5</b>, 
<b>CUDD_GROUP_CHECK6</b>, 
<b>CUDD_GROUP_CHECK7</b>, 
<br />
&#160;&#160;<b>CUDD_GROUP_CHECK8</b>, 
<b>CUDD_GROUP_CHECK9</b>
<br />
 }</td></tr>
<tr class="memdesc:a8b2572b778b7e8bd68afcd4aa1f0ce33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of aggregation methods. <br /></td></tr>
<tr class="separator:a8b2572b778b7e8bd68afcd4aa1f0ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec19daded82939f6045c92b3a7bde2"><td class="memItemLeft" align="right" valign="top"><a id="afbec19daded82939f6045c92b3a7bde2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> { <b>CUDD_PRE_GC_HOOK</b>, 
<b>CUDD_POST_GC_HOOK</b>, 
<b>CUDD_PRE_REORDERING_HOOK</b>, 
<b>CUDD_POST_REORDERING_HOOK</b>
 }</td></tr>
<tr class="memdesc:afbec19daded82939f6045c92b3a7bde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hooks. <br /></td></tr>
<tr class="separator:afbec19daded82939f6045c92b3a7bde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27114b4342bc1b987f35d751eae2444b"><td class="memItemLeft" align="right" valign="top"><a id="a27114b4342bc1b987f35d751eae2444b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a27114b4342bc1b987f35d751eae2444b">Cudd_ErrorType</a> { <br />
&#160;&#160;<b>CUDD_NO_ERROR</b>, 
<b>CUDD_MEMORY_OUT</b>, 
<b>CUDD_TOO_MANY_NODES</b>, 
<b>CUDD_MAX_MEM_EXCEEDED</b>, 
<br />
&#160;&#160;<b>CUDD_TIMEOUT_EXPIRED</b>, 
<b>CUDD_TERMINATION</b>, 
<b>CUDD_INVALID_ARG</b>, 
<b>CUDD_INTERNAL_ERROR</b>
<br />
 }</td></tr>
<tr class="memdesc:a27114b4342bc1b987f35d751eae2444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of error codes. <br /></td></tr>
<tr class="separator:a27114b4342bc1b987f35d751eae2444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f4d3cfe77ec9aaa54e842f70da5bc2"><td class="memItemLeft" align="right" valign="top"><a id="a34f4d3cfe77ec9aaa54e842f70da5bc2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a34f4d3cfe77ec9aaa54e842f70da5bc2">Cudd_LazyGroupType</a> { <b>CUDD_LAZY_NONE</b>, 
<b>CUDD_LAZY_SOFT_GROUP</b>, 
<b>CUDD_LAZY_HARD_GROUP</b>, 
<b>CUDD_LAZY_UNGROUP</b>
 }</td></tr>
<tr class="memdesc:a34f4d3cfe77ec9aaa54e842f70da5bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group type for lazy sifting. <br /></td></tr>
<tr class="separator:a34f4d3cfe77ec9aaa54e842f70da5bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d55585c0a16ded7753ebc19d765659"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae6d55585c0a16ded7753ebc19d765659">Cudd_VariableType</a> { <b>CUDD_VAR_PRIMARY_INPUT</b>, 
<b>CUDD_VAR_PRESENT_STATE</b>, 
<b>CUDD_VAR_NEXT_STATE</b>
 }</td></tr>
<tr class="memdesc:ae6d55585c0a16ded7753ebc19d765659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type.  <a href="cudd_8h.html#ae6d55585c0a16ded7753ebc19d765659">More...</a><br /></td></tr>
<tr class="separator:ae6d55585c0a16ded7753ebc19d765659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad77f4dd2911bac8e25633fe84c6cfb8b">Cudd_addNewVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ADD variable.  <a href="#ad77f4dd2911bac8e25633fe84c6cfb8b">More...</a><br /></td></tr>
<tr class="separator:ad77f4dd2911bac8e25633fe84c6cfb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aacea7b5ed8dc2595a1c0e01788bc205a">Cudd_addNewVarAtLevel</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int level)</td></tr>
<tr class="memdesc:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ADD variable at a specified level.  <a href="#aacea7b5ed8dc2595a1c0e01788bc205a">More...</a><br /></td></tr>
<tr class="separator:aacea7b5ed8dc2595a1c0e01788bc205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c50e1a273569cc0ffc19ab98c28ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a475c50e1a273569cc0ffc19ab98c28ce">Cudd_bddNewVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a475c50e1a273569cc0ffc19ab98c28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new BDD variable.  <a href="#a475c50e1a273569cc0ffc19ab98c28ce">More...</a><br /></td></tr>
<tr class="separator:a475c50e1a273569cc0ffc19ab98c28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35eac7df807101795efe0d582ff05fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae35eac7df807101795efe0d582ff05fa">Cudd_bddNewVarAtLevel</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int level)</td></tr>
<tr class="memdesc:ae35eac7df807101795efe0d582ff05fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new BDD variable at a specified level.  <a href="#ae35eac7df807101795efe0d582ff05fa">More...</a><br /></td></tr>
<tr class="separator:ae35eac7df807101795efe0d582ff05fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7174f24036c4eae624311b273df978da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7174f24036c4eae624311b273df978da">Cudd_bddIsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a7174f24036c4eae624311b273df978da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the given node is a BDD variable; 0 otherwise.  <a href="#a7174f24036c4eae624311b273df978da">More...</a><br /></td></tr>
<tr class="separator:a7174f24036c4eae624311b273df978da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19967d7c87650f63fc312f38c318e3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a19967d7c87650f63fc312f38c318e3e9">Cudd_addIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a19967d7c87650f63fc312f38c318e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD variable with index i.  <a href="#a19967d7c87650f63fc312f38c318e3e9">More...</a><br /></td></tr>
<tr class="separator:a19967d7c87650f63fc312f38c318e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd71665cde402bd5bc4f39015c09ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a40fd71665cde402bd5bc4f39015c09ae">Cudd_bddIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a40fd71665cde402bd5bc4f39015c09ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the BDD variable with index i.  <a href="#a40fd71665cde402bd5bc4f39015c09ae">More...</a><br /></td></tr>
<tr class="separator:a40fd71665cde402bd5bc4f39015c09ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf8017813ae9a60790ae4f8a445800d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acbf8017813ae9a60790ae4f8a445800d">Cudd_zddIthVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:acbf8017813ae9a60790ae4f8a445800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ZDD variable with index i.  <a href="#acbf8017813ae9a60790ae4f8a445800d">More...</a><br /></td></tr>
<tr class="separator:acbf8017813ae9a60790ae4f8a445800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d898e3087539ceaaf5ff86aa62c471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a45d898e3087539ceaaf5ff86aa62c471">Cudd_zddVarsFromBddVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int multiplicity)</td></tr>
<tr class="memdesc:a45d898e3087539ceaaf5ff86aa62c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates one or more ZDD variables for each BDD variable.  <a href="#a45d898e3087539ceaaf5ff86aa62c471">More...</a><br /></td></tr>
<tr class="separator:a45d898e3087539ceaaf5ff86aa62c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbe3503e24e823a81bc2c8acb065345"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1dbe3503e24e823a81bc2c8acb065345">Cudd_ReadMaxIndex</a> (void)</td></tr>
<tr class="memdesc:a1dbe3503e24e823a81bc2c8acb065345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible index for a variable.  <a href="#a1dbe3503e24e823a81bc2c8acb065345">More...</a><br /></td></tr>
<tr class="separator:a1dbe3503e24e823a81bc2c8acb065345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8b8fb347b6c5324ef9bce64aa73a63bb">Cudd_addConst</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> c)</td></tr>
<tr class="memdesc:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ADD for constant c.  <a href="#a8b8fb347b6c5324ef9bce64aa73a63bb">More...</a><br /></td></tr>
<tr class="separator:a8b8fb347b6c5324ef9bce64aa73a63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018bdc54a42aacf14959f83cbf6992b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a018bdc54a42aacf14959f83cbf6992b6">Cudd_IsConstant</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a018bdc54a42aacf14959f83cbf6992b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the node is a constant node.  <a href="#a018bdc54a42aacf14959f83cbf6992b6">More...</a><br /></td></tr>
<tr class="separator:a018bdc54a42aacf14959f83cbf6992b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4ac0cf7ba2eba7a6652a886deb4723fa">Cudd_IsNonConstant</a> (<a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if a DD node is not constant.  <a href="#a4ac0cf7ba2eba7a6652a886deb4723fa">More...</a><br /></td></tr>
<tr class="separator:a4ac0cf7ba2eba7a6652a886deb4723fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed52f5319f877acc6ac7c27490111b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aeed52f5319f877acc6ac7c27490111b6">Cudd_T</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:aeed52f5319f877acc6ac7c27490111b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the then child of an internal node.  <a href="#aeed52f5319f877acc6ac7c27490111b6">More...</a><br /></td></tr>
<tr class="separator:aeed52f5319f877acc6ac7c27490111b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601a736699b3e5c8eb7149e6049ea131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a601a736699b3e5c8eb7149e6049ea131">Cudd_E</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a601a736699b3e5c8eb7149e6049ea131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the else child of an internal node.  <a href="#a601a736699b3e5c8eb7149e6049ea131">More...</a><br /></td></tr>
<tr class="separator:a601a736699b3e5c8eb7149e6049ea131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9ebe62ac5ac8a49dc13bce839ae09c88">Cudd_V</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a constant node.  <a href="#a9ebe62ac5ac8a49dc13bce839ae09c88">More...</a><br /></td></tr>
<tr class="separator:a9ebe62ac5ac8a49dc13bce839ae09c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae94781bf6e62d0c6a3439b4db11b50e5">Cudd_ReadStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start time of the manager.  <a href="#ae94781bf6e62d0c6a3439b4db11b50e5">More...</a><br /></td></tr>
<tr class="separator:ae94781bf6e62d0c6a3439b4db11b50e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab6cafb71c46dedb3eaa27acd56b855b8">Cudd_ReadElapsedTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time elapsed since the start time of the manager.  <a href="#ab6cafb71c46dedb3eaa27acd56b855b8">More...</a><br /></td></tr>
<tr class="separator:ab6cafb71c46dedb3eaa27acd56b855b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b42ab1fa12990140dbfd415bc7a6231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2b42ab1fa12990140dbfd415bc7a6231">Cudd_SetStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long st)</td></tr>
<tr class="memdesc:a2b42ab1fa12990140dbfd415bc7a6231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the start time of the manager.  <a href="#a2b42ab1fa12990140dbfd415bc7a6231">More...</a><br /></td></tr>
<tr class="separator:a2b42ab1fa12990140dbfd415bc7a6231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bbaa787eb4bbf866292ea6f566e427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac8bbaa787eb4bbf866292ea6f566e427">Cudd_ResetStartTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:ac8bbaa787eb4bbf866292ea6f566e427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the start time of the manager.  <a href="#ac8bbaa787eb4bbf866292ea6f566e427">More...</a><br /></td></tr>
<tr class="separator:ac8bbaa787eb4bbf866292ea6f566e427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855a253235b54ff16fd66c6e43241069"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a855a253235b54ff16fd66c6e43241069">Cudd_ReadTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a855a253235b54ff16fd66c6e43241069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time limit for the manager.  <a href="#a855a253235b54ff16fd66c6e43241069">More...</a><br /></td></tr>
<tr class="separator:a855a253235b54ff16fd66c6e43241069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e694e133632d34256646869f076ff5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac6e694e133632d34256646869f076ff5">Cudd_SetTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long tl)</td></tr>
<tr class="memdesc:ac6e694e133632d34256646869f076ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time limit for the manager.  <a href="#ac6e694e133632d34256646869f076ff5">More...</a><br /></td></tr>
<tr class="separator:ac6e694e133632d34256646869f076ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb6240810097270fd1414536de17eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aeeb6240810097270fd1414536de17eb0">Cudd_UpdateTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aeeb6240810097270fd1414536de17eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the time limit for the manager.  <a href="#aeeb6240810097270fd1414536de17eb0">More...</a><br /></td></tr>
<tr class="separator:aeeb6240810097270fd1414536de17eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333169d352f3ab54002eaae738a39d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a333169d352f3ab54002eaae738a39d68">Cudd_IncreaseTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, unsigned long increase)</td></tr>
<tr class="memdesc:a333169d352f3ab54002eaae738a39d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the time limit for the manager.  <a href="#a333169d352f3ab54002eaae738a39d68">More...</a><br /></td></tr>
<tr class="separator:a333169d352f3ab54002eaae738a39d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497c8cb498833021f18813fb5813b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa497c8cb498833021f18813fb5813b57">Cudd_UnsetTimeLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aa497c8cb498833021f18813fb5813b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the time limit for the manager.  <a href="#aa497c8cb498833021f18813fb5813b57">More...</a><br /></td></tr>
<tr class="separator:aa497c8cb498833021f18813fb5813b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7c3b2370790803f37aace1dfc0a7d1cc">Cudd_TimeLimited</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the time limit for the manager is set.  <a href="#a7c3b2370790803f37aace1dfc0a7d1cc">More...</a><br /></td></tr>
<tr class="separator:a7c3b2370790803f37aace1dfc0a7d1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">Cudd_RegisterTerminationCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#ab19edd4d89e40f721e04dbdeb3e36684">DD_THFP</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a termination callback.  <a href="#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">More...</a><br /></td></tr>
<tr class="separator:a5dbdd1ef4d92a8f7d60304e2cc17ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014219cc6794497d58c3eeb140db8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8014219cc6794497d58c3eeb140db8c8">Cudd_UnregisterTerminationCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a8014219cc6794497d58c3eeb140db8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a termination callback.  <a href="#a8014219cc6794497d58c3eeb140db8c8">More...</a><br /></td></tr>
<tr class="separator:a8014219cc6794497d58c3eeb140db8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa76d8075f1af649c8741af26369836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6aa76d8075f1af649c8741af26369836">Cudd_RegisterOutOfMemoryCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> callback)</td></tr>
<tr class="memdesc:a6aa76d8075f1af649c8741af26369836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs an out-of-memory callback.  <a href="#a6aa76d8075f1af649c8741af26369836">More...</a><br /></td></tr>
<tr class="separator:a6aa76d8075f1af649c8741af26369836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6966d8f04f26fd49495f3703a771ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1b6966d8f04f26fd49495f3703a771ce">Cudd_UnregisterOutOfMemoryCallback</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a1b6966d8f04f26fd49495f3703a771ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an out-of-memory callback.  <a href="#a1b6966d8f04f26fd49495f3703a771ce">More...</a><br /></td></tr>
<tr class="separator:a1b6966d8f04f26fd49495f3703a771ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a5e97bfebdc0362991d1caaa96115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a122a5e97bfebdc0362991d1caaa96115">Cudd_RegisterTimeoutHandler</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a> handler, void *arg)</td></tr>
<tr class="memdesc:a122a5e97bfebdc0362991d1caaa96115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a timeout handler function.  <a href="#a122a5e97bfebdc0362991d1caaa96115">More...</a><br /></td></tr>
<tr class="separator:a122a5e97bfebdc0362991d1caaa96115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1312ca893e36e0b628804b12e5df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4b1312ca893e36e0b628804b12e5df32">Cudd_ReadTimeoutHandler</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, void **argp)</td></tr>
<tr class="memdesc:a4b1312ca893e36e0b628804b12e5df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current timeout handler function.  <a href="#a4b1312ca893e36e0b628804b12e5df32">More...</a><br /></td></tr>
<tr class="separator:a4b1312ca893e36e0b628804b12e5df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d69b4288f36d5d377c460d49066a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6a0d69b4288f36d5d377c460d49066a6">Cudd_AutodynEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> method)</td></tr>
<tr class="memdesc:a6a0d69b4288f36d5d377c460d49066a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables automatic dynamic reordering of BDDs and ADDs.  <a href="#a6a0d69b4288f36d5d377c460d49066a6">More...</a><br /></td></tr>
<tr class="separator:a6a0d69b4288f36d5d377c460d49066a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd2c1c2a110944c1d760de577aed431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#affd2c1c2a110944c1d760de577aed431">Cudd_AutodynDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:affd2c1c2a110944c1d760de577aed431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables automatic dynamic reordering.  <a href="#affd2c1c2a110944c1d760de577aed431">More...</a><br /></td></tr>
<tr class="separator:affd2c1c2a110944c1d760de577aed431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3806c2327487b3cea3c7ffff75aead83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3806c2327487b3cea3c7ffff75aead83">Cudd_ReorderingStatus</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *method)</td></tr>
<tr class="memdesc:a3806c2327487b3cea3c7ffff75aead83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of automatic dynamic reordering of BDDs and ADDs.  <a href="#a3806c2327487b3cea3c7ffff75aead83">More...</a><br /></td></tr>
<tr class="separator:a3806c2327487b3cea3c7ffff75aead83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2">Cudd_AutodynEnableZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> method)</td></tr>
<tr class="memdesc:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables automatic dynamic reordering of ZDDs.  <a href="#a709e0e15a38d6d6e9c83ff8b8a9d07f2">More...</a><br /></td></tr>
<tr class="separator:a709e0e15a38d6d6e9c83ff8b8a9d07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ccb201e3c1aa25ebef007399849fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a219ccb201e3c1aa25ebef007399849fa">Cudd_AutodynDisableZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a219ccb201e3c1aa25ebef007399849fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables automatic dynamic reordering of ZDDs.  <a href="#a219ccb201e3c1aa25ebef007399849fa">More...</a><br /></td></tr>
<tr class="separator:a219ccb201e3c1aa25ebef007399849fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f65c44244489bfbb37137929baf0cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac6f65c44244489bfbb37137929baf0cd">Cudd_ReorderingStatusZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *method)</td></tr>
<tr class="memdesc:ac6f65c44244489bfbb37137929baf0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of automatic dynamic reordering of ZDDs.  <a href="#ac6f65c44244489bfbb37137929baf0cd">More...</a><br /></td></tr>
<tr class="separator:ac6f65c44244489bfbb37137929baf0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34225975eef55170213a0a9efed5a891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a34225975eef55170213a0a9efed5a891">Cudd_zddRealignmentEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a34225975eef55170213a0a9efed5a891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the realignment of ZDD order to BDD order is enabled.  <a href="#a34225975eef55170213a0a9efed5a891">More...</a><br /></td></tr>
<tr class="separator:a34225975eef55170213a0a9efed5a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa57aff1886a1fea0cb8b5bf8d66cf50e">Cudd_zddRealignEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables realignment of ZDD order to BDD order.  <a href="#aa57aff1886a1fea0cb8b5bf8d66cf50e">More...</a><br /></td></tr>
<tr class="separator:aa57aff1886a1fea0cb8b5bf8d66cf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea01466660ca226539a66a014a4da00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afea01466660ca226539a66a014a4da00">Cudd_zddRealignDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:afea01466660ca226539a66a014a4da00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables realignment of ZDD order to BDD order.  <a href="#afea01466660ca226539a66a014a4da00">More...</a><br /></td></tr>
<tr class="separator:afea01466660ca226539a66a014a4da00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516183604a75b38337b81fd17c291826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a516183604a75b38337b81fd17c291826">Cudd_bddRealignmentEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a516183604a75b38337b81fd17c291826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the realignment of BDD order to ZDD order is enabled.  <a href="#a516183604a75b38337b81fd17c291826">More...</a><br /></td></tr>
<tr class="separator:a516183604a75b38337b81fd17c291826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0d34d836668fc62e7c7835fa95132d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2d0d34d836668fc62e7c7835fa95132d">Cudd_bddRealignEnable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a2d0d34d836668fc62e7c7835fa95132d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables realignment of BDD order to ZDD order.  <a href="#a2d0d34d836668fc62e7c7835fa95132d">More...</a><br /></td></tr>
<tr class="separator:a2d0d34d836668fc62e7c7835fa95132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb093bdd80db0b880f61017f3e36de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3eb093bdd80db0b880f61017f3e36de2">Cudd_bddRealignDisable</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a3eb093bdd80db0b880f61017f3e36de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables realignment of ZDD order to BDD order.  <a href="#a3eb093bdd80db0b880f61017f3e36de2">More...</a><br /></td></tr>
<tr class="separator:a3eb093bdd80db0b880f61017f3e36de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651c953d81570d3f4f794bcbef40afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2651c953d81570d3f4f794bcbef40afe">Cudd_ReadOne</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2651c953d81570d3f4f794bcbef40afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one constant of the manager.  <a href="#a2651c953d81570d3f4f794bcbef40afe">More...</a><br /></td></tr>
<tr class="separator:a2651c953d81570d3f4f794bcbef40afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad6d6950021b06a3bf4a6bcd05b1753e7">Cudd_ReadZddOne</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ZDD for the constant 1 function.  <a href="#ad6d6950021b06a3bf4a6bcd05b1753e7">More...</a><br /></td></tr>
<tr class="separator:ad6d6950021b06a3bf4a6bcd05b1753e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92900f3320df460a72eacc4ed801d69e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a92900f3320df460a72eacc4ed801d69e">Cudd_ReadZero</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a92900f3320df460a72eacc4ed801d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the zero constant of the manager.  <a href="#a92900f3320df460a72eacc4ed801d69e">More...</a><br /></td></tr>
<tr class="separator:a92900f3320df460a72eacc4ed801d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd42d8cb5c86659170103a3068e13a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1dd42d8cb5c86659170103a3068e13a6">Cudd_ReadLogicZero</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1dd42d8cb5c86659170103a3068e13a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logic zero constant of the manager.  <a href="#a1dd42d8cb5c86659170103a3068e13a6">More...</a><br /></td></tr>
<tr class="separator:a1dd42d8cb5c86659170103a3068e13a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af581badbfb76ba5909f83482c47d743e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af581badbfb76ba5909f83482c47d743e">Cudd_ReadPlusInfinity</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af581badbfb76ba5909f83482c47d743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the plus-infinity constant from the manager.  <a href="#af581badbfb76ba5909f83482c47d743e">More...</a><br /></td></tr>
<tr class="separator:af581badbfb76ba5909f83482c47d743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae0ff7f850bf0b84af8ea0779ec0800ac">Cudd_ReadMinusInfinity</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the minus-infinity constant from the manager.  <a href="#ae0ff7f850bf0b84af8ea0779ec0800ac">More...</a><br /></td></tr>
<tr class="separator:ae0ff7f850bf0b84af8ea0779ec0800ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d561f9d388a943104665fe0c850c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a041d561f9d388a943104665fe0c850c0">Cudd_ReadBackground</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a041d561f9d388a943104665fe0c850c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the background constant of the manager.  <a href="#a041d561f9d388a943104665fe0c850c0">More...</a><br /></td></tr>
<tr class="separator:a041d561f9d388a943104665fe0c850c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792749a2a10045b60d2a3d99d99928e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3792749a2a10045b60d2a3d99d99928e">Cudd_SetBackground</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *bck)</td></tr>
<tr class="memdesc:a3792749a2a10045b60d2a3d99d99928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the background constant of the manager.  <a href="#a3792749a2a10045b60d2a3d99d99928e">More...</a><br /></td></tr>
<tr class="separator:a3792749a2a10045b60d2a3d99d99928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588943f358faadd3c7e8a4caf813fce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab588943f358faadd3c7e8a4caf813fce">Cudd_ReadCacheSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab588943f358faadd3c7e8a4caf813fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of slots in the cache.  <a href="#ab588943f358faadd3c7e8a4caf813fce">More...</a><br /></td></tr>
<tr class="separator:ab588943f358faadd3c7e8a4caf813fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac309a335487dbb3ba77b088c90e085c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aac309a335487dbb3ba77b088c90e085c">Cudd_ReadCacheUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aac309a335487dbb3ba77b088c90e085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the fraction of used slots in the cache.  <a href="#aac309a335487dbb3ba77b088c90e085c">More...</a><br /></td></tr>
<tr class="separator:aac309a335487dbb3ba77b088c90e085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4595bfefe543b3f8f74248c048b53fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab4595bfefe543b3f8f74248c048b53fe">Cudd_ReadCacheLookUps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab4595bfefe543b3f8f74248c048b53fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of cache look-ups.  <a href="#ab4595bfefe543b3f8f74248c048b53fe">More...</a><br /></td></tr>
<tr class="separator:ab4595bfefe543b3f8f74248c048b53fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281582d99df044cf8892204026b64b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2281582d99df044cf8892204026b64b9">Cudd_ReadCacheHits</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2281582d99df044cf8892204026b64b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of cache hits.  <a href="#a2281582d99df044cf8892204026b64b9">More...</a><br /></td></tr>
<tr class="separator:a2281582d99df044cf8892204026b64b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8ec5d88cf36fd80006b157252be029"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3d8ec5d88cf36fd80006b157252be029">Cudd_ReadRecursiveCalls</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3d8ec5d88cf36fd80006b157252be029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of recursive calls.  <a href="#a3d8ec5d88cf36fd80006b157252be029">More...</a><br /></td></tr>
<tr class="separator:a3d8ec5d88cf36fd80006b157252be029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79695ef1e6f821d310f5613a6d8ba148"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a79695ef1e6f821d310f5613a6d8ba148">Cudd_ReadMinHit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a79695ef1e6f821d310f5613a6d8ba148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the hit rate that causes resizinig of the computed table.  <a href="#a79695ef1e6f821d310f5613a6d8ba148">More...</a><br /></td></tr>
<tr class="separator:a79695ef1e6f821d310f5613a6d8ba148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f3e2036a77ab8c1318e607dea232b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae96f3e2036a77ab8c1318e607dea232b">Cudd_SetMinHit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int hr)</td></tr>
<tr class="memdesc:ae96f3e2036a77ab8c1318e607dea232b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the hit rate that causes resizinig of the computed table.  <a href="#ae96f3e2036a77ab8c1318e607dea232b">More...</a><br /></td></tr>
<tr class="separator:ae96f3e2036a77ab8c1318e607dea232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">Cudd_ReadLooseUpTo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the looseUpTo parameter of the manager.  <a href="#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">More...</a><br /></td></tr>
<tr class="separator:ab452b9f1bbcdb8bf49cbea25f6e8ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1952bb97db9782bcf607d169c842b7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1952bb97db9782bcf607d169c842b7ce">Cudd_SetLooseUpTo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int lut)</td></tr>
<tr class="memdesc:a1952bb97db9782bcf607d169c842b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the looseUpTo parameter of the manager.  <a href="#a1952bb97db9782bcf607d169c842b7ce">More...</a><br /></td></tr>
<tr class="separator:a1952bb97db9782bcf607d169c842b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dafbaafff7055890cce20fa791b2092"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7dafbaafff7055890cce20fa791b2092">Cudd_ReadMaxCache</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a7dafbaafff7055890cce20fa791b2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the soft limit for the cache size.  <a href="#a7dafbaafff7055890cce20fa791b2092">More...</a><br /></td></tr>
<tr class="separator:a7dafbaafff7055890cce20fa791b2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acfac0e32bb4bcfe7f0035f4fff401a0e">Cudd_ReadMaxCacheHard</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxCacheHard parameter of the manager.  <a href="#acfac0e32bb4bcfe7f0035f4fff401a0e">More...</a><br /></td></tr>
<tr class="separator:acfac0e32bb4bcfe7f0035f4fff401a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ced83212c4c45f94d8957e3fab485c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4ced83212c4c45f94d8957e3fab485c5">Cudd_SetMaxCacheHard</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int mc)</td></tr>
<tr class="memdesc:a4ced83212c4c45f94d8957e3fab485c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxCacheHard parameter of the manager.  <a href="#a4ced83212c4c45f94d8957e3fab485c5">More...</a><br /></td></tr>
<tr class="separator:a4ced83212c4c45f94d8957e3fab485c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1647f3f86f4e555bea35673f9539f94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab1647f3f86f4e555bea35673f9539f94">Cudd_ReadSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab1647f3f86f4e555bea35673f9539f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of BDD variables in existance.  <a href="#ab1647f3f86f4e555bea35673f9539f94">More...</a><br /></td></tr>
<tr class="separator:ab1647f3f86f4e555bea35673f9539f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a82a5d45fa3fb62aa72a3aa280c563f9d">Cudd_ReadZddSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ZDD variables in existance.  <a href="#a82a5d45fa3fb62aa72a3aa280c563f9d">More...</a><br /></td></tr>
<tr class="separator:a82a5d45fa3fb62aa72a3aa280c563f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787560300153655851b4fe3c7646b0c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3787560300153655851b4fe3c7646b0c">Cudd_ReadSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3787560300153655851b4fe3c7646b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of slots of the unique table.  <a href="#a3787560300153655851b4fe3c7646b0c">More...</a><br /></td></tr>
<tr class="separator:a3787560300153655851b4fe3c7646b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0941cb7338ba1a71f3451f4c2a747093"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0941cb7338ba1a71f3451f4c2a747093">Cudd_ReadUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a0941cb7338ba1a71f3451f4c2a747093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the fraction of used slots in the unique table.  <a href="#a0941cb7338ba1a71f3451f4c2a747093">More...</a><br /></td></tr>
<tr class="separator:a0941cb7338ba1a71f3451f4c2a747093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a31d06c2608e7c5b08b3fd6c6e200662f">Cudd_ExpectedUsedSlots</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the expected fraction of used slots in the unique table.  <a href="#a31d06c2608e7c5b08b3fd6c6e200662f">More...</a><br /></td></tr>
<tr class="separator:a31d06c2608e7c5b08b3fd6c6e200662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc6805752cf0bc83080322d778759e6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5bc6805752cf0bc83080322d778759e6">Cudd_ReadKeys</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a5bc6805752cf0bc83080322d778759e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the unique table.  <a href="#a5bc6805752cf0bc83080322d778759e6">More...</a><br /></td></tr>
<tr class="separator:a5bc6805752cf0bc83080322d778759e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4074f697e7ea725a1b853d9a468a082e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4074f697e7ea725a1b853d9a468a082e">Cudd_ReadDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4074f697e7ea725a1b853d9a468a082e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dead nodes in the unique table.  <a href="#a4074f697e7ea725a1b853d9a468a082e">More...</a><br /></td></tr>
<tr class="separator:a4074f697e7ea725a1b853d9a468a082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace82092e4e785b388c83f554daa23283"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ace82092e4e785b388c83f554daa23283">Cudd_ReadMinDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ace82092e4e785b388c83f554daa23283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the minDead parameter of the manager.  <a href="#ace82092e4e785b388c83f554daa23283">More...</a><br /></td></tr>
<tr class="separator:ace82092e4e785b388c83f554daa23283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22056db7260493748eda0162431cd76"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac22056db7260493748eda0162431cd76">Cudd_ReadReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac22056db7260493748eda0162431cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times reordering has occurred.  <a href="#ac22056db7260493748eda0162431cd76">More...</a><br /></td></tr>
<tr class="separator:ac22056db7260493748eda0162431cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad011aad1e779f0e31ab67cf7a1d7f591">Cudd_ReadMaxReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of times reordering may be invoked.  <a href="#ad011aad1e779f0e31ab67cf7a1d7f591">More...</a><br /></td></tr>
<tr class="separator:ad011aad1e779f0e31ab67cf7a1d7f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e39aeebc215847d374a01bb1f182b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3a2e39aeebc215847d374a01bb1f182b">Cudd_SetMaxReorderings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int mr)</td></tr>
<tr class="memdesc:a3a2e39aeebc215847d374a01bb1f182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of times reordering may be invoked.  <a href="#a3a2e39aeebc215847d374a01bb1f182b">More...</a><br /></td></tr>
<tr class="separator:a3a2e39aeebc215847d374a01bb1f182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61141274ba36755e4c88a4c1597b9847"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a61141274ba36755e4c88a4c1597b9847">Cudd_ReadReorderingTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a61141274ba36755e4c88a4c1597b9847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in reordering.  <a href="#a61141274ba36755e4c88a4c1597b9847">More...</a><br /></td></tr>
<tr class="separator:a61141274ba36755e4c88a4c1597b9847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aaebdd320041ddca11fdb0f3414f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a50aaebdd320041ddca11fdb0f3414f0c">Cudd_ReadGarbageCollections</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a50aaebdd320041ddca11fdb0f3414f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times garbage collection has occurred.  <a href="#a50aaebdd320041ddca11fdb0f3414f0c">More...</a><br /></td></tr>
<tr class="separator:a50aaebdd320041ddca11fdb0f3414f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653fa9231b3d68947521175de74f26b8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a653fa9231b3d68947521175de74f26b8">Cudd_ReadGarbageCollectionTime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a653fa9231b3d68947521175de74f26b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time spent in garbage collection.  <a href="#a653fa9231b3d68947521175de74f26b8">More...</a><br /></td></tr>
<tr class="separator:a653fa9231b3d68947521175de74f26b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525911b0006fddcbcf698a077b874cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af525911b0006fddcbcf698a077b874cb">Cudd_ReadNodesFreed</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af525911b0006fddcbcf698a077b874cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes freed.  <a href="#af525911b0006fddcbcf698a077b874cb">More...</a><br /></td></tr>
<tr class="separator:af525911b0006fddcbcf698a077b874cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e283a368a08c5ac96101ee7e9b525c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae7e283a368a08c5ac96101ee7e9b525c">Cudd_ReadNodesDropped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae7e283a368a08c5ac96101ee7e9b525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes dropped.  <a href="#ae7e283a368a08c5ac96101ee7e9b525c">More...</a><br /></td></tr>
<tr class="separator:ae7e283a368a08c5ac96101ee7e9b525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf224e24889082c229d56db1f982f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acebf224e24889082c229d56db1f982f3">Cudd_ReadUniqueLookUps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:acebf224e24889082c229d56db1f982f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of look-ups in the unique table.  <a href="#acebf224e24889082c229d56db1f982f3">More...</a><br /></td></tr>
<tr class="separator:acebf224e24889082c229d56db1f982f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa1d598d1d5830c72b33aca86e511c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aaaa1d598d1d5830c72b33aca86e511c1">Cudd_ReadUniqueLinks</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aaaa1d598d1d5830c72b33aca86e511c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of links followed in the unique table.  <a href="#aaaa1d598d1d5830c72b33aca86e511c1">More...</a><br /></td></tr>
<tr class="separator:aaaa1d598d1d5830c72b33aca86e511c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112841ed78d8f90d31ee879684775b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a112841ed78d8f90d31ee879684775b51">Cudd_ReadSiftMaxVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a112841ed78d8f90d31ee879684775b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the siftMaxVar parameter of the manager.  <a href="#a112841ed78d8f90d31ee879684775b51">More...</a><br /></td></tr>
<tr class="separator:a112841ed78d8f90d31ee879684775b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ad3e7bf12607f58756e15f2b1251aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a23ad3e7bf12607f58756e15f2b1251aa">Cudd_SetSiftMaxVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int smv)</td></tr>
<tr class="memdesc:a23ad3e7bf12607f58756e15f2b1251aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the siftMaxVar parameter of the manager.  <a href="#a23ad3e7bf12607f58756e15f2b1251aa">More...</a><br /></td></tr>
<tr class="separator:a23ad3e7bf12607f58756e15f2b1251aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a54fbfd8fa0597af542ad9dfa4eefa2da">Cudd_ReadSiftMaxSwap</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the siftMaxSwap parameter of the manager.  <a href="#a54fbfd8fa0597af542ad9dfa4eefa2da">More...</a><br /></td></tr>
<tr class="separator:a54fbfd8fa0597af542ad9dfa4eefa2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40246082da9de77243088f935be6e2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a40246082da9de77243088f935be6e2e6">Cudd_SetSiftMaxSwap</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int sms)</td></tr>
<tr class="memdesc:a40246082da9de77243088f935be6e2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the siftMaxSwap parameter of the manager.  <a href="#a40246082da9de77243088f935be6e2e6">More...</a><br /></td></tr>
<tr class="separator:a40246082da9de77243088f935be6e2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f3600540de47d20e85eb4036af6e49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a23f3600540de47d20e85eb4036af6e49">Cudd_ReadMaxGrowth</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a23f3600540de47d20e85eb4036af6e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxGrowth parameter of the manager.  <a href="#a23f3600540de47d20e85eb4036af6e49">More...</a><br /></td></tr>
<tr class="separator:a23f3600540de47d20e85eb4036af6e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa3a621a6133ce4203b8bfa351d5de4ea">Cudd_SetMaxGrowth</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, double mg)</td></tr>
<tr class="memdesc:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxGrowth parameter of the manager.  <a href="#aa3a621a6133ce4203b8bfa351d5de4ea">More...</a><br /></td></tr>
<tr class="separator:aa3a621a6133ce4203b8bfa351d5de4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692abb5fde2011b2a3cec010946eebca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a692abb5fde2011b2a3cec010946eebca">Cudd_ReadMaxGrowthAlternate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a692abb5fde2011b2a3cec010946eebca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maxGrowthAlt parameter of the manager.  <a href="#a692abb5fde2011b2a3cec010946eebca">More...</a><br /></td></tr>
<tr class="separator:a692abb5fde2011b2a3cec010946eebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7d4358c1f00a31b657c937b8e64ec6e6">Cudd_SetMaxGrowthAlternate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, double mg)</td></tr>
<tr class="memdesc:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maxGrowthAlt parameter of the manager.  <a href="#a7d4358c1f00a31b657c937b8e64ec6e6">More...</a><br /></td></tr>
<tr class="separator:a7d4358c1f00a31b657c937b8e64ec6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5283d665223378e10425342dad1684b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa5283d665223378e10425342dad1684b">Cudd_ReadReorderingCycle</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aa5283d665223378e10425342dad1684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the reordCycle parameter of the manager.  <a href="#aa5283d665223378e10425342dad1684b">More...</a><br /></td></tr>
<tr class="separator:aa5283d665223378e10425342dad1684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd23a86c046d74935d746757846d1148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afd23a86c046d74935d746757846d1148">Cudd_SetReorderingCycle</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int cycle)</td></tr>
<tr class="memdesc:afd23a86c046d74935d746757846d1148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reordCycle parameter of the manager.  <a href="#afd23a86c046d74935d746757846d1148">More...</a><br /></td></tr>
<tr class="separator:afd23a86c046d74935d746757846d1148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c38a74f4362bd57bcb44593a3f515d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a53c38a74f4362bd57bcb44593a3f515d">Cudd_NodeReadIndex</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a53c38a74f4362bd57bcb44593a3f515d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the node.  <a href="#a53c38a74f4362bd57bcb44593a3f515d">More...</a><br /></td></tr>
<tr class="separator:a53c38a74f4362bd57bcb44593a3f515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfa59899b792c9f47a612ceba42c976"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aacfa59899b792c9f47a612ceba42c976">Cudd_ReadPerm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:aacfa59899b792c9f47a612ceba42c976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position of the i-th variable in the order.  <a href="#aacfa59899b792c9f47a612ceba42c976">More...</a><br /></td></tr>
<tr class="separator:aacfa59899b792c9f47a612ceba42c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965c64ce6822b03441ce7445e8187aa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a965c64ce6822b03441ce7445e8187aa3">Cudd_ReadPermZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a965c64ce6822b03441ce7445e8187aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position of the i-th ZDD variable in the order.  <a href="#a965c64ce6822b03441ce7445e8187aa3">More...</a><br /></td></tr>
<tr class="separator:a965c64ce6822b03441ce7445e8187aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae16ce73ed2e5afcd0dd1c1db43884d2a">Cudd_ReadInvPerm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the variable currently in the i-th position of the order.  <a href="#ae16ce73ed2e5afcd0dd1c1db43884d2a">More...</a><br /></td></tr>
<tr class="separator:ae16ce73ed2e5afcd0dd1c1db43884d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f47219044e26a1be7699014dcc021a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a30f47219044e26a1be7699014dcc021a">Cudd_ReadInvPermZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a30f47219044e26a1be7699014dcc021a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ZDD variable currently in the i-th position of the order.  <a href="#a30f47219044e26a1be7699014dcc021a">More...</a><br /></td></tr>
<tr class="separator:a30f47219044e26a1be7699014dcc021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8f64c98953fd110d0e5146bcadaca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a44d8f64c98953fd110d0e5146bcadaca">Cudd_ReadVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int i)</td></tr>
<tr class="memdesc:a44d8f64c98953fd110d0e5146bcadaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i-th element of the vars array.  <a href="#a44d8f64c98953fd110d0e5146bcadaca">More...</a><br /></td></tr>
<tr class="separator:a44d8f64c98953fd110d0e5146bcadaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac711d8ce9d243e16246b83e3c1f04199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac711d8ce9d243e16246b83e3c1f04199">Cudd_ReadEpsilon</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac711d8ce9d243e16246b83e3c1f04199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the epsilon parameter of the manager.  <a href="#ac711d8ce9d243e16246b83e3c1f04199">More...</a><br /></td></tr>
<tr class="separator:ac711d8ce9d243e16246b83e3c1f04199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a30ef132c1f56bdb0e26efc81fa695cf3">Cudd_SetEpsilon</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> ep)</td></tr>
<tr class="memdesc:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the epsilon parameter of the manager to ep.  <a href="#a30ef132c1f56bdb0e26efc81fa695cf3">More...</a><br /></td></tr>
<tr class="separator:a30ef132c1f56bdb0e26efc81fa695cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8f2639c79f7b9c58367cbfc0f55ca3b5">Cudd_ReadGroupcheck</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the groupcheck parameter of the manager.  <a href="#a8f2639c79f7b9c58367cbfc0f55ca3b5">More...</a><br /></td></tr>
<tr class="separator:a8f2639c79f7b9c58367cbfc0f55ca3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e7fa94656ed131aa67ca1ea15a031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aee7e7fa94656ed131aa67ca1ea15a031">Cudd_SetGroupcheck</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a> gc)</td></tr>
<tr class="memdesc:aee7e7fa94656ed131aa67ca1ea15a031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameter groupcheck of the manager to gc.  <a href="#aee7e7fa94656ed131aa67ca1ea15a031">More...</a><br /></td></tr>
<tr class="separator:aee7e7fa94656ed131aa67ca1ea15a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adf441cdb56f24a9e3e20f6e87cc571c8">Cudd_GarbageCollectionEnabled</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether garbage collection is enabled.  <a href="#adf441cdb56f24a9e3e20f6e87cc571c8">More...</a><br /></td></tr>
<tr class="separator:adf441cdb56f24a9e3e20f6e87cc571c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a5511bcc805af71fc1fb5abba96f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a95a5511bcc805af71fc1fb5abba96f1e">Cudd_EnableGarbageCollection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a95a5511bcc805af71fc1fb5abba96f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables garbage collection.  <a href="#a95a5511bcc805af71fc1fb5abba96f1e">More...</a><br /></td></tr>
<tr class="separator:a95a5511bcc805af71fc1fb5abba96f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1def55437ab00e012fba1a98bc3a941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab1def55437ab00e012fba1a98bc3a941">Cudd_DisableGarbageCollection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ab1def55437ab00e012fba1a98bc3a941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables garbage collection.  <a href="#ab1def55437ab00e012fba1a98bc3a941">More...</a><br /></td></tr>
<tr class="separator:ab1def55437ab00e012fba1a98bc3a941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34d186620ce66627e57bbccfa24a892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae34d186620ce66627e57bbccfa24a892">Cudd_DeadAreCounted</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ae34d186620ce66627e57bbccfa24a892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether dead nodes are counted towards triggering reordering.  <a href="#ae34d186620ce66627e57bbccfa24a892">More...</a><br /></td></tr>
<tr class="separator:ae34d186620ce66627e57bbccfa24a892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b407453f68498df9b9783f88401cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af0b407453f68498df9b9783f88401cf5">Cudd_TurnOnCountDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af0b407453f68498df9b9783f88401cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the dead nodes to be counted towards triggering reordering.  <a href="#af0b407453f68498df9b9783f88401cf5">More...</a><br /></td></tr>
<tr class="separator:af0b407453f68498df9b9783f88401cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b822894a35380ffca9e555286213484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5b822894a35380ffca9e555286213484">Cudd_TurnOffCountDead</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a5b822894a35380ffca9e555286213484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the dead nodes not to be counted towards triggering reordering.  <a href="#a5b822894a35380ffca9e555286213484">More...</a><br /></td></tr>
<tr class="separator:a5b822894a35380ffca9e555286213484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac305e7d5aaa2c3808db94795dc0a1150"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac305e7d5aaa2c3808db94795dc0a1150">Cudd_ReadRecomb</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:ac305e7d5aaa2c3808db94795dc0a1150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the recombination parameter used in group sifting.  <a href="#ac305e7d5aaa2c3808db94795dc0a1150">More...</a><br /></td></tr>
<tr class="separator:ac305e7d5aaa2c3808db94795dc0a1150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f934b27bc1d1ea947f410c8aedd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac68f934b27bc1d1ea947f410c8aedd36">Cudd_SetRecomb</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int recomb)</td></tr>
<tr class="memdesc:ac68f934b27bc1d1ea947f410c8aedd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the recombination parameter used in group sifting.  <a href="#ac68f934b27bc1d1ea947f410c8aedd36">More...</a><br /></td></tr>
<tr class="separator:ac68f934b27bc1d1ea947f410c8aedd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3028ccbe6fb46efd6565d0f4aab78738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3028ccbe6fb46efd6565d0f4aab78738">Cudd_ReadSymmviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a3028ccbe6fb46efd6565d0f4aab78738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the symmviolation parameter used in group sifting.  <a href="#a3028ccbe6fb46efd6565d0f4aab78738">More...</a><br /></td></tr>
<tr class="separator:a3028ccbe6fb46efd6565d0f4aab78738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb84b628160417172cb44e22e2067b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5bb84b628160417172cb44e22e2067b7">Cudd_SetSymmviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int symmviolation)</td></tr>
<tr class="memdesc:a5bb84b628160417172cb44e22e2067b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the symmviolation parameter used in group sifting.  <a href="#a5bb84b628160417172cb44e22e2067b7">More...</a><br /></td></tr>
<tr class="separator:a5bb84b628160417172cb44e22e2067b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89117a52be055c338311b1380d511375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a89117a52be055c338311b1380d511375">Cudd_ReadArcviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a89117a52be055c338311b1380d511375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the arcviolation parameter used in group sifting.  <a href="#a89117a52be055c338311b1380d511375">More...</a><br /></td></tr>
<tr class="separator:a89117a52be055c338311b1380d511375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064405f352a9d93a6ee16cfa5d2512c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3064405f352a9d93a6ee16cfa5d2512c">Cudd_SetArcviolation</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int arcviolation)</td></tr>
<tr class="memdesc:a3064405f352a9d93a6ee16cfa5d2512c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the arcviolation parameter used in group sifting.  <a href="#a3064405f352a9d93a6ee16cfa5d2512c">More...</a><br /></td></tr>
<tr class="separator:a3064405f352a9d93a6ee16cfa5d2512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e760e63a14cd28172b2371c8419b0d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1e760e63a14cd28172b2371c8419b0d9">Cudd_ReadPopulationSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1e760e63a14cd28172b2371c8419b0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current size of the population used by the genetic algorithm for variable reordering.  <a href="#a1e760e63a14cd28172b2371c8419b0d9">More...</a><br /></td></tr>
<tr class="separator:a1e760e63a14cd28172b2371c8419b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#abbdf2ca87a414bb36bfbb6247a8915ec">Cudd_SetPopulationSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int populationSize)</td></tr>
<tr class="memdesc:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the population used by the genetic algorithm for variable reordering.  <a href="#abbdf2ca87a414bb36bfbb6247a8915ec">More...</a><br /></td></tr>
<tr class="separator:abbdf2ca87a414bb36bfbb6247a8915ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2609fe9051be1a8ab6d305d38bfb5956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2609fe9051be1a8ab6d305d38bfb5956">Cudd_ReadNumberXovers</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2609fe9051be1a8ab6d305d38bfb5956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current number of crossovers used by the genetic algorithm for variable reordering.  <a href="#a2609fe9051be1a8ab6d305d38bfb5956">More...</a><br /></td></tr>
<tr class="separator:a2609fe9051be1a8ab6d305d38bfb5956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae8b2c48e26b4178cf6536f4ce253d9b1">Cudd_SetNumberXovers</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int numberXovers)</td></tr>
<tr class="memdesc:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of crossovers used by the genetic algorithm for variable reordering.  <a href="#ae8b2c48e26b4178cf6536f4ce253d9b1">More...</a><br /></td></tr>
<tr class="separator:ae8b2c48e26b4178cf6536f4ce253d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a93f6c6fc1714330d1554a0f2e562ae1f">Cudd_ReadOrderRandomization</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the order randomization factor.  <a href="#a93f6c6fc1714330d1554a0f2e562ae1f">More...</a><br /></td></tr>
<tr class="separator:a93f6c6fc1714330d1554a0f2e562ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58f1cfc002a5a2af126f29e7377243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3e58f1cfc002a5a2af126f29e7377243">Cudd_SetOrderRandomization</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int factor)</td></tr>
<tr class="memdesc:a3e58f1cfc002a5a2af126f29e7377243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the order randomization factor.  <a href="#a3e58f1cfc002a5a2af126f29e7377243">More...</a><br /></td></tr>
<tr class="separator:a3e58f1cfc002a5a2af126f29e7377243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952c97ec2d8b0a73f759e7e993e1e367"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a952c97ec2d8b0a73f759e7e993e1e367">Cudd_ReadMemoryInUse</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a952c97ec2d8b0a73f759e7e993e1e367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory in use by the manager measured in bytes.  <a href="#a952c97ec2d8b0a73f759e7e993e1e367">More...</a><br /></td></tr>
<tr class="separator:a952c97ec2d8b0a73f759e7e993e1e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0883e74086d9f61c2988ba614e9e649e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0883e74086d9f61c2988ba614e9e649e">Cudd_PrintInfo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:a0883e74086d9f61c2988ba614e9e649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out statistics and settings for a CUDD manager.  <a href="#a0883e74086d9f61c2988ba614e9e649e">More...</a><br /></td></tr>
<tr class="separator:a0883e74086d9f61c2988ba614e9e649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39633df05be731b6b145d65f83aed572"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a39633df05be731b6b145d65f83aed572">Cudd_ReadPeakNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a39633df05be731b6b145d65f83aed572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the peak number of nodes.  <a href="#a39633df05be731b6b145d65f83aed572">More...</a><br /></td></tr>
<tr class="separator:a39633df05be731b6b145d65f83aed572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a120dd8ff3d2b0a4df7600a820175f1d4">Cudd_ReadPeakLiveNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the peak number of live nodes.  <a href="#a120dd8ff3d2b0a4df7600a820175f1d4">More...</a><br /></td></tr>
<tr class="separator:a120dd8ff3d2b0a4df7600a820175f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba2c88b8f70df51791c26ffde800fc7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9ba2c88b8f70df51791c26ffde800fc7">Cudd_ReadNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9ba2c88b8f70df51791c26ffde800fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of nodes in BDDs and ADDs.  <a href="#a9ba2c88b8f70df51791c26ffde800fc7">More...</a><br /></td></tr>
<tr class="separator:a9ba2c88b8f70df51791c26ffde800fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4c015c746d9c71fb9b57249f2a4ccd72">Cudd_zddReadNodeCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of nodes in ZDDs.  <a href="#a4c015c746d9c71fb9b57249f2a4ccd72">More...</a><br /></td></tr>
<tr class="separator:a4c015c746d9c71fb9b57249f2a4ccd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6884f064de544463f006f9104e4afa74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6884f064de544463f006f9104e4afa74">Cudd_AddHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a6884f064de544463f006f9104e4afa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to a hook.  <a href="#a6884f064de544463f006f9104e4afa74">More...</a><br /></td></tr>
<tr class="separator:a6884f064de544463f006f9104e4afa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c732be4af510054662cd6e6f0a5772f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0c732be4af510054662cd6e6f0a5772f">Cudd_RemoveHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a0c732be4af510054662cd6e6f0a5772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a function from a hook.  <a href="#a0c732be4af510054662cd6e6f0a5772f">More...</a><br /></td></tr>
<tr class="separator:a0c732be4af510054662cd6e6f0a5772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eb04332db0a87f173b7638080ec856"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a55eb04332db0a87f173b7638080ec856">Cudd_IsInHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a> f, <a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a> where)</td></tr>
<tr class="memdesc:a55eb04332db0a87f173b7638080ec856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a function is in a hook.  <a href="#a55eb04332db0a87f173b7638080ec856">More...</a><br /></td></tr>
<tr class="separator:a55eb04332db0a87f173b7638080ec856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852da7502c07042fde873b504aaa4573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a852da7502c07042fde873b504aaa4573">Cudd_StdPreReordHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:a852da7502c07042fde873b504aaa4573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample hook function to call before reordering.  <a href="#a852da7502c07042fde873b504aaa4573">More...</a><br /></td></tr>
<tr class="separator:a852da7502c07042fde873b504aaa4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b17a13db3a9537a0a13df5507f4d11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa3b17a13db3a9537a0a13df5507f4d11">Cudd_StdPostReordHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:aa3b17a13db3a9537a0a13df5507f4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample hook function to call after reordering.  <a href="#aa3b17a13db3a9537a0a13df5507f4d11">More...</a><br /></td></tr>
<tr class="separator:aa3b17a13db3a9537a0a13df5507f4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adfe5374e85cf3fb0827307b1e3cc5e07">Cudd_EnableReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables reporting of reordering stats.  <a href="#adfe5374e85cf3fb0827307b1e3cc5e07">More...</a><br /></td></tr>
<tr class="separator:adfe5374e85cf3fb0827307b1e3cc5e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249298e38710246ab1ead014cfe54dd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a249298e38710246ab1ead014cfe54dd9">Cudd_DisableReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a249298e38710246ab1ead014cfe54dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables reporting of reordering stats.  <a href="#a249298e38710246ab1ead014cfe54dd9">More...</a><br /></td></tr>
<tr class="separator:a249298e38710246ab1ead014cfe54dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a634a339969d6d84e3db858f3f77be4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4a634a339969d6d84e3db858f3f77be4">Cudd_ReorderingReporting</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a4a634a339969d6d84e3db858f3f77be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if reporting of reordering stats is enabled; 0 otherwise.  <a href="#a4a634a339969d6d84e3db858f3f77be4">More...</a><br /></td></tr>
<tr class="separator:a4a634a339969d6d84e3db858f3f77be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba970524139c009227b2fa0fc8cac0eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aba970524139c009227b2fa0fc8cac0eb">Cudd_PrintGroupedOrder</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, const char *str, void *data)</td></tr>
<tr class="memdesc:aba970524139c009227b2fa0fc8cac0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook function to print the current variable order.  <a href="#aba970524139c009227b2fa0fc8cac0eb">More...</a><br /></td></tr>
<tr class="separator:aba970524139c009227b2fa0fc8cac0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa547783b2cd3e54062864543fba0de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6aa547783b2cd3e54062864543fba0de">Cudd_EnableOrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a6aa547783b2cd3e54062864543fba0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables monitoring of ordering.  <a href="#a6aa547783b2cd3e54062864543fba0de">More...</a><br /></td></tr>
<tr class="separator:a6aa547783b2cd3e54062864543fba0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1363eeb294a402d754f142c2022d4562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1363eeb294a402d754f142c2022d4562">Cudd_DisableOrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a1363eeb294a402d754f142c2022d4562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables monitoring of ordering.  <a href="#a1363eeb294a402d754f142c2022d4562">More...</a><br /></td></tr>
<tr class="separator:a1363eeb294a402d754f142c2022d4562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d721c40b8c47401a0739027cf5a571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a93d721c40b8c47401a0739027cf5a571">Cudd_OrderingMonitoring</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a93d721c40b8c47401a0739027cf5a571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if monitoring of ordering is enabled; 0 otherwise.  <a href="#a93d721c40b8c47401a0739027cf5a571">More...</a><br /></td></tr>
<tr class="separator:a93d721c40b8c47401a0739027cf5a571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4a097e769d11868f760b920e6f1da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2d4a097e769d11868f760b920e6f1da8">Cudd_SetApplicationHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, void *value)</td></tr>
<tr class="memdesc:a2d4a097e769d11868f760b920e6f1da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application hook.  <a href="#a2d4a097e769d11868f760b920e6f1da8">More...</a><br /></td></tr>
<tr class="separator:a2d4a097e769d11868f760b920e6f1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f98975109e7d3afd1bad0716e4d6666"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9f98975109e7d3afd1bad0716e4d6666">Cudd_ReadApplicationHook</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9f98975109e7d3afd1bad0716e4d6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the application hook.  <a href="#a9f98975109e7d3afd1bad0716e4d6666">More...</a><br /></td></tr>
<tr class="separator:a9f98975109e7d3afd1bad0716e4d6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b83058c815b1ca112c6a9c74525ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a27114b4342bc1b987f35d751eae2444b">Cudd_ErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a988b83058c815b1ca112c6a9c74525ad">Cudd_ReadErrorCode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a988b83058c815b1ca112c6a9c74525ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the code of the last error.  <a href="#a988b83058c815b1ca112c6a9c74525ad">More...</a><br /></td></tr>
<tr class="separator:a988b83058c815b1ca112c6a9c74525ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3a189c261ed9f698ace55ade32af01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aed3a189c261ed9f698ace55ade32af01">Cudd_ClearErrorCode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aed3a189c261ed9f698ace55ade32af01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the error code of a manager.  <a href="#aed3a189c261ed9f698ace55ade32af01">More...</a><br /></td></tr>
<tr class="separator:aed3a189c261ed9f698ace55ade32af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8941f373e5e1156b2e42af09f4247d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8941f373e5e1156b2e42af09f4247d47">Cudd_InstallOutOfMemoryHandler</a> (<a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> newHandler)</td></tr>
<tr class="memdesc:a8941f373e5e1156b2e42af09f4247d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a handler for failed memory allocations.  <a href="#a8941f373e5e1156b2e42af09f4247d47">More...</a><br /></td></tr>
<tr class="separator:a8941f373e5e1156b2e42af09f4247d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811b2599d1ed4a66001b7577cbbbd33d"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a811b2599d1ed4a66001b7577cbbbd33d">Cudd_ReadStdout</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a811b2599d1ed4a66001b7577cbbbd33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the stdout of a manager.  <a href="#a811b2599d1ed4a66001b7577cbbbd33d">More...</a><br /></td></tr>
<tr class="separator:a811b2599d1ed4a66001b7577cbbbd33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3080103403d6ba1f79b04f4e701edbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac3080103403d6ba1f79b04f4e701edbc">Cudd_SetStdout</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:ac3080103403d6ba1f79b04f4e701edbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stdout of a manager.  <a href="#ac3080103403d6ba1f79b04f4e701edbc">More...</a><br /></td></tr>
<tr class="separator:ac3080103403d6ba1f79b04f4e701edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9830fe86096e7721263e058ba7d93d26"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9830fe86096e7721263e058ba7d93d26">Cudd_ReadStderr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a9830fe86096e7721263e058ba7d93d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the stderr of a manager.  <a href="#a9830fe86096e7721263e058ba7d93d26">More...</a><br /></td></tr>
<tr class="separator:a9830fe86096e7721263e058ba7d93d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910e7309dc7551140d71871619ead247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a910e7309dc7551140d71871619ead247">Cudd_SetStderr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, FILE *fp)</td></tr>
<tr class="memdesc:a910e7309dc7551140d71871619ead247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stderr of a manager.  <a href="#a910e7309dc7551140d71871619ead247">More...</a><br /></td></tr>
<tr class="separator:a910e7309dc7551140d71871619ead247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3820fb326bce09797fda8439b5daa4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adc3820fb326bce09797fda8439b5daa4">Cudd_ReadNextReordering</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:adc3820fb326bce09797fda8439b5daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the threshold for the next dynamic reordering.  <a href="#adc3820fb326bce09797fda8439b5daa4">More...</a><br /></td></tr>
<tr class="separator:adc3820fb326bce09797fda8439b5daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d62c965eabd4ec777af47acd790ee47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3d62c965eabd4ec777af47acd790ee47">Cudd_SetNextReordering</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int next)</td></tr>
<tr class="memdesc:a3d62c965eabd4ec777af47acd790ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the threshold for the next dynamic reordering.  <a href="#a3d62c965eabd4ec777af47acd790ee47">More...</a><br /></td></tr>
<tr class="separator:a3d62c965eabd4ec777af47acd790ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2cb92ccf940cabf261d35ccc1945e7cf">Cudd_ReadSwapSteps</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of elementary reordering steps.  <a href="#a2cb92ccf940cabf261d35ccc1945e7cf">More...</a><br /></td></tr>
<tr class="separator:a2cb92ccf940cabf261d35ccc1945e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afbdb9c3955275888ec9cb60711a57"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af6afbdb9c3955275888ec9cb60711a57">Cudd_ReadMaxLive</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:af6afbdb9c3955275888ec9cb60711a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maximum allowed number of live nodes.  <a href="#af6afbdb9c3955275888ec9cb60711a57">More...</a><br /></td></tr>
<tr class="separator:af6afbdb9c3955275888ec9cb60711a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553f7975b60ebe4a38141cbff1eebea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac553f7975b60ebe4a38141cbff1eebea">Cudd_SetMaxLive</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, unsigned int maxLive)</td></tr>
<tr class="memdesc:ac553f7975b60ebe4a38141cbff1eebea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum allowed number of live nodes.  <a href="#ac553f7975b60ebe4a38141cbff1eebea">More...</a><br /></td></tr>
<tr class="separator:ac553f7975b60ebe4a38141cbff1eebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef52798a6b7994a3038335d36ec9f051"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aef52798a6b7994a3038335d36ec9f051">Cudd_ReadMaxMemory</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:aef52798a6b7994a3038335d36ec9f051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the maximum allowed memory.  <a href="#aef52798a6b7994a3038335d36ec9f051">More...</a><br /></td></tr>
<tr class="separator:aef52798a6b7994a3038335d36ec9f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d15a525874908e9230881bccabbb993"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0d15a525874908e9230881bccabbb993">Cudd_SetMaxMemory</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, size_t maxMemory)</td></tr>
<tr class="memdesc:a0d15a525874908e9230881bccabbb993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum allowed memory.  <a href="#a0d15a525874908e9230881bccabbb993">More...</a><br /></td></tr>
<tr class="separator:a0d15a525874908e9230881bccabbb993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acdc5b22c44f316a98c894998ca93d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5acdc5b22c44f316a98c894998ca93d8">Cudd_bddBindVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a5acdc5b22c44f316a98c894998ca93d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents sifting of a variable.  <a href="#a5acdc5b22c44f316a98c894998ca93d8">More...</a><br /></td></tr>
<tr class="separator:a5acdc5b22c44f316a98c894998ca93d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944f587db5ad4427ea36912313adccaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a944f587db5ad4427ea36912313adccaa">Cudd_bddUnbindVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a944f587db5ad4427ea36912313adccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the sifting of a variable.  <a href="#a944f587db5ad4427ea36912313adccaa">More...</a><br /></td></tr>
<tr class="separator:a944f587db5ad4427ea36912313adccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d01993b4162e8ece02e339ecb0a456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a88d01993b4162e8ece02e339ecb0a456">Cudd_bddVarIsBound</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a88d01993b4162e8ece02e339ecb0a456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether a variable can be sifted.  <a href="#a88d01993b4162e8ece02e339ecb0a456">More...</a><br /></td></tr>
<tr class="separator:a88d01993b4162e8ece02e339ecb0a456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8603fe2007fd37712dd51ef0b78a5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac8603fe2007fd37712dd51ef0b78a5c7">Cudd_addExistAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:ac8603fe2007fd37712dd51ef0b78a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Existentially Abstracts all the variables in cube from f.  <a href="#ac8603fe2007fd37712dd51ef0b78a5c7">More...</a><br /></td></tr>
<tr class="separator:ac8603fe2007fd37712dd51ef0b78a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57290efa5451fcece67fc41046bd3a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae57290efa5451fcece67fc41046bd3a3">Cudd_addUnivAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:ae57290efa5451fcece67fc41046bd3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universally Abstracts all the variables in cube from f.  <a href="#ae57290efa5451fcece67fc41046bd3a3">More...</a><br /></td></tr>
<tr class="separator:ae57290efa5451fcece67fc41046bd3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6fd0eef3dd314aedc861a30f4b71e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8c6fd0eef3dd314aedc861a30f4b71e7">Cudd_addOrAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:a8c6fd0eef3dd314aedc861a30f4b71e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunctively abstracts all the variables in cube from the 0-1 ADD f.  <a href="#a8c6fd0eef3dd314aedc861a30f4b71e7">More...</a><br /></td></tr>
<tr class="separator:a8c6fd0eef3dd314aedc861a30f4b71e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8300acf801bcde789878fccb3635d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae8300acf801bcde789878fccb3635d5f">Cudd_addApply</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a2aa941e1d7fbaa50cae391a6dfd229b8">DD_AOP</a> op, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:ae8300acf801bcde789878fccb3635d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies op to the corresponding discriminants of f and g.  <a href="#ae8300acf801bcde789878fccb3635d5f">More...</a><br /></td></tr>
<tr class="separator:ae8300acf801bcde789878fccb3635d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab378c5151c55c439cd5579d871f554ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab378c5151c55c439cd5579d871f554ce">Cudd_addPlus</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:ab378c5151c55c439cd5579d871f554ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point addition.  <a href="#ab378c5151c55c439cd5579d871f554ce">More...</a><br /></td></tr>
<tr class="separator:ab378c5151c55c439cd5579d871f554ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69854ec8f0a7ff4535c07cad3522de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab69854ec8f0a7ff4535c07cad3522de4">Cudd_addTimes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:ab69854ec8f0a7ff4535c07cad3522de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point multiplication.  <a href="#ab69854ec8f0a7ff4535c07cad3522de4">More...</a><br /></td></tr>
<tr class="separator:ab69854ec8f0a7ff4535c07cad3522de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e98e508843c4aa0ad42311d5ab525d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8e98e508843c4aa0ad42311d5ab525d7">Cudd_addThreshold</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a8e98e508843c4aa0ad42311d5ab525d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">f if f&ge;g; 0 if f&lt;g.  <a href="#a8e98e508843c4aa0ad42311d5ab525d7">More...</a><br /></td></tr>
<tr class="separator:a8e98e508843c4aa0ad42311d5ab525d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17119bcb91dba087618b08e7595ecb66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a17119bcb91dba087618b08e7595ecb66">Cudd_addSetNZ</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a17119bcb91dba087618b08e7595ecb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator sets f to the value of g wherever g != 0.  <a href="#a17119bcb91dba087618b08e7595ecb66">More...</a><br /></td></tr>
<tr class="separator:a17119bcb91dba087618b08e7595ecb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a04a3a242f175d4db3e4444f7e9e8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0a04a3a242f175d4db3e4444f7e9e8b8">Cudd_addDivide</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a0a04a3a242f175d4db3e4444f7e9e8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point division.  <a href="#a0a04a3a242f175d4db3e4444f7e9e8b8">More...</a><br /></td></tr>
<tr class="separator:a0a04a3a242f175d4db3e4444f7e9e8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b49e50384beae41a27c5cf7f31faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1d3b49e50384beae41a27c5cf7f31faf">Cudd_addMinus</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a1d3b49e50384beae41a27c5cf7f31faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point subtraction.  <a href="#a1d3b49e50384beae41a27c5cf7f31faf">More...</a><br /></td></tr>
<tr class="separator:a1d3b49e50384beae41a27c5cf7f31faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432fc72cd4668cc0d6a6ce7ca1d1e7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a432fc72cd4668cc0d6a6ce7ca1d1e7f3">Cudd_addMinimum</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a432fc72cd4668cc0d6a6ce7ca1d1e7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point min.  <a href="#a432fc72cd4668cc0d6a6ce7ca1d1e7f3">More...</a><br /></td></tr>
<tr class="separator:a432fc72cd4668cc0d6a6ce7ca1d1e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be922ac5d59b292f527993509fda58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6be922ac5d59b292f527993509fda58f">Cudd_addMaximum</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a6be922ac5d59b292f527993509fda58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer and floating point max.  <a href="#a6be922ac5d59b292f527993509fda58f">More...</a><br /></td></tr>
<tr class="separator:a6be922ac5d59b292f527993509fda58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4954870e0caa4a99e915c40a9c3ff792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4954870e0caa4a99e915c40a9c3ff792">Cudd_addOneZeroMaximum</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a4954870e0caa4a99e915c40a9c3ff792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if f &gt; g and 0 otherwise.  <a href="#a4954870e0caa4a99e915c40a9c3ff792">More...</a><br /></td></tr>
<tr class="separator:a4954870e0caa4a99e915c40a9c3ff792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214dc5cef566e46a3699bae9f19ba47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac214dc5cef566e46a3699bae9f19ba47">Cudd_addDiff</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:ac214dc5cef566e46a3699bae9f19ba47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns plusinfinity if f=g; returns min(f,g) if f!=g.  <a href="#ac214dc5cef566e46a3699bae9f19ba47">More...</a><br /></td></tr>
<tr class="separator:ac214dc5cef566e46a3699bae9f19ba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e9945c51e576ce46ef1b2dbd0a470a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a09e9945c51e576ce46ef1b2dbd0a470a">Cudd_addAgreement</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a09e9945c51e576ce46ef1b2dbd0a470a"><td class="mdescLeft">&#160;</td><td class="mdescRight">f if f==g; background if f!=g.  <a href="#a09e9945c51e576ce46ef1b2dbd0a470a">More...</a><br /></td></tr>
<tr class="separator:a09e9945c51e576ce46ef1b2dbd0a470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a761e68f7e19fa2a840bdbb84e898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a924a761e68f7e19fa2a840bdbb84e898">Cudd_addOr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a924a761e68f7e19fa2a840bdbb84e898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunction of two 0-1 ADDs.  <a href="#a924a761e68f7e19fa2a840bdbb84e898">More...</a><br /></td></tr>
<tr class="separator:a924a761e68f7e19fa2a840bdbb84e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa979af17da5b8c71fe71d44422beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6cfa979af17da5b8c71fe71d44422beb">Cudd_addNand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a6cfa979af17da5b8c71fe71d44422beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">NAND of two 0-1 ADDs.  <a href="#a6cfa979af17da5b8c71fe71d44422beb">More...</a><br /></td></tr>
<tr class="separator:a6cfa979af17da5b8c71fe71d44422beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9307c6070c4c7ec72a0427b96b4a8cb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9307c6070c4c7ec72a0427b96b4a8cb2">Cudd_addNor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a9307c6070c4c7ec72a0427b96b4a8cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOR of two 0-1 ADDs.  <a href="#a9307c6070c4c7ec72a0427b96b4a8cb2">More...</a><br /></td></tr>
<tr class="separator:a9307c6070c4c7ec72a0427b96b4a8cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d32f9713422bd9fdbe073406b9c631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af0d32f9713422bd9fdbe073406b9c631">Cudd_addXor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:af0d32f9713422bd9fdbe073406b9c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR of two 0-1 ADDs.  <a href="#af0d32f9713422bd9fdbe073406b9c631">More...</a><br /></td></tr>
<tr class="separator:af0d32f9713422bd9fdbe073406b9c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b42ff91ece2d4abef597a964ad0e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9e0b42ff91ece2d4abef597a964ad0e9">Cudd_addXnor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **f, <a class="el" href="structDdNode.html">DdNode</a> **g)</td></tr>
<tr class="memdesc:a9e0b42ff91ece2d4abef597a964ad0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">XNOR of two 0-1 ADDs.  <a href="#a9e0b42ff91ece2d4abef597a964ad0e9">More...</a><br /></td></tr>
<tr class="separator:a9e0b42ff91ece2d4abef597a964ad0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66863e6440ae56326f3383837d9966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9c66863e6440ae56326f3383837d9966">Cudd_addMonadicApply</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="cudd_8h.html#a8296f4822b35f456afd928f40ea7ff46">DD_MAOP</a> op, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a9c66863e6440ae56326f3383837d9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies op to the discriminants of f.  <a href="#a9c66863e6440ae56326f3383837d9966">More...</a><br /></td></tr>
<tr class="separator:a9c66863e6440ae56326f3383837d9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ddaff431bfaec7f7075e4a650540f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a229ddaff431bfaec7f7075e4a650540f">Cudd_addLog</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a229ddaff431bfaec7f7075e4a650540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural logarithm of an ADD.  <a href="#a229ddaff431bfaec7f7075e4a650540f">More...</a><br /></td></tr>
<tr class="separator:a229ddaff431bfaec7f7075e4a650540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8eb23dbb37eaa4d6bbd912b0b32a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8b8eb23dbb37eaa4d6bbd912b0b32a8f">Cudd_addFindMax</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a8b8eb23dbb37eaa4d6bbd912b0b32a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum discriminant of f.  <a href="#a8b8eb23dbb37eaa4d6bbd912b0b32a8f">More...</a><br /></td></tr>
<tr class="separator:a8b8eb23dbb37eaa4d6bbd912b0b32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598e352d575d7adb126c8b7958024bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a598e352d575d7adb126c8b7958024bdd">Cudd_addFindMin</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a598e352d575d7adb126c8b7958024bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum discriminant of f.  <a href="#a598e352d575d7adb126c8b7958024bdd">More...</a><br /></td></tr>
<tr class="separator:a598e352d575d7adb126c8b7958024bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c624ba988e4da35d5e576cda1532998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5c624ba988e4da35d5e576cda1532998">Cudd_addIthBit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int bit)</td></tr>
<tr class="memdesc:a5c624ba988e4da35d5e576cda1532998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the i-th bit from an ADD.  <a href="#a5c624ba988e4da35d5e576cda1532998">More...</a><br /></td></tr>
<tr class="separator:a5c624ba988e4da35d5e576cda1532998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aadb4f60d820faf1a55ec4fe028dd5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0aadb4f60d820faf1a55ec4fe028dd5a">Cudd_addScalarInverse</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *epsilon)</td></tr>
<tr class="memdesc:a0aadb4f60d820faf1a55ec4fe028dd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar inverse of an ADD.  <a href="#a0aadb4f60d820faf1a55ec4fe028dd5a">More...</a><br /></td></tr>
<tr class="separator:a0aadb4f60d820faf1a55ec4fe028dd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385a1fdc578cf9e41ff15ef50b6870df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a385a1fdc578cf9e41ff15ef50b6870df">Cudd_addIte</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr class="memdesc:a385a1fdc578cf9e41ff15ef50b6870df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITE(f,g,h).  <a href="#a385a1fdc578cf9e41ff15ef50b6870df">More...</a><br /></td></tr>
<tr class="separator:a385a1fdc578cf9e41ff15ef50b6870df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eae04162ef0a94b49121add887ee99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad1eae04162ef0a94b49121add887ee99">Cudd_addIteConstant</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr class="memdesc:ad1eae04162ef0a94b49121add887ee99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITEconstant for ADDs.  <a href="#ad1eae04162ef0a94b49121add887ee99">More...</a><br /></td></tr>
<tr class="separator:ad1eae04162ef0a94b49121add887ee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cac595be91f0524a8be01c2b330661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a88cac595be91f0524a8be01c2b330661">Cudd_addEvalConst</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a88cac595be91f0524a8be01c2b330661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether ADD g is constant whenever ADD f is 1.  <a href="#a88cac595be91f0524a8be01c2b330661">More...</a><br /></td></tr>
<tr class="separator:a88cac595be91f0524a8be01c2b330661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6faa7c3d70abff90b5187b2f505310"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aef6faa7c3d70abff90b5187b2f505310">Cudd_addLeq</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:aef6faa7c3d70abff90b5187b2f505310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether f is less than or equal to g.  <a href="#aef6faa7c3d70abff90b5187b2f505310">More...</a><br /></td></tr>
<tr class="separator:aef6faa7c3d70abff90b5187b2f505310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0776cc88f7f4911a8c7bede3f3aacdfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0776cc88f7f4911a8c7bede3f3aacdfd">Cudd_addCmpl</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a0776cc88f7f4911a8c7bede3f3aacdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complement of an ADD a la C language.  <a href="#a0776cc88f7f4911a8c7bede3f3aacdfd">More...</a><br /></td></tr>
<tr class="separator:a0776cc88f7f4911a8c7bede3f3aacdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9f8c929819d746e23fcb5ad51e175f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5d9f8c929819d746e23fcb5ad51e175f">Cudd_addNegate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a5d9f8c929819d746e23fcb5ad51e175f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the additive inverse of an ADD.  <a href="#a5d9f8c929819d746e23fcb5ad51e175f">More...</a><br /></td></tr>
<tr class="separator:a5d9f8c929819d746e23fcb5ad51e175f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072569b11bd6695a5b8536739be9611c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a072569b11bd6695a5b8536739be9611c">Cudd_addRoundOff</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int N)</td></tr>
<tr class="memdesc:a072569b11bd6695a5b8536739be9611c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds off the discriminants of an ADD.  <a href="#a072569b11bd6695a5b8536739be9611c">More...</a><br /></td></tr>
<tr class="separator:a072569b11bd6695a5b8536739be9611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a821a60a42494e3e12d91956a754c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a16a821a60a42494e3e12d91956a754c2">Cudd_addWalsh</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a16a821a60a42494e3e12d91956a754c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a Walsh matrix in ADD form.  <a href="#a16a821a60a42494e3e12d91956a754c2">More...</a><br /></td></tr>
<tr class="separator:a16a821a60a42494e3e12d91956a754c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5097993847962311dbbf670a6a3ca3a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5097993847962311dbbf670a6a3ca3a5">Cudd_addResidue</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, int m, int options, int top)</td></tr>
<tr class="memdesc:a5097993847962311dbbf670a6a3ca3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an ADD for the residue modulo m of an n-bit number.  <a href="#a5097993847962311dbbf670a6a3ca3a5">More...</a><br /></td></tr>
<tr class="separator:a5097993847962311dbbf670a6a3ca3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85814dd5f29584d937ad0129cee1afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af85814dd5f29584d937ad0129cee1afe">Cudd_bddAndAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:af85814dd5f29584d937ad0129cee1afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the AND of two BDDs and simultaneously abstracts the variables in cube.  <a href="#af85814dd5f29584d937ad0129cee1afe">More...</a><br /></td></tr>
<tr class="separator:af85814dd5f29584d937ad0129cee1afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c596310dd547baf86fcfbf128d326ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8c596310dd547baf86fcfbf128d326ca">Cudd_bddAndAbstractLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *cube, unsigned int limit)</td></tr>
<tr class="memdesc:a8c596310dd547baf86fcfbf128d326ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the AND of two BDDs and simultaneously abstracts variables unless too many nodes are needed.  <a href="#a8c596310dd547baf86fcfbf128d326ca">More...</a><br /></td></tr>
<tr class="separator:a8c596310dd547baf86fcfbf128d326ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cbcb6561b572e19065a374ad420c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a39cbcb6561b572e19065a374ad420c89">Cudd_ApaNumberOfDigits</a> (int binaryDigits)</td></tr>
<tr class="memdesc:a39cbcb6561b572e19065a374ad420c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of digits for an arbitrary precision integer.  <a href="#a39cbcb6561b572e19065a374ad420c89">More...</a><br /></td></tr>
<tr class="separator:a39cbcb6561b572e19065a374ad420c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45962862c26d56dc134d2e76062ec96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac45962862c26d56dc134d2e76062ec96">Cudd_NewApaNumber</a> (int digits)</td></tr>
<tr class="memdesc:ac45962862c26d56dc134d2e76062ec96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for an arbitrary precision integer.  <a href="#ac45962862c26d56dc134d2e76062ec96">More...</a><br /></td></tr>
<tr class="separator:ac45962862c26d56dc134d2e76062ec96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551741844918bc505f84d11613814660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a551741844918bc505f84d11613814660">Cudd_FreeApaNumber</a> (<a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> number)</td></tr>
<tr class="memdesc:a551741844918bc505f84d11613814660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an arbitrary precision integer.  <a href="#a551741844918bc505f84d11613814660">More...</a><br /></td></tr>
<tr class="separator:a551741844918bc505f84d11613814660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a9e620d1f62d73fd79e79594189071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae7a9e620d1f62d73fd79e79594189071">Cudd_ApaCopy</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> source, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> dest)</td></tr>
<tr class="memdesc:ae7a9e620d1f62d73fd79e79594189071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of an arbitrary precision integer.  <a href="#ae7a9e620d1f62d73fd79e79594189071">More...</a><br /></td></tr>
<tr class="separator:ae7a9e620d1f62d73fd79e79594189071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1827c23504bb6637971495369ebfff34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1827c23504bb6637971495369ebfff34">Cudd_ApaAdd</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> a, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> b, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> sum)</td></tr>
<tr class="memdesc:a1827c23504bb6637971495369ebfff34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two arbitrary precision integers.  <a href="#a1827c23504bb6637971495369ebfff34">More...</a><br /></td></tr>
<tr class="separator:a1827c23504bb6637971495369ebfff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622003514c774dc751db777dc6e51a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a622003514c774dc751db777dc6e51a18">Cudd_ApaSubtract</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> a, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> b, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> diff)</td></tr>
<tr class="memdesc:a622003514c774dc751db777dc6e51a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two arbitrary precision integers.  <a href="#a622003514c774dc751db777dc6e51a18">More...</a><br /></td></tr>
<tr class="separator:a622003514c774dc751db777dc6e51a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6b2acc4d31928f58adeaae9d039b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4c6b2acc4d31928f58adeaae9d039b91">Cudd_ApaShortDivision</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> dividend, <a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> divisor, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> quotient)</td></tr>
<tr class="memdesc:a4c6b2acc4d31928f58adeaae9d039b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an arbitrary precision integer by a digit.  <a href="#a4c6b2acc4d31928f58adeaae9d039b91">More...</a><br /></td></tr>
<tr class="separator:a4c6b2acc4d31928f58adeaae9d039b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9448a1159e8fd6453bbb0641f658965a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9448a1159e8fd6453bbb0641f658965a">Cudd_ApaIntDivision</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> dividend, unsigned int divisor, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> quotient)</td></tr>
<tr class="memdesc:a9448a1159e8fd6453bbb0641f658965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an arbitrary precision integer by an integer.  <a href="#a9448a1159e8fd6453bbb0641f658965a">More...</a><br /></td></tr>
<tr class="separator:a9448a1159e8fd6453bbb0641f658965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5c6ab170b95e24dbc291e6c41772e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a40c5c6ab170b95e24dbc291e6c41772e">Cudd_ApaShiftRight</a> (int digits, <a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> in, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> a, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> b)</td></tr>
<tr class="memdesc:a40c5c6ab170b95e24dbc291e6c41772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts right an arbitrary precision integer by one binary place.  <a href="#a40c5c6ab170b95e24dbc291e6c41772e">More...</a><br /></td></tr>
<tr class="separator:a40c5c6ab170b95e24dbc291e6c41772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab982f99886e7bf960d43ce880caac189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab982f99886e7bf960d43ce880caac189">Cudd_ApaSetToLiteral</a> (int digits, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> number, <a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> literal)</td></tr>
<tr class="memdesc:ab982f99886e7bf960d43ce880caac189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary precision integer to a one-digit literal.  <a href="#ab982f99886e7bf960d43ce880caac189">More...</a><br /></td></tr>
<tr class="separator:ab982f99886e7bf960d43ce880caac189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e0a5e5523b73c0f2ce2a3e9c45b3c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a69e0a5e5523b73c0f2ce2a3e9c45b3c8">Cudd_ApaPowerOfTwo</a> (int digits, <a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> number, int power)</td></tr>
<tr class="memdesc:a69e0a5e5523b73c0f2ce2a3e9c45b3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary precision integer to a power of two.  <a href="#a69e0a5e5523b73c0f2ce2a3e9c45b3c8">More...</a><br /></td></tr>
<tr class="separator:a69e0a5e5523b73c0f2ce2a3e9c45b3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf56c6bcd0064dc9cfd8cf6c416dcef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1bf56c6bcd0064dc9cfd8cf6c416dcef">Cudd_ApaCompare</a> (int digitsFirst, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> first, int digitsSecond, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> second)</td></tr>
<tr class="memdesc:a1bf56c6bcd0064dc9cfd8cf6c416dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two arbitrary precision integers.  <a href="#a1bf56c6bcd0064dc9cfd8cf6c416dcef">More...</a><br /></td></tr>
<tr class="separator:a1bf56c6bcd0064dc9cfd8cf6c416dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1747824c9276f5928472c086edaa10a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af1747824c9276f5928472c086edaa10a">Cudd_ApaCompareRatios</a> (int digitsFirst, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> firstNum, unsigned int firstDen, int digitsSecond, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> secondNum, unsigned int secondDen)</td></tr>
<tr class="memdesc:af1747824c9276f5928472c086edaa10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the ratios of two arbitrary precision integers to two unsigned ints.  <a href="#af1747824c9276f5928472c086edaa10a">More...</a><br /></td></tr>
<tr class="separator:af1747824c9276f5928472c086edaa10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63afad708e512fca63010abd6dc9af2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a63afad708e512fca63010abd6dc9af2d">Cudd_ApaPrintHex</a> (FILE *fp, int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> number)</td></tr>
<tr class="memdesc:a63afad708e512fca63010abd6dc9af2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an arbitrary precision integer in hexadecimal format.  <a href="#a63afad708e512fca63010abd6dc9af2d">More...</a><br /></td></tr>
<tr class="separator:a63afad708e512fca63010abd6dc9af2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05244bf059d03fde3b1fd755111d6ae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a05244bf059d03fde3b1fd755111d6ae5">Cudd_ApaPrintDecimal</a> (FILE *fp, int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> number)</td></tr>
<tr class="memdesc:a05244bf059d03fde3b1fd755111d6ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an arbitrary precision integer in decimal format.  <a href="#a05244bf059d03fde3b1fd755111d6ae5">More...</a><br /></td></tr>
<tr class="separator:a05244bf059d03fde3b1fd755111d6ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af885a506f0f384da5b70eb3e4e3a2f44"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af885a506f0f384da5b70eb3e4e3a2f44">Cudd_ApaStringDecimal</a> (int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> number)</td></tr>
<tr class="memdesc:af885a506f0f384da5b70eb3e4e3a2f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts an arbitrary precision integer to a string in decimal format.  <a href="#af885a506f0f384da5b70eb3e4e3a2f44">More...</a><br /></td></tr>
<tr class="separator:af885a506f0f384da5b70eb3e4e3a2f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804362fa5a31985744e5fc1333e08eec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a804362fa5a31985744e5fc1333e08eec">Cudd_ApaPrintExponential</a> (FILE *fp, int digits, <a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a> number, int precision)</td></tr>
<tr class="memdesc:a804362fa5a31985744e5fc1333e08eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an arbitrary precision integer in exponential format.  <a href="#a804362fa5a31985744e5fc1333e08eec">More...</a><br /></td></tr>
<tr class="separator:a804362fa5a31985744e5fc1333e08eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d07f6e04e77467e44c0d209c3b450d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a86d07f6e04e77467e44c0d209c3b450d">Cudd_ApaCountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars, int *digits)</td></tr>
<tr class="memdesc:a86d07f6e04e77467e44c0d209c3b450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of minterms of a DD.  <a href="#a86d07f6e04e77467e44c0d209c3b450d">More...</a><br /></td></tr>
<tr class="separator:a86d07f6e04e77467e44c0d209c3b450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0594a9f95c1b1935685cbf922d3d59af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0594a9f95c1b1935685cbf922d3d59af">Cudd_ApaPrintMinterm</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> const *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:a0594a9f95c1b1935685cbf922d3d59af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic.  <a href="#a0594a9f95c1b1935685cbf922d3d59af">More...</a><br /></td></tr>
<tr class="separator:a0594a9f95c1b1935685cbf922d3d59af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30cec86f65e23284b10f288f98f2e43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa30cec86f65e23284b10f288f98f2e43">Cudd_ApaPrintMintermExp</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> const *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars, int precision)</td></tr>
<tr class="memdesc:aa30cec86f65e23284b10f288f98f2e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithmetic.  <a href="#aa30cec86f65e23284b10f288f98f2e43">More...</a><br /></td></tr>
<tr class="separator:aa30cec86f65e23284b10f288f98f2e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc488ccdcafa9150ee2c76196f891faa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afc488ccdcafa9150ee2c76196f891faa">Cudd_ApaPrintDensity</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:afc488ccdcafa9150ee2c76196f891faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the density of a BDD or ADD using arbitrary precision arithmetic.  <a href="#afc488ccdcafa9150ee2c76196f891faa">More...</a><br /></td></tr>
<tr class="separator:afc488ccdcafa9150ee2c76196f891faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9381231f34573676e814bb696b2321c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9381231f34573676e814bb696b2321c9">Cudd_UnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a9381231f34573676e814bb696b2321c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with Shiple's underapproximation method.  <a href="#a9381231f34573676e814bb696b2321c9">More...</a><br /></td></tr>
<tr class="separator:a9381231f34573676e814bb696b2321c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e725e579f19ac3e946c04cfdde95f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a09e725e579f19ac3e946c04cfdde95f0">Cudd_OverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a09e725e579f19ac3e946c04cfdde95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with Shiple's underapproximation method.  <a href="#a09e725e579f19ac3e946c04cfdde95f0">More...</a><br /></td></tr>
<tr class="separator:a09e725e579f19ac3e946c04cfdde95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a05f3e8b16e5df2eb681a68e6ee6906f3">Cudd_RemapUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr class="memdesc:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the remapping underapproximation method.  <a href="#a05f3e8b16e5df2eb681a68e6ee6906f3">More...</a><br /></td></tr>
<tr class="separator:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88270c8ded877c10677d563b7041df38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a88270c8ded877c10677d563b7041df38">Cudd_RemapOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr class="memdesc:a88270c8ded877c10677d563b7041df38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the remapping underapproximation method.  <a href="#a88270c8ded877c10677d563b7041df38">More...</a><br /></td></tr>
<tr class="separator:a88270c8ded877c10677d563b7041df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe204aedfdf7705234573d8781729e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9fe204aedfdf7705234573d8781729e2">Cudd_BiasedUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:a9fe204aedfdf7705234573d8781729e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the biased underapproximation method.  <a href="#a9fe204aedfdf7705234573d8781729e2">More...</a><br /></td></tr>
<tr class="separator:a9fe204aedfdf7705234573d8781729e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab6ecb253ad0a11cc9430f0d527e6eaa0">Cudd_BiasedOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the biased underapproximation method.  <a href="#ab6ecb253ad0a11cc9430f0d527e6eaa0">More...</a><br /></td></tr>
<tr class="separator:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddb1590403cc2c2d6c382b68835269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a38ddb1590403cc2c2d6c382b68835269">Cudd_bddExistAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:a38ddb1590403cc2c2d6c382b68835269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Existentially abstracts all the variables in cube from f.  <a href="#a38ddb1590403cc2c2d6c382b68835269">More...</a><br /></td></tr>
<tr class="separator:a38ddb1590403cc2c2d6c382b68835269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667b6eab32e0bb6976d26125ce048e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a667b6eab32e0bb6976d26125ce048e5a">Cudd_bddExistAbstractLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube, unsigned int limit)</td></tr>
<tr class="memdesc:a667b6eab32e0bb6976d26125ce048e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Existentially abstracts all the variables in cube from f.  <a href="#a667b6eab32e0bb6976d26125ce048e5a">More...</a><br /></td></tr>
<tr class="separator:a667b6eab32e0bb6976d26125ce048e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc16ad340eb8baf7803d2e425fdfee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a32bc16ad340eb8baf7803d2e425fdfee">Cudd_bddXorExistAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:a32bc16ad340eb8baf7803d2e425fdfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the exclusive OR of two BDDs and simultaneously abstracts the variables in cube.  <a href="#a32bc16ad340eb8baf7803d2e425fdfee">More...</a><br /></td></tr>
<tr class="separator:a32bc16ad340eb8baf7803d2e425fdfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b9475e3c302e6515fe4986686b6be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac6b9475e3c302e6515fe4986686b6be1">Cudd_bddUnivAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *cube)</td></tr>
<tr class="memdesc:ac6b9475e3c302e6515fe4986686b6be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universally abstracts all the variables in cube from f.  <a href="#ac6b9475e3c302e6515fe4986686b6be1">More...</a><br /></td></tr>
<tr class="separator:ac6b9475e3c302e6515fe4986686b6be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d1414b911b3c614355a57d28f419e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a97d1414b911b3c614355a57d28f419e5">Cudd_bddBooleanDiff</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int x)</td></tr>
<tr class="memdesc:a97d1414b911b3c614355a57d28f419e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the boolean difference of f with respect to x.  <a href="#a97d1414b911b3c614355a57d28f419e5">More...</a><br /></td></tr>
<tr class="separator:a97d1414b911b3c614355a57d28f419e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4175e1b1c5fe59957da7be2966036a77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4175e1b1c5fe59957da7be2966036a77">Cudd_bddVarIsDependent</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *var)</td></tr>
<tr class="memdesc:a4175e1b1c5fe59957da7be2966036a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is dependent on others in a function.  <a href="#a4175e1b1c5fe59957da7be2966036a77">More...</a><br /></td></tr>
<tr class="separator:a4175e1b1c5fe59957da7be2966036a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419deb183e4225531473b7775f06f9d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0419deb183e4225531473b7775f06f9d">Cudd_bddCorrelation</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a0419deb183e4225531473b7775f06f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the correlation of f and g.  <a href="#a0419deb183e4225531473b7775f06f9d">More...</a><br /></td></tr>
<tr class="separator:a0419deb183e4225531473b7775f06f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ee92dcdb59f091b2e809f0c461ccef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a79ee92dcdb59f091b2e809f0c461ccef">Cudd_bddCorrelationWeights</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, double *prob)</td></tr>
<tr class="memdesc:a79ee92dcdb59f091b2e809f0c461ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the correlation of f and g for given input probabilities.  <a href="#a79ee92dcdb59f091b2e809f0c461ccef">More...</a><br /></td></tr>
<tr class="separator:a79ee92dcdb59f091b2e809f0c461ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5761d50898785418ebcaccefb18a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3f5761d50898785418ebcaccefb18a93">Cudd_bddIte</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr class="memdesc:a3f5761d50898785418ebcaccefb18a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITE(f,g,h).  <a href="#a3f5761d50898785418ebcaccefb18a93">More...</a><br /></td></tr>
<tr class="separator:a3f5761d50898785418ebcaccefb18a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc655c685b3822fc21663dfaebdfc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a41cc655c685b3822fc21663dfaebdfc6">Cudd_bddIteLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, unsigned int limit)</td></tr>
<tr class="memdesc:a41cc655c685b3822fc21663dfaebdfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITE(f,g,h) unless too many nodes are required.  <a href="#a41cc655c685b3822fc21663dfaebdfc6">More...</a><br /></td></tr>
<tr class="separator:a41cc655c685b3822fc21663dfaebdfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae893c6ab0472d7058bd424d02bc9420f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae893c6ab0472d7058bd424d02bc9420f">Cudd_bddIteConstant</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr class="memdesc:ae893c6ab0472d7058bd424d02bc9420f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITEconstant(f,g,h).  <a href="#ae893c6ab0472d7058bd424d02bc9420f">More...</a><br /></td></tr>
<tr class="separator:ae893c6ab0472d7058bd424d02bc9420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc109a28a03aae73d3390dc5846a8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6dc109a28a03aae73d3390dc5846a8cb">Cudd_bddIntersect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a6dc109a28a03aae73d3390dc5846a8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function included in the intersection of f and g.  <a href="#a6dc109a28a03aae73d3390dc5846a8cb">More...</a><br /></td></tr>
<tr class="separator:a6dc109a28a03aae73d3390dc5846a8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8374b23de03000aeafb9b6deecee4b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8374b23de03000aeafb9b6deecee4b3c">Cudd_bddAnd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a8374b23de03000aeafb9b6deecee4b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjunction of two BDDs f and g.  <a href="#a8374b23de03000aeafb9b6deecee4b3c">More...</a><br /></td></tr>
<tr class="separator:a8374b23de03000aeafb9b6deecee4b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbb2fd5b9c884df0d684a86dc26a97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adfbb2fd5b9c884df0d684a86dc26a97d">Cudd_bddAndLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr class="memdesc:adfbb2fd5b9c884df0d684a86dc26a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjunction of two BDDs f and g unless too many nodes are required.  <a href="#adfbb2fd5b9c884df0d684a86dc26a97d">More...</a><br /></td></tr>
<tr class="separator:adfbb2fd5b9c884df0d684a86dc26a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd195b3599f9101ff65b57e494f445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad9dd195b3599f9101ff65b57e494f445">Cudd_bddOr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:ad9dd195b3599f9101ff65b57e494f445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the disjunction of two BDDs f and g.  <a href="#ad9dd195b3599f9101ff65b57e494f445">More...</a><br /></td></tr>
<tr class="separator:ad9dd195b3599f9101ff65b57e494f445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbc77f8b658ac3c88a2549a84c58b38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6cbc77f8b658ac3c88a2549a84c58b38">Cudd_bddOrLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr class="memdesc:a6cbc77f8b658ac3c88a2549a84c58b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the disjunction of two BDDs f and g unless too many nodes are required.  <a href="#a6cbc77f8b658ac3c88a2549a84c58b38">More...</a><br /></td></tr>
<tr class="separator:a6cbc77f8b658ac3c88a2549a84c58b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4502750f55f79f7d21ce4674bd66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a98d4502750f55f79f7d21ce4674bd66f">Cudd_bddNand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a98d4502750f55f79f7d21ce4674bd66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the NAND of two BDDs f and g.  <a href="#a98d4502750f55f79f7d21ce4674bd66f">More...</a><br /></td></tr>
<tr class="separator:a98d4502750f55f79f7d21ce4674bd66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb902e010f3213ba3a0e7917e93b70e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3bb902e010f3213ba3a0e7917e93b70e">Cudd_bddNor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a3bb902e010f3213ba3a0e7917e93b70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the NOR of two BDDs f and g.  <a href="#a3bb902e010f3213ba3a0e7917e93b70e">More...</a><br /></td></tr>
<tr class="separator:a3bb902e010f3213ba3a0e7917e93b70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2215420b94afbcd00d011fe2787c5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad2215420b94afbcd00d011fe2787c5e7">Cudd_bddXor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:ad2215420b94afbcd00d011fe2787c5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive OR of two BDDs f and g.  <a href="#ad2215420b94afbcd00d011fe2787c5e7">More...</a><br /></td></tr>
<tr class="separator:ad2215420b94afbcd00d011fe2787c5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452caf40a12400757e44fe5a8569e20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a452caf40a12400757e44fe5a8569e20c">Cudd_bddXnor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a452caf40a12400757e44fe5a8569e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive NOR of two BDDs f and g.  <a href="#a452caf40a12400757e44fe5a8569e20c">More...</a><br /></td></tr>
<tr class="separator:a452caf40a12400757e44fe5a8569e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7422788984a855fb387643f27294014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae7422788984a855fb387643f27294014">Cudd_bddXnorLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr class="memdesc:ae7422788984a855fb387643f27294014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive NOR of two BDDs f and g unless too many nodes are required.  <a href="#ae7422788984a855fb387643f27294014">More...</a><br /></td></tr>
<tr class="separator:ae7422788984a855fb387643f27294014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a46089e8572876a1521cdee6cb31a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a89a46089e8572876a1521cdee6cb31a2">Cudd_bddLeq</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a89a46089e8572876a1521cdee6cb31a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether f is less than or equal to g.  <a href="#a89a46089e8572876a1521cdee6cb31a2">More...</a><br /></td></tr>
<tr class="separator:a89a46089e8572876a1521cdee6cb31a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94a0491ea6d3464e488b667a0b42bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adf94a0491ea6d3464e488b667a0b42bd">Cudd_addBddThreshold</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> value)</td></tr>
<tr class="memdesc:adf94a0491ea6d3464e488b667a0b42bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ADD to a BDD.  <a href="#adf94a0491ea6d3464e488b667a0b42bd">More...</a><br /></td></tr>
<tr class="separator:adf94a0491ea6d3464e488b667a0b42bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a7d31fbafb86bd3b335b2a5523444c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a17a7d31fbafb86bd3b335b2a5523444c">Cudd_addBddStrictThreshold</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> value)</td></tr>
<tr class="memdesc:a17a7d31fbafb86bd3b335b2a5523444c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ADD to a BDD.  <a href="#a17a7d31fbafb86bd3b335b2a5523444c">More...</a><br /></td></tr>
<tr class="separator:a17a7d31fbafb86bd3b335b2a5523444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa95504dec573eada577783098b26b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adfa95504dec573eada577783098b26b6">Cudd_addBddInterval</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> lower, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> upper)</td></tr>
<tr class="memdesc:adfa95504dec573eada577783098b26b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ADD to a BDD.  <a href="#adfa95504dec573eada577783098b26b6">More...</a><br /></td></tr>
<tr class="separator:adfa95504dec573eada577783098b26b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8255c2649b61e0f28521792eea4065f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa8255c2649b61e0f28521792eea4065f">Cudd_addBddIthBit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int bit)</td></tr>
<tr class="memdesc:aa8255c2649b61e0f28521792eea4065f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ADD to a BDD by extracting the i-th bit from the leaves.  <a href="#aa8255c2649b61e0f28521792eea4065f">More...</a><br /></td></tr>
<tr class="separator:aa8255c2649b61e0f28521792eea4065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0f570e1bbe987fdecc4786ac808e08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2a0f570e1bbe987fdecc4786ac808e08">Cudd_BddToAdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *B)</td></tr>
<tr class="memdesc:a2a0f570e1bbe987fdecc4786ac808e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a BDD to a 0-1 ADD.  <a href="#a2a0f570e1bbe987fdecc4786ac808e08">More...</a><br /></td></tr>
<tr class="separator:a2a0f570e1bbe987fdecc4786ac808e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a80d92ddf13c5d54e61974f1855c22b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6a80d92ddf13c5d54e61974f1855c22b">Cudd_addBddPattern</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a6a80d92ddf13c5d54e61974f1855c22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ADD to a BDD.  <a href="#a6a80d92ddf13c5d54e61974f1855c22b">More...</a><br /></td></tr>
<tr class="separator:a6a80d92ddf13c5d54e61974f1855c22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5744cfcff87a1a83b2cbaab2aba51494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5744cfcff87a1a83b2cbaab2aba51494">Cudd_bddTransfer</a> (<a class="el" href="structDdManager.html">DdManager</a> *ddSource, <a class="el" href="structDdManager.html">DdManager</a> *ddDestination, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a5744cfcff87a1a83b2cbaab2aba51494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a BDD from a manager to another one.  <a href="#a5744cfcff87a1a83b2cbaab2aba51494">More...</a><br /></td></tr>
<tr class="separator:a5744cfcff87a1a83b2cbaab2aba51494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4784371f26794a254bcc6a2ad875b5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae4784371f26794a254bcc6a2ad875b5e">Cudd_DebugCheck</a> (<a class="el" href="structDdManager.html">DdManager</a> *table)</td></tr>
<tr class="memdesc:ae4784371f26794a254bcc6a2ad875b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inconsistencies in the DD heap.  <a href="#ae4784371f26794a254bcc6a2ad875b5e">More...</a><br /></td></tr>
<tr class="separator:ae4784371f26794a254bcc6a2ad875b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081e08d440a7ca8b7406e79b25dfaef5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a081e08d440a7ca8b7406e79b25dfaef5">Cudd_CheckKeys</a> (<a class="el" href="structDdManager.html">DdManager</a> *table)</td></tr>
<tr class="memdesc:a081e08d440a7ca8b7406e79b25dfaef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for several conditions that should not occur.  <a href="#a081e08d440a7ca8b7406e79b25dfaef5">More...</a><br /></td></tr>
<tr class="separator:a081e08d440a7ca8b7406e79b25dfaef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb785f2cff5e691fba1d005b645f9b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aeb785f2cff5e691fba1d005b645f9b16">Cudd_bddClippingAnd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int maxDepth, int direction)</td></tr>
<tr class="memdesc:aeb785f2cff5e691fba1d005b645f9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the conjunction of two BDDs f and g.  <a href="#aeb785f2cff5e691fba1d005b645f9b16">More...</a><br /></td></tr>
<tr class="separator:aeb785f2cff5e691fba1d005b645f9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7894f643b69f42b26d4aa2554296fd15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7894f643b69f42b26d4aa2554296fd15">Cudd_bddClippingAndAbstract</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *cube, int maxDepth, int direction)</td></tr>
<tr class="memdesc:a7894f643b69f42b26d4aa2554296fd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the conjunction of two BDDs f and g and simultaneously abstracts the variables in cube.  <a href="#a7894f643b69f42b26d4aa2554296fd15">More...</a><br /></td></tr>
<tr class="separator:a7894f643b69f42b26d4aa2554296fd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5c75ae199f9383cf86cfa5d754faa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acd5c75ae199f9383cf86cfa5d754faa3">Cudd_Cofactor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:acd5c75ae199f9383cf86cfa5d754faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cofactor of f with respect to g.  <a href="#acd5c75ae199f9383cf86cfa5d754faa3">More...</a><br /></td></tr>
<tr class="separator:acd5c75ae199f9383cf86cfa5d754faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87964c4eda5c1b32acdd98fb43a727"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#abe87964c4eda5c1b32acdd98fb43a727">Cudd_CheckCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:abe87964c4eda5c1b32acdd98fb43a727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether g is the BDD of a cube.  <a href="#abe87964c4eda5c1b32acdd98fb43a727">More...</a><br /></td></tr>
<tr class="separator:abe87964c4eda5c1b32acdd98fb43a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30712f050737cb498a0e6572a7940bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a30712f050737cb498a0e6572a7940bf3">Cudd_VarsAreSymmetric</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int index1, int index2)</td></tr>
<tr class="memdesc:a30712f050737cb498a0e6572a7940bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two variables are symmetric in a <a class="el" href="classBDD.html" title="Class for BDDs.">BDD</a>.  <a href="#a30712f050737cb498a0e6572a7940bf3">More...</a><br /></td></tr>
<tr class="separator:a30712f050737cb498a0e6572a7940bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab5ccb7b9d27d9d383d0f407cf894f118">Cudd_bddCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr class="memdesc:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the BDD for f.  <a href="#ab5ccb7b9d27d9d383d0f407cf894f118">More...</a><br /></td></tr>
<tr class="separator:ab5ccb7b9d27d9d383d0f407cf894f118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad050bd964c7386f2a9eed09b8a1d25d7">Cudd_addCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr class="memdesc:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the ADD for f.  <a href="#ad050bd964c7386f2a9eed09b8a1d25d7">More...</a><br /></td></tr>
<tr class="separator:ad050bd964c7386f2a9eed09b8a1d25d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4926a513ab721d9bbc866740d40cbfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4926a513ab721d9bbc866740d40cbfcf">Cudd_addPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:a4926a513ab721d9bbc866740d40cbfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of an ADD.  <a href="#a4926a513ab721d9bbc866740d40cbfcf">More...</a><br /></td></tr>
<tr class="separator:a4926a513ab721d9bbc866740d40cbfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2ab066ce29ac83aa7d3891b96d4356e1">Cudd_addSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the ADD f.  <a href="#a2ab066ce29ac83aa7d3891b96d4356e1">More...</a><br /></td></tr>
<tr class="separator:a2ab066ce29ac83aa7d3891b96d4356e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa877bf86c670ea10d67d4f6e91fcc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afa877bf86c670ea10d67d4f6e91fcc98">Cudd_bddPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr class="memdesc:afa877bf86c670ea10d67d4f6e91fcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of a BDD.  <a href="#afa877bf86c670ea10d67d4f6e91fcc98">More...</a><br /></td></tr>
<tr class="separator:afa877bf86c670ea10d67d4f6e91fcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b6ff390b8f205a28d2804d723118d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af1b6ff390b8f205a28d2804d723118d9">Cudd_bddVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:af1b6ff390b8f205a28d2804d723118d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the variables of a BDD using the default variable map.  <a href="#af1b6ff390b8f205a28d2804d723118d9">More...</a><br /></td></tr>
<tr class="separator:af1b6ff390b8f205a28d2804d723118d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3d0ed2b9c7a7158ed78273908a2a5386">Cudd_SetVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a variable mapping with the manager.  <a href="#a3d0ed2b9c7a7158ed78273908a2a5386">More...</a><br /></td></tr>
<tr class="separator:a3d0ed2b9c7a7158ed78273908a2a5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2ab6b6123e102f9b0b61c9d2961f707e">Cudd_bddSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr class="memdesc:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the BDD f.  <a href="#a2ab6b6123e102f9b0b61c9d2961f707e">More...</a><br /></td></tr>
<tr class="separator:a2ab6b6123e102f9b0b61c9d2961f707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e976b573531badb9a023f86dcdbeb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6e976b573531badb9a023f86dcdbeb40">Cudd_bddAdjPermuteX</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *B, <a class="el" href="structDdNode.html">DdNode</a> **x, int n)</td></tr>
<tr class="memdesc:a6e976b573531badb9a023f86dcdbeb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a set of variables in the BDD B.  <a href="#a6e976b573531badb9a023f86dcdbeb40">More...</a><br /></td></tr>
<tr class="separator:a6e976b573531badb9a023f86dcdbeb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62543c529dab3780047f2a45f1e5c50f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a62543c529dab3780047f2a45f1e5c50f">Cudd_addVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a62543c529dab3780047f2a45f1e5c50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a62543c529dab3780047f2a45f1e5c50f">More...</a><br /></td></tr>
<tr class="separator:a62543c529dab3780047f2a45f1e5c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52f7db30965ff17d5a8d5667162eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0d52f7db30965ff17d5a8d5667162eb5">Cudd_addGeneralVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vectorOn, <a class="el" href="structDdNode.html">DdNode</a> **vectorOff)</td></tr>
<tr class="memdesc:a0d52f7db30965ff17d5a8d5667162eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of ADDs.  <a href="#a0d52f7db30965ff17d5a8d5667162eb5">More...</a><br /></td></tr>
<tr class="separator:a0d52f7db30965ff17d5a8d5667162eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74339b069aaea8dbf1b321eaa773b59a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a74339b069aaea8dbf1b321eaa773b59a">Cudd_addNonSimCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a74339b069aaea8dbf1b321eaa773b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a74339b069aaea8dbf1b321eaa773b59a">More...</a><br /></td></tr>
<tr class="separator:a74339b069aaea8dbf1b321eaa773b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bffb3a79510753ee6648a998aaaae97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0bffb3a79510753ee6648a998aaaae97">Cudd_bddVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr class="memdesc:a0bffb3a79510753ee6648a998aaaae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a BDD with a vector of BDDs.  <a href="#a0bffb3a79510753ee6648a998aaaae97">More...</a><br /></td></tr>
<tr class="separator:a0bffb3a79510753ee6648a998aaaae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536e36dac9b4ddf90edb3a48934b7886"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a536e36dac9b4ddf90edb3a48934b7886">Cudd_bddApproxConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:a536e36dac9b4ddf90edb3a48934b7886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a536e36dac9b4ddf90edb3a48934b7886">More...</a><br /></td></tr>
<tr class="separator:a536e36dac9b4ddf90edb3a48934b7886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e">Cudd_bddApproxDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#aa9d8d2d24ef2842db6b6ab5794d2bb6e">More...</a><br /></td></tr>
<tr class="separator:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad7b54f1fae0417dcb3eeab6f1be792fa">Cudd_bddIterConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#ad7b54f1fae0417dcb3eeab6f1be792fa">More...</a><br /></td></tr>
<tr class="separator:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac716bb2411a608764d34404fadf09379"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac716bb2411a608764d34404fadf09379">Cudd_bddIterDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:ac716bb2411a608764d34404fadf09379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#ac716bb2411a608764d34404fadf09379">More...</a><br /></td></tr>
<tr class="separator:ac716bb2411a608764d34404fadf09379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de1749d0e92e061d1b3edafc56956b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8de1749d0e92e061d1b3edafc56956b3">Cudd_bddGenConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:a8de1749d0e92e061d1b3edafc56956b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a8de1749d0e92e061d1b3edafc56956b3">More...</a><br /></td></tr>
<tr class="separator:a8de1749d0e92e061d1b3edafc56956b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0f7cc1a34d26e9bbf9d3919e258dd952">Cudd_bddGenDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a0f7cc1a34d26e9bbf9d3919e258dd952">More...</a><br /></td></tr>
<tr class="separator:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21da753c8a5798886891fed4baaaa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aaa21da753c8a5798886891fed4baaaa4">Cudd_bddVarConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:aaa21da753c8a5798886891fed4baaaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#aaa21da753c8a5798886891fed4baaaa4">More...</a><br /></td></tr>
<tr class="separator:aaa21da753c8a5798886891fed4baaaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057207ca7a87e980a040bb1183db3645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a057207ca7a87e980a040bb1183db3645">Cudd_bddVarDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:a057207ca7a87e980a040bb1183db3645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a057207ca7a87e980a040bb1183db3645">More...</a><br /></td></tr>
<tr class="separator:a057207ca7a87e980a040bb1183db3645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4615437702b72ce2d5d4b25e8f2e3bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4615437702b72ce2d5d4b25e8f2e3bbc">Cudd_FindEssential</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a4615437702b72ce2d5d4b25e8f2e3bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the essential variables of a DD.  <a href="#a4615437702b72ce2d5d4b25e8f2e3bbc">More...</a><br /></td></tr>
<tr class="separator:a4615437702b72ce2d5d4b25e8f2e3bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c1545f9efe374d475c99a9110803c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a705c1545f9efe374d475c99a9110803c">Cudd_bddIsVarEssential</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int id, int phase)</td></tr>
<tr class="memdesc:a705c1545f9efe374d475c99a9110803c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a given variable is essential with a given phase in a BDD.  <a href="#a705c1545f9efe374d475c99a9110803c">More...</a><br /></td></tr>
<tr class="separator:a705c1545f9efe374d475c99a9110803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f012688629072a193cbf7639d20f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdTlcInfo.html">DdTlcInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a443f012688629072a193cbf7639d20f5">Cudd_FindTwoLiteralClauses</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a443f012688629072a193cbf7639d20f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the two literal clauses of a DD.  <a href="#a443f012688629072a193cbf7639d20f5">More...</a><br /></td></tr>
<tr class="separator:a443f012688629072a193cbf7639d20f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a6866471a2b8da0c0faf9ee7fc79c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a65a6866471a2b8da0c0faf9ee7fc79c1">Cudd_PrintTwoLiteralClauses</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, char **names, FILE *fp)</td></tr>
<tr class="memdesc:a65a6866471a2b8da0c0faf9ee7fc79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the one- and two-literal clauses of a DD.  <a href="#a65a6866471a2b8da0c0faf9ee7fc79c1">More...</a><br /></td></tr>
<tr class="separator:a65a6866471a2b8da0c0faf9ee7fc79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc962357e00829128241006e6749692"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afdc962357e00829128241006e6749692">Cudd_ReadIthClause</a> (<a class="el" href="structDdTlcInfo.html">DdTlcInfo</a> *tlc, int i, unsigned *var1, unsigned *var2, int *phase1, int *phase2)</td></tr>
<tr class="memdesc:afdc962357e00829128241006e6749692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the i-th clause of a DD.  <a href="#afdc962357e00829128241006e6749692">More...</a><br /></td></tr>
<tr class="separator:afdc962357e00829128241006e6749692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a4c74db7901421a4595343ca588128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a67a4c74db7901421a4595343ca588128">Cudd_tlcInfoFree</a> (<a class="el" href="structDdTlcInfo.html">DdTlcInfo</a> *t)</td></tr>
<tr class="memdesc:a67a4c74db7901421a4595343ca588128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structDdTlcInfo.html" title="This structure holds the set of clauses for a node.">DdTlcInfo</a> Structure.  <a href="#a67a4c74db7901421a4595343ca588128">More...</a><br /></td></tr>
<tr class="separator:a67a4c74db7901421a4595343ca588128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c08d26e1d5f2d7e2bc0011b36b3b5bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc">Cudd_DumpBlif</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, char *mname, FILE *fp, int mv)</td></tr>
<tr class="memdesc:a1c08d26e1d5f2d7e2bc0011b36b3b5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a blif file representing the argument BDDs.  <a href="#a1c08d26e1d5f2d7e2bc0011b36b3b5bc">More...</a><br /></td></tr>
<tr class="separator:a1c08d26e1d5f2d7e2bc0011b36b3b5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ff0352975be7c9f4da9c69340c4ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a835ff0352975be7c9f4da9c69340c4ab">Cudd_DumpBlifBody</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp, int mv)</td></tr>
<tr class="memdesc:a835ff0352975be7c9f4da9c69340c4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a blif body representing the argument BDDs.  <a href="#a835ff0352975be7c9f4da9c69340c4ab">More...</a><br /></td></tr>
<tr class="separator:a835ff0352975be7c9f4da9c69340c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfdcf8b654eec068f30275ff3f3e1b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9dfdcf8b654eec068f30275ff3f3e1b6">Cudd_DumpDot</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp)</td></tr>
<tr class="memdesc:a9dfdcf8b654eec068f30275ff3f3e1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a dot file representing the argument DDs.  <a href="#a9dfdcf8b654eec068f30275ff3f3e1b6">More...</a><br /></td></tr>
<tr class="separator:a9dfdcf8b654eec068f30275ff3f3e1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47caf9418e7518e24bccc79fca1bbbe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a47caf9418e7518e24bccc79fca1bbbe1">Cudd_DumpDaVinci</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp)</td></tr>
<tr class="memdesc:a47caf9418e7518e24bccc79fca1bbbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a daVinci file representing the argument BDDs.  <a href="#a47caf9418e7518e24bccc79fca1bbbe1">More...</a><br /></td></tr>
<tr class="separator:a47caf9418e7518e24bccc79fca1bbbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7d833ebc018dee098de99271aa16a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a19d7d833ebc018dee098de99271aa16a">Cudd_DumpDDcal</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp)</td></tr>
<tr class="memdesc:a19d7d833ebc018dee098de99271aa16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a DDcal file representing the argument BDDs.  <a href="#a19d7d833ebc018dee098de99271aa16a">More...</a><br /></td></tr>
<tr class="separator:a19d7d833ebc018dee098de99271aa16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc4c06d659702717cee07a5501145e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4ecc4c06d659702717cee07a5501145e">Cudd_DumpFactoredForm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp)</td></tr>
<tr class="memdesc:a4ecc4c06d659702717cee07a5501145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes factored forms representing the argument BDDs.  <a href="#a4ecc4c06d659702717cee07a5501145e">More...</a><br /></td></tr>
<tr class="separator:a4ecc4c06d659702717cee07a5501145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045101a55bae5da1745e2dafed1d4e97"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a045101a55bae5da1745e2dafed1d4e97">Cudd_FactoredFormString</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, char const *const *inames)</td></tr>
<tr class="memdesc:a045101a55bae5da1745e2dafed1d4e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with the factored form of the argument BDDs.  <a href="#a045101a55bae5da1745e2dafed1d4e97">More...</a><br /></td></tr>
<tr class="separator:a045101a55bae5da1745e2dafed1d4e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f801a2e5814da9d67a3436f0e3376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a250f801a2e5814da9d67a3436f0e3376">Cudd_bddConstrain</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:a250f801a2e5814da9d67a3436f0e3376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f constrain c.  <a href="#a250f801a2e5814da9d67a3436f0e3376">More...</a><br /></td></tr>
<tr class="separator:a250f801a2e5814da9d67a3436f0e3376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8d8bb0210e368eb7258b2961c3cf3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3c8d8bb0210e368eb7258b2961c3cf3e">Cudd_bddRestrict</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:a3c8d8bb0210e368eb7258b2961c3cf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD restrict according to Coudert and Madre's algorithm (ICCAD90).  <a href="#a3c8d8bb0210e368eb7258b2961c3cf3e">More...</a><br /></td></tr>
<tr class="separator:a3c8d8bb0210e368eb7258b2961c3cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac859dc8f03d9f8dcbc54dcab5ee94912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac859dc8f03d9f8dcbc54dcab5ee94912">Cudd_bddNPAnd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:ac859dc8f03d9f8dcbc54dcab5ee94912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f non-polluting-and g.  <a href="#ac859dc8f03d9f8dcbc54dcab5ee94912">More...</a><br /></td></tr>
<tr class="separator:ac859dc8f03d9f8dcbc54dcab5ee94912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdc53bb832fb6b57528e7d5ceef7944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3bdc53bb832fb6b57528e7d5ceef7944">Cudd_addConstrain</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:a3bdc53bb832fb6b57528e7d5ceef7944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f constrain c for ADDs.  <a href="#a3bdc53bb832fb6b57528e7d5ceef7944">More...</a><br /></td></tr>
<tr class="separator:a3bdc53bb832fb6b57528e7d5ceef7944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf0b345123f5065ac6b2ea951b7bfe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aaaf0b345123f5065ac6b2ea951b7bfe8">Cudd_bddConstrainDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:aaaf0b345123f5065ac6b2ea951b7bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD conjunctive decomposition as in McMillan's CAV96 paper.  <a href="#aaaf0b345123f5065ac6b2ea951b7bfe8">More...</a><br /></td></tr>
<tr class="separator:aaaf0b345123f5065ac6b2ea951b7bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab16f58da620eb1c2e927426aea22c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4ab16f58da620eb1c2e927426aea22c7">Cudd_addRestrict</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:a4ab16f58da620eb1c2e927426aea22c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADD restrict according to Coudert and Madre's algorithm (ICCAD90).  <a href="#a4ab16f58da620eb1c2e927426aea22c7">More...</a><br /></td></tr>
<tr class="separator:a4ab16f58da620eb1c2e927426aea22c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4482b94e76db44ff22087277d09b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1a4482b94e76db44ff22087277d09b4d">Cudd_bddCharToVect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a1a4482b94e76db44ff22087277d09b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector of BDDs whose image equals a non-zero function.  <a href="#a1a4482b94e76db44ff22087277d09b4d">More...</a><br /></td></tr>
<tr class="separator:a1a4482b94e76db44ff22087277d09b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c23e53c189d45d06b68a9a52b724141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6c23e53c189d45d06b68a9a52b724141">Cudd_bddLICompaction</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:a6c23e53c189d45d06b68a9a52b724141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs safe minimization of a BDD.  <a href="#a6c23e53c189d45d06b68a9a52b724141">More...</a><br /></td></tr>
<tr class="separator:a6c23e53c189d45d06b68a9a52b724141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc2329b3d7a6cb0b8adc5582fc7fe2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c">Cudd_bddSqueeze</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr class="memdesc:afbc2329b3d7a6cb0b8adc5582fc7fe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a small BDD in a function interval.  <a href="#afbc2329b3d7a6cb0b8adc5582fc7fe2c">More...</a><br /></td></tr>
<tr class="separator:afbc2329b3d7a6cb0b8adc5582fc7fe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee71bb03723625bacf2c0b369a187125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aee71bb03723625bacf2c0b369a187125">Cudd_bddInterpolate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr class="memdesc:aee71bb03723625bacf2c0b369a187125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an interpolant of two functions.  <a href="#aee71bb03723625bacf2c0b369a187125">More...</a><br /></td></tr>
<tr class="separator:aee71bb03723625bacf2c0b369a187125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47227c86f08d37cd5fd8ea2a89afcb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af47227c86f08d37cd5fd8ea2a89afcb7">Cudd_bddMinimize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:af47227c86f08d37cd5fd8ea2a89afcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a small BDD that agrees with <code>f</code> over <code>c</code>.  <a href="#af47227c86f08d37cd5fd8ea2a89afcb7">More...</a><br /></td></tr>
<tr class="separator:af47227c86f08d37cd5fd8ea2a89afcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc5a582b85170a4c365e852b98c37da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#abbc5a582b85170a4c365e852b98c37da">Cudd_SubsetCompress</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars, int threshold)</td></tr>
<tr class="memdesc:abbc5a582b85170a4c365e852b98c37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a dense subset of BDD <code>f</code>.  <a href="#abbc5a582b85170a4c365e852b98c37da">More...</a><br /></td></tr>
<tr class="separator:abbc5a582b85170a4c365e852b98c37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194308bd7e4afce7aa668833f8a4e2ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a194308bd7e4afce7aa668833f8a4e2ff">Cudd_SupersetCompress</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars, int threshold)</td></tr>
<tr class="memdesc:a194308bd7e4afce7aa668833f8a4e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a dense superset of BDD <code>f</code>.  <a href="#a194308bd7e4afce7aa668833f8a4e2ff">More...</a><br /></td></tr>
<tr class="separator:a194308bd7e4afce7aa668833f8a4e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a8110e2fedb3bf6674cbe9a83e6de3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a34a8110e2fedb3bf6674cbe9a83e6de3">Cudd_addHarwell</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **E, <a class="el" href="structDdNode.html">DdNode</a> ***x, <a class="el" href="structDdNode.html">DdNode</a> ***y, <a class="el" href="structDdNode.html">DdNode</a> ***xn, <a class="el" href="structDdNode.html">DdNode</a> ***yn_, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy, int pr)</td></tr>
<tr class="memdesc:a34a8110e2fedb3bf6674cbe9a83e6de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a matrix in the format of the Harwell-Boeing benchmark suite.  <a href="#a34a8110e2fedb3bf6674cbe9a83e6de3">More...</a><br /></td></tr>
<tr class="separator:a34a8110e2fedb3bf6674cbe9a83e6de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45075f018d4c680c12573bbd1c44ddb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a45075f018d4c680c12573bbd1c44ddb9">Cudd_Init</a> (unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int cacheSize, size_t maxMemory)</td></tr>
<tr class="memdesc:a45075f018d4c680c12573bbd1c44ddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> manager.  <a href="#a45075f018d4c680c12573bbd1c44ddb9">More...</a><br /></td></tr>
<tr class="separator:a45075f018d4c680c12573bbd1c44ddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2889ace3fcf7d4e00915de52554fd475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2889ace3fcf7d4e00915de52554fd475">Cudd_Quit</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique)</td></tr>
<tr class="memdesc:a2889ace3fcf7d4e00915de52554fd475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes resources associated with a DD manager.  <a href="#a2889ace3fcf7d4e00915de52554fd475">More...</a><br /></td></tr>
<tr class="separator:a2889ace3fcf7d4e00915de52554fd475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb45adfdbde035d439271377f68a098"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afbb45adfdbde035d439271377f68a098">Cudd_PrintLinear</a> (<a class="el" href="structDdManager.html">DdManager</a> *table)</td></tr>
<tr class="memdesc:afbb45adfdbde035d439271377f68a098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the linear transform matrix.  <a href="#afbb45adfdbde035d439271377f68a098">More...</a><br /></td></tr>
<tr class="separator:afbb45adfdbde035d439271377f68a098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474cd847607bf4afaaff49e849626585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a474cd847607bf4afaaff49e849626585">Cudd_ReadLinear</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, int x, int y)</td></tr>
<tr class="memdesc:a474cd847607bf4afaaff49e849626585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry of the linear transform matrix.  <a href="#a474cd847607bf4afaaff49e849626585">More...</a><br /></td></tr>
<tr class="separator:a474cd847607bf4afaaff49e849626585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b953384d8f552c774055694db06ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a32b953384d8f552c774055694db06ba4">Cudd_bddLiteralSetIntersection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a32b953384d8f552c774055694db06ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intesection of two sets of literals represented as BDDs.  <a href="#a32b953384d8f552c774055694db06ba4">More...</a><br /></td></tr>
<tr class="separator:a32b953384d8f552c774055694db06ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a39a76a87a363ae2a4478b6181a580d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2a39a76a87a363ae2a4478b6181a580d">Cudd_addMatrixMultiply</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *A, <a class="el" href="structDdNode.html">DdNode</a> *B, <a class="el" href="structDdNode.html">DdNode</a> **z, int nz)</td></tr>
<tr class="memdesc:a2a39a76a87a363ae2a4478b6181a580d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of two matrices represented as ADDs.  <a href="#a2a39a76a87a363ae2a4478b6181a580d">More...</a><br /></td></tr>
<tr class="separator:a2a39a76a87a363ae2a4478b6181a580d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6a6c9af4740842142de24bb1eb986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3ba6a6c9af4740842142de24bb1eb986">Cudd_addTimesPlus</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *A, <a class="el" href="structDdNode.html">DdNode</a> *B, <a class="el" href="structDdNode.html">DdNode</a> **z, int nz)</td></tr>
<tr class="memdesc:a3ba6a6c9af4740842142de24bb1eb986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of two matrices represented as ADDs.  <a href="#a3ba6a6c9af4740842142de24bb1eb986">More...</a><br /></td></tr>
<tr class="separator:a3ba6a6c9af4740842142de24bb1eb986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cb80a30ebe274373196765e3dd57a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a98cb80a30ebe274373196765e3dd57a3">Cudd_addTriangle</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> **z, int nz)</td></tr>
<tr class="memdesc:a98cb80a30ebe274373196765e3dd57a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the triangulation step for the shortest path computation.  <a href="#a98cb80a30ebe274373196765e3dd57a3">More...</a><br /></td></tr>
<tr class="separator:a98cb80a30ebe274373196765e3dd57a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2d12490bf8133f0893c9f587442ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aff2d12490bf8133f0893c9f587442ae2">Cudd_addOuterSum</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *M, <a class="el" href="structDdNode.html">DdNode</a> *r, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr class="memdesc:aff2d12490bf8133f0893c9f587442ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the minimum of a matrix and the outer sum of two vectors.  <a href="#aff2d12490bf8133f0893c9f587442ae2">More...</a><br /></td></tr>
<tr class="separator:aff2d12490bf8133f0893c9f587442ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45fcda0a0e4d2cce08b955ff0964a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab45fcda0a0e4d2cce08b955ff0964a98">Cudd_PrioritySelect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *R, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, <a class="el" href="structDdNode.html">DdNode</a> **z, <a class="el" href="structDdNode.html">DdNode</a> *Pi, int n, <a class="el" href="cudd_8h.html#afaac0abf7189a0db3e7ecd729c93188b">DD_PRFP</a> PiFunc)</td></tr>
<tr class="memdesc:ab45fcda0a0e4d2cce08b955ff0964a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects pairs from R using a priority function.  <a href="#ab45fcda0a0e4d2cce08b955ff0964a98">More...</a><br /></td></tr>
<tr class="separator:ab45fcda0a0e4d2cce08b955ff0964a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e96461db0102f8aea154caa3f516a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a931e96461db0102f8aea154caa3f516a">Cudd_Xgty</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **z, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y)</td></tr>
<tr class="memdesc:a931e96461db0102f8aea154caa3f516a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function x &gt; y.  <a href="#a931e96461db0102f8aea154caa3f516a">More...</a><br /></td></tr>
<tr class="separator:a931e96461db0102f8aea154caa3f516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9817150682e961ceac761a6055cbecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac9817150682e961ceac761a6055cbecd">Cudd_Xeqy</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y)</td></tr>
<tr class="memdesc:ac9817150682e961ceac761a6055cbecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function x==y.  <a href="#ac9817150682e961ceac761a6055cbecd">More...</a><br /></td></tr>
<tr class="separator:ac9817150682e961ceac761a6055cbecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a3aade7bb40fe511c203dfee9c0f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a13a3aade7bb40fe511c203dfee9c0f33">Cudd_addXeqy</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y)</td></tr>
<tr class="memdesc:a13a3aade7bb40fe511c203dfee9c0f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an ADD for the function x==y.  <a href="#a13a3aade7bb40fe511c203dfee9c0f33">More...</a><br /></td></tr>
<tr class="separator:a13a3aade7bb40fe511c203dfee9c0f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee4055f67c91825ec6edbea00ce9f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7ee4055f67c91825ec6edbea00ce9f83">Cudd_Dxygtdxz</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, <a class="el" href="structDdNode.html">DdNode</a> **z)</td></tr>
<tr class="memdesc:a7ee4055f67c91825ec6edbea00ce9f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function d(x,y) &gt; d(x,z).  <a href="#a7ee4055f67c91825ec6edbea00ce9f83">More...</a><br /></td></tr>
<tr class="separator:a7ee4055f67c91825ec6edbea00ce9f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab118ad9c8350d51d5ce1b824db5423fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab118ad9c8350d51d5ce1b824db5423fd">Cudd_Dxygtdyz</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, <a class="el" href="structDdNode.html">DdNode</a> **z)</td></tr>
<tr class="memdesc:ab118ad9c8350d51d5ce1b824db5423fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function d(x,y) &gt; d(y,z).  <a href="#ab118ad9c8350d51d5ce1b824db5423fd">More...</a><br /></td></tr>
<tr class="separator:ab118ad9c8350d51d5ce1b824db5423fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74aaf027fda040d4d484ff970f370eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae74aaf027fda040d4d484ff970f370eb">Cudd_Inequality</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, int c, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y)</td></tr>
<tr class="memdesc:ae74aaf027fda040d4d484ff970f370eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function x - y &ge; c.  <a href="#ae74aaf027fda040d4d484ff970f370eb">More...</a><br /></td></tr>
<tr class="separator:ae74aaf027fda040d4d484ff970f370eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d01be53f7cf9bb538d67aec6a576288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0d01be53f7cf9bb538d67aec6a576288">Cudd_Disequality</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, int c, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y)</td></tr>
<tr class="memdesc:a0d01be53f7cf9bb538d67aec6a576288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function x - y != c.  <a href="#a0d01be53f7cf9bb538d67aec6a576288">More...</a><br /></td></tr>
<tr class="separator:a0d01be53f7cf9bb538d67aec6a576288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705817ee319b2dd8e95b229722b0b65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a705817ee319b2dd8e95b229722b0b65e">Cudd_bddInterval</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int N, <a class="el" href="structDdNode.html">DdNode</a> **x, unsigned int lowerB, unsigned int upperB)</td></tr>
<tr class="memdesc:a705817ee319b2dd8e95b229722b0b65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a BDD for the function lowerB &le; x &le; upperB.  <a href="#a705817ee319b2dd8e95b229722b0b65e">More...</a><br /></td></tr>
<tr class="separator:a705817ee319b2dd8e95b229722b0b65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c2b80e8f71d86bd2f1db454e7fe1b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a88c2b80e8f71d86bd2f1db454e7fe1b2">Cudd_CProjection</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *R, <a class="el" href="structDdNode.html">DdNode</a> *Y)</td></tr>
<tr class="memdesc:a88c2b80e8f71d86bd2f1db454e7fe1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the compatible projection of R w.r.t. cube Y.  <a href="#a88c2b80e8f71d86bd2f1db454e7fe1b2">More...</a><br /></td></tr>
<tr class="separator:a88c2b80e8f71d86bd2f1db454e7fe1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2f14258e299c507e7e4b3dbbb9af3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1a2f14258e299c507e7e4b3dbbb9af3c">Cudd_addHamming</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **xVars, <a class="el" href="structDdNode.html">DdNode</a> **yVars, int nVars)</td></tr>
<tr class="memdesc:a1a2f14258e299c507e7e4b3dbbb9af3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hamming distance ADD.  <a href="#a1a2f14258e299c507e7e4b3dbbb9af3c">More...</a><br /></td></tr>
<tr class="separator:a1a2f14258e299c507e7e4b3dbbb9af3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d75e07d01a7a29c1cfd1b2fae8f4c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac5d75e07d01a7a29c1cfd1b2fae8f4c8">Cudd_MinHammingDist</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *minterm, int upperBound)</td></tr>
<tr class="memdesc:ac5d75e07d01a7a29c1cfd1b2fae8f4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum Hamming distance between f and minterm.  <a href="#ac5d75e07d01a7a29c1cfd1b2fae8f4c8">More...</a><br /></td></tr>
<tr class="separator:ac5d75e07d01a7a29c1cfd1b2fae8f4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac994164b09f82c2cd44b875fa583c60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac994164b09f82c2cd44b875fa583c60d">Cudd_bddClosestCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int *distance)</td></tr>
<tr class="memdesc:ac994164b09f82c2cd44b875fa583c60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a cube of f at minimum Hamming distance from the minterms of g.  <a href="#ac994164b09f82c2cd44b875fa583c60d">More...</a><br /></td></tr>
<tr class="separator:ac994164b09f82c2cd44b875fa583c60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fa1f494a6075b537e13b655c564e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a60fa1f494a6075b537e13b655c564e76">Cudd_addRead</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **E, <a class="el" href="structDdNode.html">DdNode</a> ***x, <a class="el" href="structDdNode.html">DdNode</a> ***y, <a class="el" href="structDdNode.html">DdNode</a> ***xn, <a class="el" href="structDdNode.html">DdNode</a> ***yn_, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy)</td></tr>
<tr class="memdesc:a60fa1f494a6075b537e13b655c564e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a sparse matrix.  <a href="#a60fa1f494a6075b537e13b655c564e76">More...</a><br /></td></tr>
<tr class="separator:a60fa1f494a6075b537e13b655c564e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a5e49e217519cb4d29545aa0bbbb4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa3a5e49e217519cb4d29545aa0bbbb4d">Cudd_bddRead</a> (FILE *fp, <a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **E, <a class="el" href="structDdNode.html">DdNode</a> ***x, <a class="el" href="structDdNode.html">DdNode</a> ***y, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy)</td></tr>
<tr class="memdesc:aa3a5e49e217519cb4d29545aa0bbbb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a graph (without labels) given as a list of arcs.  <a href="#aa3a5e49e217519cb4d29545aa0bbbb4d">More...</a><br /></td></tr>
<tr class="separator:aa3a5e49e217519cb4d29545aa0bbbb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d9959640235fc073699c776914fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3d0d9959640235fc073699c776914fca">Cudd_Ref</a> (<a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a3d0d9959640235fc073699c776914fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the reference count of a node, if it is not saturated.  <a href="#a3d0d9959640235fc073699c776914fca">More...</a><br /></td></tr>
<tr class="separator:a3d0d9959640235fc073699c776914fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944d022761660bf481167b78759f599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0944d022761660bf481167b78759f599">Cudd_RecursiveDeref</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a0944d022761660bf481167b78759f599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of node n.  <a href="#a0944d022761660bf481167b78759f599">More...</a><br /></td></tr>
<tr class="separator:a0944d022761660bf481167b78759f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15905d5750b5f2f948329ce0f67a0fc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a15905d5750b5f2f948329ce0f67a0fc8">Cudd_IterDerefBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a15905d5750b5f2f948329ce0f67a0fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of BDD node n.  <a href="#a15905d5750b5f2f948329ce0f67a0fc8">More...</a><br /></td></tr>
<tr class="separator:a15905d5750b5f2f948329ce0f67a0fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8587ef00c2f8e947d5d78f98a5f4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#afe8587ef00c2f8e947d5d78f98a5f4e7">Cudd_DelayedDerefBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:afe8587ef00c2f8e947d5d78f98a5f4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of BDD node n.  <a href="#afe8587ef00c2f8e947d5d78f98a5f4e7">More...</a><br /></td></tr>
<tr class="separator:afe8587ef00c2f8e947d5d78f98a5f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08641a3718655a85000069cc58cdd172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a08641a3718655a85000069cc58cdd172">Cudd_RecursiveDerefZdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a08641a3718655a85000069cc58cdd172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of ZDD node n.  <a href="#a08641a3718655a85000069cc58cdd172">More...</a><br /></td></tr>
<tr class="separator:a08641a3718655a85000069cc58cdd172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1878b826a0a318e816d419ca5bcea97b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1878b826a0a318e816d419ca5bcea97b">Cudd_Deref</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a1878b826a0a318e816d419ca5bcea97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of node.  <a href="#a1878b826a0a318e816d419ca5bcea97b">More...</a><br /></td></tr>
<tr class="separator:a1878b826a0a318e816d419ca5bcea97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d388f1545438a43167bb55d6c432ef0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0d388f1545438a43167bb55d6c432ef0">Cudd_CheckZeroRef</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager)</td></tr>
<tr class="memdesc:a0d388f1545438a43167bb55d6c432ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the unique table for nodes with non-zero reference counts.  <a href="#a0d388f1545438a43167bb55d6c432ef0">More...</a><br /></td></tr>
<tr class="separator:a0d388f1545438a43167bb55d6c432ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a5a86dfb8ebc7726d6cf56b6a7eec1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1">Cudd_ReduceHeap</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> heuristic, int minsize)</td></tr>
<tr class="memdesc:a02a5a86dfb8ebc7726d6cf56b6a7eec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main dynamic reordering routine.  <a href="#a02a5a86dfb8ebc7726d6cf56b6a7eec1">More...</a><br /></td></tr>
<tr class="separator:a02a5a86dfb8ebc7726d6cf56b6a7eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8568f20319c54de096630b40c998e2e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8568f20319c54de096630b40c998e2e8">Cudd_ShuffleHeap</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, int *permutation)</td></tr>
<tr class="memdesc:a8568f20319c54de096630b40c998e2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders variables according to given permutation.  <a href="#a8568f20319c54de096630b40c998e2e8">More...</a><br /></td></tr>
<tr class="separator:a8568f20319c54de096630b40c998e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f11262fedecf0c0f4376432b478e6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0f11262fedecf0c0f4376432b478e6e8">Cudd_Eval</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *inputs)</td></tr>
<tr class="memdesc:a0f11262fedecf0c0f4376432b478e6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a DD for a given variable assignment.  <a href="#a0f11262fedecf0c0f4376432b478e6e8">More...</a><br /></td></tr>
<tr class="separator:a0f11262fedecf0c0f4376432b478e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e2d36d1fdfa3d917ad345867bd4596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a78e2d36d1fdfa3d917ad345867bd4596">Cudd_ShortestPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight, int *support, int *length)</td></tr>
<tr class="memdesc:a78e2d36d1fdfa3d917ad345867bd4596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a shortest path in a DD.  <a href="#a78e2d36d1fdfa3d917ad345867bd4596">More...</a><br /></td></tr>
<tr class="separator:a78e2d36d1fdfa3d917ad345867bd4596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5722a5bf76d99cd30783ad87ba03bf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5722a5bf76d99cd30783ad87ba03bf96">Cudd_LargestCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *length)</td></tr>
<tr class="memdesc:a5722a5bf76d99cd30783ad87ba03bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a largest cube in a DD.  <a href="#a5722a5bf76d99cd30783ad87ba03bf96">More...</a><br /></td></tr>
<tr class="separator:a5722a5bf76d99cd30783ad87ba03bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#addfc0e508dfd1d0bd0c74104a3dd15e8">Cudd_ShortestLength</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight)</td></tr>
<tr class="memdesc:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the shortest path(s) in a DD.  <a href="#addfc0e508dfd1d0bd0c74104a3dd15e8">More...</a><br /></td></tr>
<tr class="separator:addfc0e508dfd1d0bd0c74104a3dd15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a66a70b011fca8b95fbc3953e8b1be1fe">Cudd_Decreasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr class="memdesc:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is negative unate in a variable.  <a href="#a66a70b011fca8b95fbc3953e8b1be1fe">More...</a><br /></td></tr>
<tr class="separator:a66a70b011fca8b95fbc3953e8b1be1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f87b23df844d48727ee53f75d868be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4f87b23df844d48727ee53f75d868be6">Cudd_Increasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr class="memdesc:a4f87b23df844d48727ee53f75d868be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is positive unate in a variable.  <a href="#a4f87b23df844d48727ee53f75d868be6">More...</a><br /></td></tr>
<tr class="separator:a4f87b23df844d48727ee53f75d868be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e078600dd9087c623e1bdfea00d599d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3e078600dd9087c623e1bdfea00d599d">Cudd_EquivDC</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *F, <a class="el" href="structDdNode.html">DdNode</a> *G, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr class="memdesc:a3e078600dd9087c623e1bdfea00d599d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether F and G are identical wherever D is 0.  <a href="#a3e078600dd9087c623e1bdfea00d599d">More...</a><br /></td></tr>
<tr class="separator:a3e078600dd9087c623e1bdfea00d599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcbf450b32f6937bc6dba252474638d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5dcbf450b32f6937bc6dba252474638d">Cudd_bddLeqUnless</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr class="memdesc:a5dcbf450b32f6937bc6dba252474638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether f is less than of equal to G unless D is 1.  <a href="#a5dcbf450b32f6937bc6dba252474638d">More...</a><br /></td></tr>
<tr class="separator:a5dcbf450b32f6937bc6dba252474638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0be57ead326db49e00a51d7acf75f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#abe0be57ead326db49e00a51d7acf75f9">Cudd_EqualSupNorm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> tolerance, int pr)</td></tr>
<tr class="memdesc:abe0be57ead326db49e00a51d7acf75f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ADDs for equality within tolerance.  <a href="#abe0be57ead326db49e00a51d7acf75f9">More...</a><br /></td></tr>
<tr class="separator:abe0be57ead326db49e00a51d7acf75f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b924211354f5d356009a7c804be2340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7b924211354f5d356009a7c804be2340">Cudd_bddMakePrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a7b924211354f5d356009a7c804be2340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands cube to a prime implicant of f.  <a href="#a7b924211354f5d356009a7c804be2340">More...</a><br /></td></tr>
<tr class="separator:a7b924211354f5d356009a7c804be2340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb9bb89f75fe6176be961c73a19be09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#accb9bb89f75fe6176be961c73a19be09">Cudd_bddMaximallyExpand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *lb, <a class="el" href="structDdNode.html">DdNode</a> *ub, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:accb9bb89f75fe6176be961c73a19be09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands lb to prime implicants of (f and ub).  <a href="#accb9bb89f75fe6176be961c73a19be09">More...</a><br /></td></tr>
<tr class="separator:accb9bb89f75fe6176be961c73a19be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3a45afd92abdea6f969399e7c0eb5c8f">Cudd_bddLargestPrimeUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *phaseBdd)</td></tr>
<tr class="memdesc:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a largest prime implicant of a unate function.  <a href="#a3a45afd92abdea6f969399e7c0eb5c8f">More...</a><br /></td></tr>
<tr class="separator:a3a45afd92abdea6f969399e7c0eb5c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d22c9f437512fb0cc44107174f3bab"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a86d22c9f437512fb0cc44107174f3bab">Cudd_CofMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a86d22c9f437512fb0cc44107174f3bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the fraction of minterms in the on-set of all the positive cofactors of a BDD or ADD.  <a href="#a86d22c9f437512fb0cc44107174f3bab">More...</a><br /></td></tr>
<tr class="separator:a86d22c9f437512fb0cc44107174f3bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6c21f42d3912604516687f47fd0f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5e6c21f42d3912604516687f47fd0f12">Cudd_SolveEqn</a> (<a class="el" href="structDdManager.html">DdManager</a> *bdd, <a class="el" href="structDdNode.html">DdNode</a> *F, <a class="el" href="structDdNode.html">DdNode</a> *Y, <a class="el" href="structDdNode.html">DdNode</a> **G, int **yIndex, int n)</td></tr>
<tr class="memdesc:a5e6c21f42d3912604516687f47fd0f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the solution of F(x,y) = 0.  <a href="#a5e6c21f42d3912604516687f47fd0f12">More...</a><br /></td></tr>
<tr class="separator:a5e6c21f42d3912604516687f47fd0f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232cca2744915ebae9aecedb78a83dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a232cca2744915ebae9aecedb78a83dd5">Cudd_VerifySol</a> (<a class="el" href="structDdManager.html">DdManager</a> *bdd, <a class="el" href="structDdNode.html">DdNode</a> *F, <a class="el" href="structDdNode.html">DdNode</a> **G, int *yIndex, int n)</td></tr>
<tr class="memdesc:a232cca2744915ebae9aecedb78a83dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the solution of F(x,y) = 0.  <a href="#a232cca2744915ebae9aecedb78a83dd5">More...</a><br /></td></tr>
<tr class="separator:a232cca2744915ebae9aecedb78a83dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5386715b96f5d263045e0ee11703ee7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5386715b96f5d263045e0ee11703ee7c">Cudd_SplitSet</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *S, <a class="el" href="structDdNode.html">DdNode</a> **xVars, int n, double m)</td></tr>
<tr class="memdesc:a5386715b96f5d263045e0ee11703ee7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns m minterms from a BDD.  <a href="#a5386715b96f5d263045e0ee11703ee7c">More...</a><br /></td></tr>
<tr class="separator:a5386715b96f5d263045e0ee11703ee7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7579ecbb0187c4061cc2d45a3a21e68e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7579ecbb0187c4061cc2d45a3a21e68e">Cudd_SubsetHeavyBranch</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold)</td></tr>
<tr class="memdesc:a7579ecbb0187c4061cc2d45a3a21e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the heavy branch heuristic.  <a href="#a7579ecbb0187c4061cc2d45a3a21e68e">More...</a><br /></td></tr>
<tr class="separator:a7579ecbb0187c4061cc2d45a3a21e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5562f42d8ed481485bcb9d5469b2cedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5562f42d8ed481485bcb9d5469b2cedd">Cudd_SupersetHeavyBranch</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold)</td></tr>
<tr class="memdesc:a5562f42d8ed481485bcb9d5469b2cedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the heavy branch heuristic.  <a href="#a5562f42d8ed481485bcb9d5469b2cedd">More...</a><br /></td></tr>
<tr class="separator:a5562f42d8ed481485bcb9d5469b2cedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890a2da46a4d6cec913e2ae57a9ab626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a890a2da46a4d6cec913e2ae57a9ab626">Cudd_SubsetShortPaths</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int hardlimit)</td></tr>
<tr class="memdesc:a890a2da46a4d6cec913e2ae57a9ab626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the shortest paths heuristic.  <a href="#a890a2da46a4d6cec913e2ae57a9ab626">More...</a><br /></td></tr>
<tr class="separator:a890a2da46a4d6cec913e2ae57a9ab626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8ed34596ee3ef413bc804f08de8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a64d8ed34596ee3ef413bc804f08de8f7">Cudd_SupersetShortPaths</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int hardlimit)</td></tr>
<tr class="memdesc:a64d8ed34596ee3ef413bc804f08de8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the shortest paths heuristic.  <a href="#a64d8ed34596ee3ef413bc804f08de8f7">More...</a><br /></td></tr>
<tr class="separator:a64d8ed34596ee3ef413bc804f08de8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd2716996fec765f23ec7bca30f14b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a83fd2716996fec765f23ec7bca30f14b">Cudd_SymmProfile</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, int lower, int upper)</td></tr>
<tr class="memdesc:a83fd2716996fec765f23ec7bca30f14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistics on symmetric variables.  <a href="#a83fd2716996fec765f23ec7bca30f14b">More...</a><br /></td></tr>
<tr class="separator:a83fd2716996fec765f23ec7bca30f14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405445d35a7c41877fe916f6dfa11472"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a405445d35a7c41877fe916f6dfa11472">Cudd_Prime</a> (unsigned int p)</td></tr>
<tr class="memdesc:a405445d35a7c41877fe916f6dfa11472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next prime &ge; p.  <a href="#a405445d35a7c41877fe916f6dfa11472">More...</a><br /></td></tr>
<tr class="separator:a405445d35a7c41877fe916f6dfa11472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b694fd53078a6f3f6a0e73cd97fd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ade6b694fd53078a6f3f6a0e73cd97fd9">Cudd_Reserve</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, int amount)</td></tr>
<tr class="memdesc:ade6b694fd53078a6f3f6a0e73cd97fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand manager without creating variables.  <a href="#ade6b694fd53078a6f3f6a0e73cd97fd9">More...</a><br /></td></tr>
<tr class="separator:ade6b694fd53078a6f3f6a0e73cd97fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab82cceadafa2b81083e0467c102526"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aeab82cceadafa2b81083e0467c102526">Cudd_PrintMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:aeab82cceadafa2b81083e0467c102526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a disjoint sum of products.  <a href="#aeab82cceadafa2b81083e0467c102526">More...</a><br /></td></tr>
<tr class="separator:aeab82cceadafa2b81083e0467c102526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61fadaf6046697691b35fad8c9faf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8b61fadaf6046697691b35fad8c9faf0">Cudd_bddPrintCover</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr class="memdesc:a8b61fadaf6046697691b35fad8c9faf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a sum of prime implicants of a BDD.  <a href="#a8b61fadaf6046697691b35fad8c9faf0">More...</a><br /></td></tr>
<tr class="separator:a8b61fadaf6046697691b35fad8c9faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46a1b9147411ce547a2e03305d6c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a1e46a1b9147411ce547a2e03305d6c22">Cudd_PrintDebug</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int n, int pr)</td></tr>
<tr class="memdesc:a1e46a1b9147411ce547a2e03305d6c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to the manager standard output a DD and its statistics.  <a href="#a1e46a1b9147411ce547a2e03305d6c22">More...</a><br /></td></tr>
<tr class="separator:a1e46a1b9147411ce547a2e03305d6c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac610821afa1bb9ad8432a3c656eb81cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac610821afa1bb9ad8432a3c656eb81cd">Cudd_PrintSummary</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int n, int mode)</td></tr>
<tr class="memdesc:ac610821afa1bb9ad8432a3c656eb81cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a one-line summary of an ADD or BDD to the manager stdout.  <a href="#ac610821afa1bb9ad8432a3c656eb81cd">More...</a><br /></td></tr>
<tr class="separator:ac610821afa1bb9ad8432a3c656eb81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf613390a7dbeaad14b3963d68de24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a95cf613390a7dbeaad14b3963d68de24">Cudd_DagSize</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a95cf613390a7dbeaad14b3963d68de24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a DD.  <a href="#a95cf613390a7dbeaad14b3963d68de24">More...</a><br /></td></tr>
<tr class="separator:a95cf613390a7dbeaad14b3963d68de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3de83b78306f45ce8ea65c2fd15122"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3a3de83b78306f45ce8ea65c2fd15122">Cudd_EstimateCofactor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int i, int phase)</td></tr>
<tr class="memdesc:a3a3de83b78306f45ce8ea65c2fd15122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of nodes in a cofactor of a DD.  <a href="#a3a3de83b78306f45ce8ea65c2fd15122">More...</a><br /></td></tr>
<tr class="separator:a3a3de83b78306f45ce8ea65c2fd15122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23b2111b9f214571866c6e88035a9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3e23b2111b9f214571866c6e88035a9d">Cudd_EstimateCofactorSimple</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, int i)</td></tr>
<tr class="memdesc:a3e23b2111b9f214571866c6e88035a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of nodes in a cofactor of a DD.  <a href="#a3e23b2111b9f214571866c6e88035a9d">More...</a><br /></td></tr>
<tr class="separator:a3e23b2111b9f214571866c6e88035a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d57cfc6ede9ae452a40779b58a3bac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a49d57cfc6ede9ae452a40779b58a3bac">Cudd_SharingSize</a> (<a class="el" href="structDdNode.html">DdNode</a> **nodeArray, int n)</td></tr>
<tr class="memdesc:a49d57cfc6ede9ae452a40779b58a3bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in an array of DDs.  <a href="#a49d57cfc6ede9ae452a40779b58a3bac">More...</a><br /></td></tr>
<tr class="separator:a49d57cfc6ede9ae452a40779b58a3bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f187be7f86701d59f924860970a0b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa1f187be7f86701d59f924860970a0b9">Cudd_CountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:aa1f187be7f86701d59f924860970a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the minterms of an ADD or BDD.  <a href="#aa1f187be7f86701d59f924860970a0b9">More...</a><br /></td></tr>
<tr class="separator:aa1f187be7f86701d59f924860970a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb9e0fde5043297b133ce6516e9a99"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a91cb9e0fde5043297b133ce6516e9a99">Cudd_LdblCountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:a91cb9e0fde5043297b133ce6516e9a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of minterms of aa ADD or BDD as a long double.  <a href="#a91cb9e0fde5043297b133ce6516e9a99">More...</a><br /></td></tr>
<tr class="separator:a91cb9e0fde5043297b133ce6516e9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a38e134284702f2455b5454ff0ece5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa5a38e134284702f2455b5454ff0ece5">Cudd_EpdPrintMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:aa5a38e134284702f2455b5454ff0ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of minterms of an ADD or BDD with extended range.  <a href="#aa5a38e134284702f2455b5454ff0ece5">More...</a><br /></td></tr>
<tr class="separator:aa5a38e134284702f2455b5454ff0ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95929aeb92541971db3e5798920e6882"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a95929aeb92541971db3e5798920e6882">Cudd_CountPath</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a95929aeb92541971db3e5798920e6882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the paths of a DD.  <a href="#a95929aeb92541971db3e5798920e6882">More...</a><br /></td></tr>
<tr class="separator:a95929aeb92541971db3e5798920e6882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1533ac1641e3ee3260d336e863052c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2b1533ac1641e3ee3260d336e863052c">Cudd_CountPathsToNonZero</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a2b1533ac1641e3ee3260d336e863052c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the paths to a non-zero terminal of a DD.  <a href="#a2b1533ac1641e3ee3260d336e863052c">More...</a><br /></td></tr>
<tr class="separator:a2b1533ac1641e3ee3260d336e863052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e317288c1b57e0097013d52435d23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a455e317288c1b57e0097013d52435d23">Cudd_SupportIndices</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int **indices)</td></tr>
<tr class="memdesc:a455e317288c1b57e0097013d52435d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#a455e317288c1b57e0097013d52435d23">More...</a><br /></td></tr>
<tr class="separator:a455e317288c1b57e0097013d52435d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f8e5b8efe97330f8650e1378ad172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9e1f8e5b8efe97330f8650e1378ad172">Cudd_Support</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a9e1f8e5b8efe97330f8650e1378ad172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#a9e1f8e5b8efe97330f8650e1378ad172">More...</a><br /></td></tr>
<tr class="separator:a9e1f8e5b8efe97330f8650e1378ad172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc898f0fe024bece58bb9e992845bb73"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adc898f0fe024bece58bb9e992845bb73">Cudd_SupportIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:adc898f0fe024bece58bb9e992845bb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#adc898f0fe024bece58bb9e992845bb73">More...</a><br /></td></tr>
<tr class="separator:adc898f0fe024bece58bb9e992845bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0e7cde5c4dfd8832de07de9b31e9469e">Cudd_SupportSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the variables on which a DD depends.  <a href="#a0e7cde5c4dfd8832de07de9b31e9469e">More...</a><br /></td></tr>
<tr class="separator:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd4942d4c62cb3a539a8039084d571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac6fd4942d4c62cb3a539a8039084d571">Cudd_VectorSupportIndices</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n, int **indices)</td></tr>
<tr class="memdesc:ac6fd4942d4c62cb3a539a8039084d571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#ac6fd4942d4c62cb3a539a8039084d571">More...</a><br /></td></tr>
<tr class="separator:ac6fd4942d4c62cb3a539a8039084d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8f6cf8a1719f76a3e121e7f61c406d5b">Cudd_VectorSupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#a8f6cf8a1719f76a3e121e7f61c406d5b">More...</a><br /></td></tr>
<tr class="separator:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a3eda5431ad0985605921d16c83067"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa3a3eda5431ad0985605921d16c83067">Cudd_VectorSupportIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:aa3a3eda5431ad0985605921d16c83067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#aa3a3eda5431ad0985605921d16c83067">More...</a><br /></td></tr>
<tr class="separator:aa3a3eda5431ad0985605921d16c83067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a66da9c2c22b9bbb31120bd0a28fbf83c">Cudd_VectorSupportSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the variables on which a set of DDs depends.  <a href="#a66da9c2c22b9bbb31120bd0a28fbf83c">More...</a><br /></td></tr>
<tr class="separator:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf3183bbb7822b76bacd8b70aebc94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2caf3183bbb7822b76bacd8b70aebc94">Cudd_ClassifySupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> **common, <a class="el" href="structDdNode.html">DdNode</a> **onlyF, <a class="el" href="structDdNode.html">DdNode</a> **onlyG)</td></tr>
<tr class="memdesc:a2caf3183bbb7822b76bacd8b70aebc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the variables in the support of two DDs.  <a href="#a2caf3183bbb7822b76bacd8b70aebc94">More...</a><br /></td></tr>
<tr class="separator:a2caf3183bbb7822b76bacd8b70aebc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af4867b046a794f5db312c69922790d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2af4867b046a794f5db312c69922790d">Cudd_CountLeaves</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a2af4867b046a794f5db312c69922790d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of leaves in a DD.  <a href="#a2af4867b046a794f5db312c69922790d">More...</a><br /></td></tr>
<tr class="separator:a2af4867b046a794f5db312c69922790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc47738ff8b49602d4e1442fd55576f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adcc47738ff8b49602d4e1442fd55576f">Cudd_bddPickOneCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *ddm, <a class="el" href="structDdNode.html">DdNode</a> *node, char *string)</td></tr>
<tr class="memdesc:adcc47738ff8b49602d4e1442fd55576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks one on-set cube randomly from the given DD.  <a href="#adcc47738ff8b49602d4e1442fd55576f">More...</a><br /></td></tr>
<tr class="separator:adcc47738ff8b49602d4e1442fd55576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f68528887c0feb428d010c2173a59b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a57f68528887c0feb428d010c2173a59b">Cudd_bddPickOneMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int n)</td></tr>
<tr class="memdesc:a57f68528887c0feb428d010c2173a59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks one on-set minterm randomly from the given DD.  <a href="#a57f68528887c0feb428d010c2173a59b">More...</a><br /></td></tr>
<tr class="separator:a57f68528887c0feb428d010c2173a59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a57c4e8e8d0b9ec3101e117629a2a459d">Cudd_bddPickArbitraryMinterms</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int n, int k)</td></tr>
<tr class="memdesc:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks k on-set minterms evenly distributed from given DD.  <a href="#a57c4e8e8d0b9ec3101e117629a2a459d">More...</a><br /></td></tr>
<tr class="separator:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7410606294a5fb0896c8787019db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab8e7410606294a5fb0896c8787019db1">Cudd_SubsetWithMaskVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int nvars, <a class="el" href="structDdNode.html">DdNode</a> **maskVars, int mvars)</td></tr>
<tr class="memdesc:ab8e7410606294a5fb0896c8787019db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a subset from a BDD.  <a href="#ab8e7410606294a5fb0896c8787019db1">More...</a><br /></td></tr>
<tr class="separator:ab8e7410606294a5fb0896c8787019db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4">Cudd_FirstCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int **cube, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *value)</td></tr>
<tr class="memdesc:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first cube of a decision diagram.  <a href="#a139d8dd64955ecf3e2fd4c5d6ceeebb4">More...</a><br /></td></tr>
<tr class="separator:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a05f1698806d45eaba7f4a5721dd5c3c8">Cudd_NextCube</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, int **cube, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *value)</td></tr>
<tr class="memdesc:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next cube of a decision diagram onset.  <a href="#a05f1698806d45eaba7f4a5721dd5c3c8">More...</a><br /></td></tr>
<tr class="separator:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65691b560210512cf1f8d92f0c1ece9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a65691b560210512cf1f8d92f0c1ece9a">Cudd_FirstPrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u, int **cube)</td></tr>
<tr class="memdesc:a65691b560210512cf1f8d92f0c1ece9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first prime of a Boolean function.  <a href="#a65691b560210512cf1f8d92f0c1ece9a">More...</a><br /></td></tr>
<tr class="separator:a65691b560210512cf1f8d92f0c1ece9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73">Cudd_NextPrime</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, int **cube)</td></tr>
<tr class="memdesc:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next prime of a Boolean function.  <a href="#ae9c8ccb352d96ca9bde4ab97a1ee8e73">More...</a><br /></td></tr>
<tr class="separator:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab538e936fe0bdfe380f0ad2ecd2c6581">Cudd_bddComputeCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **vars, int *phase, int n)</td></tr>
<tr class="memdesc:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cube of an array of BDD variables.  <a href="#ab538e936fe0bdfe380f0ad2ecd2c6581">More...</a><br /></td></tr>
<tr class="separator:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7d0901cba492671c25ee816510867c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2e7d0901cba492671c25ee816510867c">Cudd_addComputeCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **vars, int *phase, int n)</td></tr>
<tr class="memdesc:a2e7d0901cba492671c25ee816510867c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cube of an array of ADD variables.  <a href="#a2e7d0901cba492671c25ee816510867c">More...</a><br /></td></tr>
<tr class="separator:a2e7d0901cba492671c25ee816510867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2d2f87d831cfe727250103fc880da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4ac2d2f87d831cfe727250103fc880da">Cudd_CubeArrayToBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int *array)</td></tr>
<tr class="memdesc:a4ac2d2f87d831cfe727250103fc880da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the BDD of a cube from a positional array.  <a href="#a4ac2d2f87d831cfe727250103fc880da">More...</a><br /></td></tr>
<tr class="separator:a4ac2d2f87d831cfe727250103fc880da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53ebc58628a5a659b86025e6ed9c492"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab53ebc58628a5a659b86025e6ed9c492">Cudd_BddToCubeArray</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, int *array)</td></tr>
<tr class="memdesc:ab53ebc58628a5a659b86025e6ed9c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a positional array from the BDD of a cube.  <a href="#ab53ebc58628a5a659b86025e6ed9c492">More...</a><br /></td></tr>
<tr class="separator:ab53ebc58628a5a659b86025e6ed9c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a0cbbad0f18b5767a4924ff6b069bbc7f">Cudd_FirstNode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **node)</td></tr>
<tr class="memdesc:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first node of a decision diagram.  <a href="#a0cbbad0f18b5767a4924ff6b069bbc7f">More...</a><br /></td></tr>
<tr class="separator:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f04ddcd448e741233d5bc16562171"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a627f04ddcd448e741233d5bc16562171">Cudd_NextNode</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, <a class="el" href="structDdNode.html">DdNode</a> **node)</td></tr>
<tr class="memdesc:a627f04ddcd448e741233d5bc16562171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next node of a decision diagram.  <a href="#a627f04ddcd448e741233d5bc16562171">More...</a><br /></td></tr>
<tr class="separator:a627f04ddcd448e741233d5bc16562171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16a8509f9959aff3a0c553a0427e656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen)</td></tr>
<tr class="memdesc:aa16a8509f9959aff3a0c553a0427e656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a CUDD generator.  <a href="#aa16a8509f9959aff3a0c553a0427e656">More...</a><br /></td></tr>
<tr class="separator:aa16a8509f9959aff3a0c553a0427e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46290c6915c9d64fbe24a3faf40ced5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a46290c6915c9d64fbe24a3faf40ced5d">Cudd_IsGenEmpty</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen)</td></tr>
<tr class="memdesc:a46290c6915c9d64fbe24a3faf40ced5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the status of a generator.  <a href="#a46290c6915c9d64fbe24a3faf40ced5d">More...</a><br /></td></tr>
<tr class="separator:a46290c6915c9d64fbe24a3faf40ced5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2815667bcad915fac2620161a577c46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2815667bcad915fac2620161a577c46b">Cudd_IndicesToCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int *array, int n)</td></tr>
<tr class="memdesc:a2815667bcad915fac2620161a577c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a cube of BDD variables from an array of indices.  <a href="#a2815667bcad915fac2620161a577c46b">More...</a><br /></td></tr>
<tr class="separator:a2815667bcad915fac2620161a577c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acd64fd5ed246def2ad791e7b0ddeec2b">Cudd_PrintVersion</a> (FILE *fp)</td></tr>
<tr class="memdesc:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the package version number.  <a href="#acd64fd5ed246def2ad791e7b0ddeec2b">More...</a><br /></td></tr>
<tr class="separator:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a0af9f50ad2f6430d354193497c16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a142a0af9f50ad2f6430d354193497c16">Cudd_AverageDistance</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a142a0af9f50ad2f6430d354193497c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average distance between adjacent nodes in the manager.  <a href="#a142a0af9f50ad2f6430d354193497c16">More...</a><br /></td></tr>
<tr class="separator:a142a0af9f50ad2f6430d354193497c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7aca63dd70f27ea0245f0c269ffff6d1">Cudd_Random</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable random number generator.  <a href="#a7aca63dd70f27ea0245f0c269ffff6d1">More...</a><br /></td></tr>
<tr class="separator:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a20c2b03a12919a3d146c7e02b4f3e4bd">Cudd_Srandom</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int32_t seed)</td></tr>
<tr class="memdesc:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for the portable random number generator.  <a href="#a20c2b03a12919a3d146c7e02b4f3e4bd">More...</a><br /></td></tr>
<tr class="separator:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d6258d2a451f8d852941de13d623dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a31d6258d2a451f8d852941de13d623dc">Cudd_Density</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars)</td></tr>
<tr class="memdesc:a31d6258d2a451f8d852941de13d623dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the density of a BDD or ADD.  <a href="#a31d6258d2a451f8d852941de13d623dc">More...</a><br /></td></tr>
<tr class="separator:a31d6258d2a451f8d852941de13d623dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cf07a23729b7f2621c74bf1e2ff830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a77cf07a23729b7f2621c74bf1e2ff830">Cudd_OutOfMem</a> (size_t size)</td></tr>
<tr class="memdesc:a77cf07a23729b7f2621c74bf1e2ff830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warns that a memory allocation failed.  <a href="#a77cf07a23729b7f2621c74bf1e2ff830">More...</a><br /></td></tr>
<tr class="separator:a77cf07a23729b7f2621c74bf1e2ff830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e655bc7b71ea719534f40fb8faa393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa6e655bc7b71ea719534f40fb8faa393">Cudd_OutOfMemSilent</a> (size_t size)</td></tr>
<tr class="memdesc:aa6e655bc7b71ea719534f40fb8faa393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doesn not warn that a memory allocation failed.  <a href="#aa6e655bc7b71ea719534f40fb8faa393">More...</a><br /></td></tr>
<tr class="separator:aa6e655bc7b71ea719534f40fb8faa393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ab3f05743b5f9c2516058bde45dc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9c5ab3f05743b5f9c2516058bde45dc9">Cudd_zddCount</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *P)</td></tr>
<tr class="memdesc:a9c5ab3f05743b5f9c2516058bde45dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of minterms in a ZDD.  <a href="#a9c5ab3f05743b5f9c2516058bde45dc9">More...</a><br /></td></tr>
<tr class="separator:a9c5ab3f05743b5f9c2516058bde45dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4865c5d167f246c03b1442e8183bd0d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa4865c5d167f246c03b1442e8183bd0d">Cudd_zddCountDouble</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *P)</td></tr>
<tr class="memdesc:aa4865c5d167f246c03b1442e8183bd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of minterms of a ZDD.  <a href="#aa4865c5d167f246c03b1442e8183bd0d">More...</a><br /></td></tr>
<tr class="separator:aa4865c5d167f246c03b1442e8183bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419b6b27fabd4f4994c1c5df0c5527cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a419b6b27fabd4f4994c1c5df0c5527cb">Cudd_zddProduct</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a419b6b27fabd4f4994c1c5df0c5527cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of two covers represented by ZDDs.  <a href="#a419b6b27fabd4f4994c1c5df0c5527cb">More...</a><br /></td></tr>
<tr class="separator:a419b6b27fabd4f4994c1c5df0c5527cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb4a8cdc966acd5bd4ddabc42c6fb8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4eb4a8cdc966acd5bd4ddabc42c6fb8e">Cudd_zddUnateProduct</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a4eb4a8cdc966acd5bd4ddabc42c6fb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of two unate covers represented as ZDDs.  <a href="#a4eb4a8cdc966acd5bd4ddabc42c6fb8e">More...</a><br /></td></tr>
<tr class="separator:a4eb4a8cdc966acd5bd4ddabc42c6fb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104e65b094b4cfe361a4344fd7746b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a104e65b094b4cfe361a4344fd7746b11">Cudd_zddWeakDiv</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a104e65b094b4cfe361a4344fd7746b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies weak division to two covers.  <a href="#a104e65b094b4cfe361a4344fd7746b11">More...</a><br /></td></tr>
<tr class="separator:a104e65b094b4cfe361a4344fd7746b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e1add8b7cebce529186f3940c095f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a43e1add8b7cebce529186f3940c095f8">Cudd_zddDivide</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a43e1add8b7cebce529186f3940c095f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient of two unate covers.  <a href="#a43e1add8b7cebce529186f3940c095f8">More...</a><br /></td></tr>
<tr class="separator:a43e1add8b7cebce529186f3940c095f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7919ec84ae5121722ca263298f81edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ae7919ec84ae5121722ca263298f81edb">Cudd_zddWeakDivF</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:ae7919ec84ae5121722ca263298f81edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified version of Cudd_zddWeakDiv.  <a href="#ae7919ec84ae5121722ca263298f81edb">More...</a><br /></td></tr>
<tr class="separator:ae7919ec84ae5121722ca263298f81edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acdb146297a02315d409b7c050a6d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8acdb146297a02315d409b7c050a6d5a">Cudd_zddDivideF</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr class="memdesc:a8acdb146297a02315d409b7c050a6d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified version of Cudd_zddDivide.  <a href="#a8acdb146297a02315d409b7c050a6d5a">More...</a><br /></td></tr>
<tr class="separator:a8acdb146297a02315d409b7c050a6d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749226024982a86616474fede5544632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a749226024982a86616474fede5544632">Cudd_zddComplement</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a749226024982a86616474fede5544632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a complement cover for a ZDD node.  <a href="#a749226024982a86616474fede5544632">More...</a><br /></td></tr>
<tr class="separator:a749226024982a86616474fede5544632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5124feb3accdd31cfeb287ffff59f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2b5124feb3accdd31cfeb287ffff59f7">Cudd_zddIsop</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *L, <a class="el" href="structDdNode.html">DdNode</a> *U, <a class="el" href="structDdNode.html">DdNode</a> **zdd_I)</td></tr>
<tr class="memdesc:a2b5124feb3accdd31cfeb287ffff59f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an ISOP in ZDD form from BDDs.  <a href="#a2b5124feb3accdd31cfeb287ffff59f7">More...</a><br /></td></tr>
<tr class="separator:a2b5124feb3accdd31cfeb287ffff59f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17691865ef8b69e1d04ce5651da841e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a17691865ef8b69e1d04ce5651da841e0">Cudd_bddIsop</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *L, <a class="el" href="structDdNode.html">DdNode</a> *U)</td></tr>
<tr class="memdesc:a17691865ef8b69e1d04ce5651da841e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a BDD in the interval between L and U with a simple sum-of-product cover.  <a href="#a17691865ef8b69e1d04ce5651da841e0">More...</a><br /></td></tr>
<tr class="separator:a17691865ef8b69e1d04ce5651da841e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e686dece52e90ac6bf16751ca92859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a71e686dece52e90ac6bf16751ca92859">Cudd_MakeBddFromZddCover</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a71e686dece52e90ac6bf16751ca92859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ZDD cover to a BDD.  <a href="#a71e686dece52e90ac6bf16751ca92859">More...</a><br /></td></tr>
<tr class="separator:a71e686dece52e90ac6bf16751ca92859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7634b40c8a867ba64b3cedbbd0e206d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7634b40c8a867ba64b3cedbbd0e206d2">Cudd_zddDagSize</a> (<a class="el" href="structDdNode.html">DdNode</a> *p_node)</td></tr>
<tr class="memdesc:a7634b40c8a867ba64b3cedbbd0e206d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a ZDD.  <a href="#a7634b40c8a867ba64b3cedbbd0e206d2">More...</a><br /></td></tr>
<tr class="separator:a7634b40c8a867ba64b3cedbbd0e206d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ada301191a7910766596736ac5b0a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6e2ada301191a7910766596736ac5b0a">Cudd_zddCountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *node, int path)</td></tr>
<tr class="memdesc:a6e2ada301191a7910766596736ac5b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of minterms of a ZDD.  <a href="#a6e2ada301191a7910766596736ac5b0a">More...</a><br /></td></tr>
<tr class="separator:a6e2ada301191a7910766596736ac5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42425fde9bd20de470d590dae86fe111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a42425fde9bd20de470d590dae86fe111">Cudd_zddPrintSubtable</a> (<a class="el" href="structDdManager.html">DdManager</a> *table)</td></tr>
<tr class="memdesc:a42425fde9bd20de470d590dae86fe111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the ZDD table for debugging purposes.  <a href="#a42425fde9bd20de470d590dae86fe111">More...</a><br /></td></tr>
<tr class="separator:a42425fde9bd20de470d590dae86fe111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5f6cf86e962f2caef6492052039237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acf5f6cf86e962f2caef6492052039237">Cudd_zddPortFromBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *B)</td></tr>
<tr class="memdesc:acf5f6cf86e962f2caef6492052039237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a BDD into a ZDD.  <a href="#acf5f6cf86e962f2caef6492052039237">More...</a><br /></td></tr>
<tr class="separator:acf5f6cf86e962f2caef6492052039237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cdf0b63218f1adf43c59a29650d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a4f3cdf0b63218f1adf43c59a29650d76">Cudd_zddPortToBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a4f3cdf0b63218f1adf43c59a29650d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ZDD into a BDD.  <a href="#a4f3cdf0b63218f1adf43c59a29650d76">More...</a><br /></td></tr>
<tr class="separator:a4f3cdf0b63218f1adf43c59a29650d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a6a57fc8464e16e222c130aed593d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ab2a6a57fc8464e16e222c130aed593d9">Cudd_zddReduceHeap</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, <a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> heuristic, int minsize)</td></tr>
<tr class="memdesc:ab2a6a57fc8464e16e222c130aed593d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main dynamic reordering routine for ZDDs.  <a href="#ab2a6a57fc8464e16e222c130aed593d9">More...</a><br /></td></tr>
<tr class="separator:ab2a6a57fc8464e16e222c130aed593d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f07e5730ad04e0217b2b6a8e813042"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aa2f07e5730ad04e0217b2b6a8e813042">Cudd_zddShuffleHeap</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, int *permutation)</td></tr>
<tr class="memdesc:aa2f07e5730ad04e0217b2b6a8e813042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders ZDD variables according to given permutation.  <a href="#aa2f07e5730ad04e0217b2b6a8e813042">More...</a><br /></td></tr>
<tr class="separator:aa2f07e5730ad04e0217b2b6a8e813042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41777e8aa4a688ac964ea2564e5ae4be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a41777e8aa4a688ac964ea2564e5ae4be">Cudd_zddIte</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr class="memdesc:a41777e8aa4a688ac964ea2564e5ae4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ITE of three ZDDs.  <a href="#a41777e8aa4a688ac964ea2564e5ae4be">More...</a><br /></td></tr>
<tr class="separator:a41777e8aa4a688ac964ea2564e5ae4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc0f519f9a3aa14a3ee376c3e65e13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5fc0f519f9a3aa14a3ee376c3e65e13b">Cudd_zddUnion</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, <a class="el" href="structDdNode.html">DdNode</a> *Q)</td></tr>
<tr class="memdesc:a5fc0f519f9a3aa14a3ee376c3e65e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of two ZDDs.  <a href="#a5fc0f519f9a3aa14a3ee376c3e65e13b">More...</a><br /></td></tr>
<tr class="separator:a5fc0f519f9a3aa14a3ee376c3e65e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be281a73703e9d817bb3e497e35d0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8be281a73703e9d817bb3e497e35d0fd">Cudd_zddIntersect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, <a class="el" href="structDdNode.html">DdNode</a> *Q)</td></tr>
<tr class="memdesc:a8be281a73703e9d817bb3e497e35d0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of two ZDDs.  <a href="#a8be281a73703e9d817bb3e497e35d0fd">More...</a><br /></td></tr>
<tr class="separator:a8be281a73703e9d817bb3e497e35d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73fc58a0086966fcec55169951b61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#adc73fc58a0086966fcec55169951b61d">Cudd_zddDiff</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, <a class="el" href="structDdNode.html">DdNode</a> *Q)</td></tr>
<tr class="memdesc:adc73fc58a0086966fcec55169951b61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of two ZDDs.  <a href="#adc73fc58a0086966fcec55169951b61d">More...</a><br /></td></tr>
<tr class="separator:adc73fc58a0086966fcec55169951b61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59302de6443444bd5a0cc69e0eb09533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a59302de6443444bd5a0cc69e0eb09533">Cudd_zddDiffConst</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *P, <a class="el" href="structDdNode.html">DdNode</a> *Q)</td></tr>
<tr class="memdesc:a59302de6443444bd5a0cc69e0eb09533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the inclusion test for ZDDs (P implies Q).  <a href="#a59302de6443444bd5a0cc69e0eb09533">More...</a><br /></td></tr>
<tr class="separator:a59302de6443444bd5a0cc69e0eb09533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca2965bda4c37d1dbb881325644804b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a6ca2965bda4c37d1dbb881325644804b">Cudd_zddSubset1</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, int var)</td></tr>
<tr class="memdesc:a6ca2965bda4c37d1dbb881325644804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the positive cofactor of a ZDD w.r.t. a variable.  <a href="#a6ca2965bda4c37d1dbb881325644804b">More...</a><br /></td></tr>
<tr class="separator:a6ca2965bda4c37d1dbb881325644804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0822a83d4fd25d1e68969fe283886ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad0822a83d4fd25d1e68969fe283886ac">Cudd_zddSubset0</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, int var)</td></tr>
<tr class="memdesc:ad0822a83d4fd25d1e68969fe283886ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the negative cofactor of a ZDD w.r.t. a variable.  <a href="#ad0822a83d4fd25d1e68969fe283886ac">More...</a><br /></td></tr>
<tr class="separator:ad0822a83d4fd25d1e68969fe283886ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e29f906fd682376f4b15676c840fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#af1e29f906fd682376f4b15676c840fe2">Cudd_zddChange</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *P, int var)</td></tr>
<tr class="memdesc:af1e29f906fd682376f4b15676c840fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes a variable with its complement in a ZDD.  <a href="#af1e29f906fd682376f4b15676c840fe2">More...</a><br /></td></tr>
<tr class="separator:af1e29f906fd682376f4b15676c840fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b65104f2aa3b0e5719e73ac8c20f12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a7b65104f2aa3b0e5719e73ac8c20f12e">Cudd_zddSymmProfile</a> (<a class="el" href="structDdManager.html">DdManager</a> *table, int lower, int upper)</td></tr>
<tr class="memdesc:a7b65104f2aa3b0e5719e73ac8c20f12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistics on symmetric ZDD variables.  <a href="#a7b65104f2aa3b0e5719e73ac8c20f12e">More...</a><br /></td></tr>
<tr class="separator:a7b65104f2aa3b0e5719e73ac8c20f12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775341084fce61a34c46ecedd726075"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac775341084fce61a34c46ecedd726075">Cudd_zddPrintMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:ac775341084fce61a34c46ecedd726075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a disjoint sum of product form for a ZDD.  <a href="#ac775341084fce61a34c46ecedd726075">More...</a><br /></td></tr>
<tr class="separator:ac775341084fce61a34c46ecedd726075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bcb316ffbbb024faeda00c8aea85bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ad9bcb316ffbbb024faeda00c8aea85bf">Cudd_zddPrintCover</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:ad9bcb316ffbbb024faeda00c8aea85bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a sum of products from a ZDD representing a cover.  <a href="#ad9bcb316ffbbb024faeda00c8aea85bf">More...</a><br /></td></tr>
<tr class="separator:ad9bcb316ffbbb024faeda00c8aea85bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79817362adfa41e6086266203743a5b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a79817362adfa41e6086266203743a5b8">Cudd_zddPrintDebug</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *f, int n, int pr)</td></tr>
<tr class="memdesc:a79817362adfa41e6086266203743a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to the standard output a ZDD and its statistics.  <a href="#a79817362adfa41e6086266203743a5b8">More...</a><br /></td></tr>
<tr class="separator:a79817362adfa41e6086266203743a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a6e2d60cca93f876d66e9bda6bb6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a191a6e2d60cca93f876d66e9bda6bb6b">Cudd_zddFirstPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, <a class="el" href="structDdNode.html">DdNode</a> *f, int **path)</td></tr>
<tr class="memdesc:a191a6e2d60cca93f876d66e9bda6bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first path of a ZDD.  <a href="#a191a6e2d60cca93f876d66e9bda6bb6b">More...</a><br /></td></tr>
<tr class="separator:a191a6e2d60cca93f876d66e9bda6bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c3a1a1e5ce89ac7a24749c1568937"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aed8c3a1a1e5ce89ac7a24749c1568937">Cudd_zddNextPath</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, int **path)</td></tr>
<tr class="memdesc:aed8c3a1a1e5ce89ac7a24749c1568937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next path of a ZDD.  <a href="#aed8c3a1a1e5ce89ac7a24749c1568937">More...</a><br /></td></tr>
<tr class="separator:aed8c3a1a1e5ce89ac7a24749c1568937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e197e31a92ab28d9fc7fcfb75b52e96"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a3e197e31a92ab28d9fc7fcfb75b52e96">Cudd_zddCoverPathToString</a> (<a class="el" href="structDdManager.html">DdManager</a> *zdd, int *path, char *str)</td></tr>
<tr class="memdesc:a3e197e31a92ab28d9fc7fcfb75b52e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a path of a ZDD representing a cover to a string.  <a href="#a3e197e31a92ab28d9fc7fcfb75b52e96">More...</a><br /></td></tr>
<tr class="separator:a3e197e31a92ab28d9fc7fcfb75b52e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e14381ae82e3938e6323517cf5f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a402e14381ae82e3938e6323517cf5f27">Cudd_zddSupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a402e14381ae82e3938e6323517cf5f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a ZDD depends.  <a href="#a402e14381ae82e3938e6323517cf5f27">More...</a><br /></td></tr>
<tr class="separator:a402e14381ae82e3938e6323517cf5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88773e8e965dfbfc98eb3f4e35d7f905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a88773e8e965dfbfc98eb3f4e35d7f905">Cudd_zddDumpDot</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int n, <a class="el" href="structDdNode.html">DdNode</a> **f, char const *const *inames, char const *const *<a class="el" href="ntr_8c.html#abfd0966318aec629b0ac35d34539f398">onames</a>, FILE *fp)</td></tr>
<tr class="memdesc:a88773e8e965dfbfc98eb3f4e35d7f905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a dot file representing the argument ZDDs.  <a href="#a88773e8e965dfbfc98eb3f4e35d7f905">More...</a><br /></td></tr>
<tr class="separator:a88773e8e965dfbfc98eb3f4e35d7f905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6849dc17bbba2043922cb0efcd21ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#aac6849dc17bbba2043922cb0efcd21ec">Cudd_bddSetPiVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:aac6849dc17bbba2043922cb0efcd21ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to primary input.  <a href="#aac6849dc17bbba2043922cb0efcd21ec">More...</a><br /></td></tr>
<tr class="separator:aac6849dc17bbba2043922cb0efcd21ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8deaa5bc364ba47901043ea405b6909"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac8deaa5bc364ba47901043ea405b6909">Cudd_bddSetPsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:ac8deaa5bc364ba47901043ea405b6909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to present state.  <a href="#ac8deaa5bc364ba47901043ea405b6909">More...</a><br /></td></tr>
<tr class="separator:ac8deaa5bc364ba47901043ea405b6909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9259947e31d7d43fee7209e08e0257f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a9259947e31d7d43fee7209e08e0257f0">Cudd_bddSetNsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a9259947e31d7d43fee7209e08e0257f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable type to next state.  <a href="#a9259947e31d7d43fee7209e08e0257f0">More...</a><br /></td></tr>
<tr class="separator:a9259947e31d7d43fee7209e08e0257f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8807a8333099dbd0d32cccf9da8841b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8807a8333099dbd0d32cccf9da8841b2">Cudd_bddIsPiVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a8807a8333099dbd0d32cccf9da8841b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is primary input.  <a href="#a8807a8333099dbd0d32cccf9da8841b2">More...</a><br /></td></tr>
<tr class="separator:a8807a8333099dbd0d32cccf9da8841b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390b021da58cb55e9c912f4490a5845e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a390b021da58cb55e9c912f4490a5845e">Cudd_bddIsPsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a390b021da58cb55e9c912f4490a5845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is present state.  <a href="#a390b021da58cb55e9c912f4490a5845e">More...</a><br /></td></tr>
<tr class="separator:a390b021da58cb55e9c912f4490a5845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4fca0bea12745bf32f153a72dc269f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a5f4fca0bea12745bf32f153a72dc269f">Cudd_bddIsNsVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a5f4fca0bea12745bf32f153a72dc269f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is next state.  <a href="#a5f4fca0bea12745bf32f153a72dc269f">More...</a><br /></td></tr>
<tr class="separator:a5f4fca0bea12745bf32f153a72dc269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11beec034c2fc7842ca370aaeed9b21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac11beec034c2fc7842ca370aaeed9b21">Cudd_bddSetPairIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index, int pairIndex)</td></tr>
<tr class="memdesc:ac11beec034c2fc7842ca370aaeed9b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a corresponding pair index for a given index.  <a href="#ac11beec034c2fc7842ca370aaeed9b21">More...</a><br /></td></tr>
<tr class="separator:ac11beec034c2fc7842ca370aaeed9b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b76a558f6dafd89648f9f7c470b68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a642b76a558f6dafd89648f9f7c470b68">Cudd_bddReadPairIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a642b76a558f6dafd89648f9f7c470b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a corresponding pair index for a given index.  <a href="#a642b76a558f6dafd89648f9f7c470b68">More...</a><br /></td></tr>
<tr class="separator:a642b76a558f6dafd89648f9f7c470b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776ff1149be00414f9dfb9d8e5236b6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a776ff1149be00414f9dfb9d8e5236b6a">Cudd_bddSetVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a776ff1149be00414f9dfb9d8e5236b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be grouped.  <a href="#a776ff1149be00414f9dfb9d8e5236b6a">More...</a><br /></td></tr>
<tr class="separator:a776ff1149be00414f9dfb9d8e5236b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3008fcc7c507d061c10a343a6c01ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a2f3008fcc7c507d061c10a343a6c01ce">Cudd_bddSetVarHardGroup</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a2f3008fcc7c507d061c10a343a6c01ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be a hard group.  <a href="#a2f3008fcc7c507d061c10a343a6c01ce">More...</a><br /></td></tr>
<tr class="separator:a2f3008fcc7c507d061c10a343a6c01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8613c4063493aebe3dc9e0e14562114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#ac8613c4063493aebe3dc9e0e14562114">Cudd_bddResetVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:ac8613c4063493aebe3dc9e0e14562114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a variable not to be grouped.  <a href="#ac8613c4063493aebe3dc9e0e14562114">More...</a><br /></td></tr>
<tr class="separator:ac8613c4063493aebe3dc9e0e14562114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ea07041f3e4f560bc936404461b2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a956ea07041f3e4f560bc936404461b2a">Cudd_bddIsVarToBeGrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a956ea07041f3e4f560bc936404461b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be grouped.  <a href="#a956ea07041f3e4f560bc936404461b2a">More...</a><br /></td></tr>
<tr class="separator:a956ea07041f3e4f560bc936404461b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd0386d3adadf96af5a95939586dc7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#acdd0386d3adadf96af5a95939586dc7b">Cudd_bddSetVarToBeUngrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:acdd0386d3adadf96af5a95939586dc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a variable to be ungrouped.  <a href="#acdd0386d3adadf96af5a95939586dc7b">More...</a><br /></td></tr>
<tr class="separator:acdd0386d3adadf96af5a95939586dc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a8e0ef3b582414eb1907ad98fb4cc16e9">Cudd_bddIsVarToBeUngrouped</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be ungrouped.  <a href="#a8e0ef3b582414eb1907ad98fb4cc16e9">More...</a><br /></td></tr>
<tr class="separator:a8e0ef3b582414eb1907ad98fb4cc16e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eda0885ab454e4e518639208e0c920"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cudd_8h.html#a14eda0885ab454e4e518639208e0c920">Cudd_bddIsVarHardGroup</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int index)</td></tr>
<tr class="memdesc:a14eda0885ab454e4e518639208e0c920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a variable is set to be in a hard group.  <a href="#a14eda0885ab454e4e518639208e0c920">More...</a><br /></td></tr>
<tr class="separator:a14eda0885ab454e4e518639208e0c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The University of Colorado decision diagram package. </p>
<p>External functions and data strucures of the CUDD package. </p><ul>
<li>
To turn on the gathering of statistics, define DD_STATS. </li>
<li>
To turn on additional debugging code, define DD_DEBUG. </li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Fabio Somenzi </dd>
<dd>
Modified by Abelardo Pardo to interface it to VIS</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae43ddb042121362b558a2ff66dd829ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43ddb042121362b558a2ff66dd829ed">&#9670;&nbsp;</a></span>CUDD_CACHE_SLOTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CUDD_CACHE_SLOTS&#160;&#160;&#160;262144</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default size of the cache </p>

</div>
</div>
<a id="ac4575f4314998362765264f64eccfe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4575f4314998362765264f64eccfe0c">&#9670;&nbsp;</a></span>Cudd_Complement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_Complement</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) | (uintptr_t) 01))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the complemented version of a pointer. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#afbbecf4f6f78f92518f4d0a477d870b6" title="Returns the regular version of a pointer.">Cudd_Regular</a> <a class="el" href="cudd_8h.html#a35322518c24f65f44eda9623083cb62c" title="Returns 1 if a pointer is complemented.">Cudd_IsComplement</a> </dd></dl>

</div>
</div>
<a id="ab114f6415a719b17d825ad1ca5ba4119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab114f6415a719b17d825ad1ca5ba4119">&#9670;&nbsp;</a></span>CUDD_FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CUDD_FALSE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>readable false </p>

</div>
</div>
<a id="af13069593b0d4de4d16493b956de38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13069593b0d4de4d16493b956de38a6">&#9670;&nbsp;</a></span>Cudd_ForeachCube</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_ForeachCube</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">manager, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">gen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cube, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>((gen) = <a class="code" href="cudd_8h.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4">Cudd_FirstCube</a>(manager, f, &amp;cube, &amp;value);\</div><div class="line">    Cudd_IsGenEmpty(gen) ? <a class="code" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a>(gen) : <a class="code" href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a>;\</div><div class="line">    (void) <a class="code" href="cudd_8h.html#a05f1698806d45eaba7f4a5721dd5c3c8">Cudd_NextCube</a>(gen, &amp;cube, &amp;value))</div><div class="ttc" id="cudd_8h_html_af397eb0f37256c48b181c5f02e5cb128"><div class="ttname"><a href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a></div><div class="ttdeci">#define CUDD_TRUE</div><div class="ttdef"><b>Definition:</b> cudd.h:66</div></div>
<div class="ttc" id="cudd_8h_html_a05f1698806d45eaba7f4a5721dd5c3c8"><div class="ttname"><a href="cudd_8h.html#a05f1698806d45eaba7f4a5721dd5c3c8">Cudd_NextCube</a></div><div class="ttdeci">int Cudd_NextCube(DdGen *gen, int **cube, CUDD_VALUE_TYPE *value)</div><div class="ttdoc">Generates the next cube of a decision diagram onset.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:1996</div></div>
<div class="ttc" id="cudd_8h_html_aa16a8509f9959aff3a0c553a0427e656"><div class="ttname"><a href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a></div><div class="ttdeci">int Cudd_GenFree(DdGen *gen)</div><div class="ttdoc">Frees a CUDD generator.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2563</div></div>
<div class="ttc" id="cudd_8h_html_a139d8dd64955ecf3e2fd4c5d6ceeebb4"><div class="ttname"><a href="cudd_8h.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4">Cudd_FirstCube</a></div><div class="ttdeci">DdGen * Cudd_FirstCube(DdManager *dd, DdNode *f, int **cube, CUDD_VALUE_TYPE *value)</div><div class="ttdoc">Finds the first cube of a decision diagram.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:1881</div></div>
</div><!-- fragment -->
<p>Iterates over the cubes of a decision diagram. </p>
<p>Iterates over the cubes of a decision diagram f. </p><ul>
<li>
<a class="el" href="structDdManager.html" title="Specialized DD symbol table.">DdManager</a> *manager; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *f; </li>
<li>
<a class="el" href="structDdGen.html" title="CUDD generator.">DdGen</a> *gen; </li>
<li>
int *cube; </li>
<li>
CUDD_VALUE_TYPE value; </li>
</ul>
<p>Cudd_ForeachCube allocates and frees the generator. Therefore the application should not try to do that. Also, the cube is freed at the end of Cudd_ForeachCube and hence is not available outside of the loop.</p>
<p>CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cudd_8h.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cudd_8h.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cudd_8h.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cudd_8h.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> </dd></dl>

</div>
</div>
<a id="aeeb7e015a5d710dc3086b194193549f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb7e015a5d710dc3086b194193549f2">&#9670;&nbsp;</a></span>Cudd_ForeachNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_ForeachNode</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">manager, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">gen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>((gen) = <a class="code" href="cudd_8h.html#a0cbbad0f18b5767a4924ff6b069bbc7f">Cudd_FirstNode</a>(manager, f, &amp;node);\</div><div class="line">    Cudd_IsGenEmpty(gen) ? <a class="code" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a>(gen) : <a class="code" href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a>;\</div><div class="line">    (void) <a class="code" href="cudd_8h.html#a627f04ddcd448e741233d5bc16562171">Cudd_NextNode</a>(gen, &amp;node))</div><div class="ttc" id="cudd_8h_html_a0cbbad0f18b5767a4924ff6b069bbc7f"><div class="ttname"><a href="cudd_8h.html#a0cbbad0f18b5767a4924ff6b069bbc7f">Cudd_FirstNode</a></div><div class="ttdeci">DdGen * Cudd_FirstNode(DdManager *dd, DdNode *f, DdNode **node)</div><div class="ttdoc">Finds the first node of a decision diagram.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2476</div></div>
<div class="ttc" id="cudd_8h_html_a627f04ddcd448e741233d5bc16562171"><div class="ttname"><a href="cudd_8h.html#a627f04ddcd448e741233d5bc16562171">Cudd_NextNode</a></div><div class="ttdeci">int Cudd_NextNode(DdGen *gen, DdNode **node)</div><div class="ttdoc">Finds the next node of a decision diagram.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2533</div></div>
<div class="ttc" id="cudd_8h_html_af397eb0f37256c48b181c5f02e5cb128"><div class="ttname"><a href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a></div><div class="ttdeci">#define CUDD_TRUE</div><div class="ttdef"><b>Definition:</b> cudd.h:66</div></div>
<div class="ttc" id="cudd_8h_html_aa16a8509f9959aff3a0c553a0427e656"><div class="ttname"><a href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a></div><div class="ttdeci">int Cudd_GenFree(DdGen *gen)</div><div class="ttdoc">Frees a CUDD generator.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2563</div></div>
</div><!-- fragment -->
<p>Iterates over the nodes of a decision diagram. </p>
<p>Iterates over the nodes of a decision diagram f. </p><ul>
<li>
<a class="el" href="structDdManager.html" title="Specialized DD symbol table.">DdManager</a> *manager; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *f; </li>
<li>
<a class="el" href="structDdGen.html" title="CUDD generator.">DdGen</a> *gen; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *node; </li>
</ul>
<p>The nodes are returned in a seemingly random order. Cudd_ForeachNode allocates and frees the generator. Therefore the application should not try to do that.</p>
<p>CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cudd_8h.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cudd_8h.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cudd_8h.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> </dd></dl>

</div>
</div>
<a id="a6b1ce1bc5df95326f9eabcfeca1e7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1ce1bc5df95326f9eabcfeca1e7ded">&#9670;&nbsp;</a></span>Cudd_ForeachPrime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_ForeachPrime</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">manager, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">gen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cube&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>((gen) = <a class="code" href="cudd_8h.html#a65691b560210512cf1f8d92f0c1ece9a">Cudd_FirstPrime</a>(manager, l, u, &amp;cube);\</div><div class="line">    Cudd_IsGenEmpty(gen) ? <a class="code" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a>(gen) : <a class="code" href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a>;\</div><div class="line">    (void) <a class="code" href="cudd_8h.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73">Cudd_NextPrime</a>(gen, &amp;cube))</div><div class="ttc" id="cudd_8h_html_ae9c8ccb352d96ca9bde4ab97a1ee8e73"><div class="ttname"><a href="cudd_8h.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73">Cudd_NextPrime</a></div><div class="ttdeci">int Cudd_NextPrime(DdGen *gen, int **cube)</div><div class="ttdoc">Generates the next prime of a Boolean function.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2206</div></div>
<div class="ttc" id="cudd_8h_html_af397eb0f37256c48b181c5f02e5cb128"><div class="ttname"><a href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a></div><div class="ttdeci">#define CUDD_TRUE</div><div class="ttdef"><b>Definition:</b> cudd.h:66</div></div>
<div class="ttc" id="cudd_8h_html_a65691b560210512cf1f8d92f0c1ece9a"><div class="ttname"><a href="cudd_8h.html#a65691b560210512cf1f8d92f0c1ece9a">Cudd_FirstPrime</a></div><div class="ttdeci">DdGen * Cudd_FirstPrime(DdManager *dd, DdNode *l, DdNode *u, int **cube)</div><div class="ttdoc">Finds the first prime of a Boolean function.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2107</div></div>
<div class="ttc" id="cudd_8h_html_aa16a8509f9959aff3a0c553a0427e656"><div class="ttname"><a href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a></div><div class="ttdeci">int Cudd_GenFree(DdGen *gen)</div><div class="ttdoc">Frees a CUDD generator.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2563</div></div>
</div><!-- fragment -->
<p>Iterates over the primes of a Boolean function. </p>
<p>Iterates over the primes of a Boolean function producing a prime, but not necessarily irredundant, cover. </p><ul>
<li>
<a class="el" href="structDdManager.html" title="Specialized DD symbol table.">DdManager</a> *manager; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *l; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *u; </li>
<li>
<a class="el" href="structDdGen.html" title="CUDD generator.">DdGen</a> *gen; </li>
<li>
int *cube; </li>
</ul>
<p>The Boolean function is described by an upper bound and a lower bound. If the function is completely specified, the two bounds coincide. Cudd_ForeachPrime allocates and frees the generator. Therefore the application should not try to do that. Also, the cube is freed at the end of Cudd_ForeachPrime and hence is not available outside of the loop.</p>
<p>CAUTION: It is a mistake to change a diagram on which generation is ongoing.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#a65691b560210512cf1f8d92f0c1ece9a" title="Finds the first prime of a Boolean function.">Cudd_FirstPrime</a> <a class="el" href="cudd_8h.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73" title="Generates the next prime of a Boolean function.">Cudd_NextPrime</a> <a class="el" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cudd_8h.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> </dd></dl>

</div>
</div>
<a id="a35322518c24f65f44eda9623083cb62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35322518c24f65f44eda9623083cb62c">&#9670;&nbsp;</a></span>Cudd_IsComplement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_IsComplement</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node</td><td>)</td>
          <td>&#160;&#160;&#160;((int) ((uintptr_t) (node) &amp; (uintptr_t) 01))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if a pointer is complemented. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#afbbecf4f6f78f92518f4d0a477d870b6" title="Returns the regular version of a pointer.">Cudd_Regular</a> <a class="el" href="cudd_8h.html#ac4575f4314998362765264f64eccfe0c" title="Returns the complemented version of a pointer.">Cudd_Complement</a> </dd></dl>

</div>
</div>
<a id="a352ef8d39e760eaabae6d58d9a5ddbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352ef8d39e760eaabae6d58d9a5ddbfc">&#9670;&nbsp;</a></span>Cudd_Not</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_Not</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) ^ (uintptr_t) 01))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complements a DD. </p>
<p>Complements a DD by flipping the complement attribute of the pointer (the least significant bit).</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#ae870da95e89a703e939161fe08b899f9" title="Complements a DD if a condition is true.">Cudd_NotCond</a> </dd></dl>

</div>
</div>
<a id="ae870da95e89a703e939161fe08b899f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae870da95e89a703e939161fe08b899f9">&#9670;&nbsp;</a></span>Cudd_NotCond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_NotCond</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) ^ (uintptr_t) (c)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complements a DD if a condition is true. </p>
<p>Complements a DD if condition c is true; c should be either 0 or 1, because it is used directly (for efficiency). If in doubt on the values c may take, use "(c) ? Cudd_Not(node) : node".</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a352ef8d39e760eaabae6d58d9a5ddbfc" title="Complements a DD.">Cudd_Not</a> </dd></dl>

</div>
</div>
<a id="a2c0122cc772ed6f3012bcac42fac0c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0122cc772ed6f3012bcac42fac0c0c">&#9670;&nbsp;</a></span>Cudd_ReadIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_ReadIndex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976">Cudd_ReadPerm</a>(dd,index))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current position in the order of variable index. </p>
<p>Returns the current position in the order of variable index. This macro is obsolete and is kept for compatibility. New applications should use Cudd_ReadPerm instead.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> </dd></dl>

</div>
</div>
<a id="afbbecf4f6f78f92518f4d0a477d870b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbecf4f6f78f92518f4d0a477d870b6">&#9670;&nbsp;</a></span>Cudd_Regular</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_Regular</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="structDdNode.html">DdNode</a> *)((uintptr_t)(node) &amp; ~(uintptr_t) 01))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the regular version of a pointer. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#ac4575f4314998362765264f64eccfe0c" title="Returns the complemented version of a pointer.">Cudd_Complement</a> <a class="el" href="cudd_8h.html#a35322518c24f65f44eda9623083cb62c" title="Returns 1 if a pointer is complemented.">Cudd_IsComplement</a> </dd></dl>

</div>
</div>
<a id="af397eb0f37256c48b181c5f02e5cb128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397eb0f37256c48b181c5f02e5cb128">&#9670;&nbsp;</a></span>CUDD_TRUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CUDD_TRUE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>readable true </p>

</div>
</div>
<a id="a5898eb92cde4c11e117bb88330b50019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5898eb92cde4c11e117bb88330b50019">&#9670;&nbsp;</a></span>CUDD_UNIQUE_SLOTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CUDD_UNIQUE_SLOTS&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initial size of subtables </p>

</div>
</div>
<a id="a7afa2381aa1f60094b325b10c0a5baa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afa2381aa1f60094b325b10c0a5baa1">&#9670;&nbsp;</a></span>Cudd_zddForeachPath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Cudd_zddForeachPath</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">manager, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">gen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">path&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>((gen) = <a class="code" href="cudd_8h.html#a191a6e2d60cca93f876d66e9bda6bb6b">Cudd_zddFirstPath</a>(manager, f, &amp;path);\</div><div class="line">    Cudd_IsGenEmpty(gen) ? <a class="code" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a>(gen) : <a class="code" href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a>;\</div><div class="line">    (void) <a class="code" href="cudd_8h.html#aed8c3a1a1e5ce89ac7a24749c1568937">Cudd_zddNextPath</a>(gen, &amp;path))</div><div class="ttc" id="cudd_8h_html_af397eb0f37256c48b181c5f02e5cb128"><div class="ttname"><a href="cudd_8h.html#af397eb0f37256c48b181c5f02e5cb128">CUDD_TRUE</a></div><div class="ttdeci">#define CUDD_TRUE</div><div class="ttdef"><b>Definition:</b> cudd.h:66</div></div>
<div class="ttc" id="cudd_8h_html_aed8c3a1a1e5ce89ac7a24749c1568937"><div class="ttname"><a href="cudd_8h.html#aed8c3a1a1e5ce89ac7a24749c1568937">Cudd_zddNextPath</a></div><div class="ttdeci">int Cudd_zddNextPath(DdGen *gen, int **path)</div><div class="ttdoc">Generates the next path of a ZDD.</div><div class="ttdef"><b>Definition:</b> cuddZddUtil.c:350</div></div>
<div class="ttc" id="cudd_8h_html_a191a6e2d60cca93f876d66e9bda6bb6b"><div class="ttname"><a href="cudd_8h.html#a191a6e2d60cca93f876d66e9bda6bb6b">Cudd_zddFirstPath</a></div><div class="ttdeci">DdGen * Cudd_zddFirstPath(DdManager *zdd, DdNode *f, int **path)</div><div class="ttdoc">Finds the first path of a ZDD.</div><div class="ttdef"><b>Definition:</b> cuddZddUtil.c:238</div></div>
<div class="ttc" id="cudd_8h_html_aa16a8509f9959aff3a0c553a0427e656"><div class="ttname"><a href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a></div><div class="ttdeci">int Cudd_GenFree(DdGen *gen)</div><div class="ttdoc">Frees a CUDD generator.</div><div class="ttdef"><b>Definition:</b> cuddUtil.c:2563</div></div>
</div><!-- fragment -->
<p>Iterates over the paths of a ZDD. </p>
<p>Iterates over the paths of a ZDD f. </p><ul>
<li>
<a class="el" href="structDdManager.html" title="Specialized DD symbol table.">DdManager</a> *manager; </li>
<li>
<a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *f; </li>
<li>
<a class="el" href="structDdGen.html" title="CUDD generator.">DdGen</a> *gen; </li>
<li>
int *path; </li>
</ul>
<p>Cudd_zddForeachPath allocates and frees the generator. Therefore the application should not try to do that. Also, the path is freed at the end of Cudd_zddForeachPath and hence is not available outside of the loop.</p>
<p>CAUTION: It is assumed that dynamic reordering will not occur while there are open generators. It is the user's responsibility to make sure that dynamic reordering does not occur. As long as new nodes are not created during generation, and dynamic reordering is not called explicitly, dynamic reordering will not occur. Alternatively, it is sufficient to disable dynamic reordering. It is a mistake to dispose of a diagram on which generation is ongoing.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a191a6e2d60cca93f876d66e9bda6bb6b" title="Finds the first path of a ZDD.">Cudd_zddFirstPath</a> <a class="el" href="cudd_8h.html#aed8c3a1a1e5ce89ac7a24749c1568937" title="Generates the next path of a ZDD.">Cudd_zddNextPath</a> <a class="el" href="cudd_8h.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cudd_8h.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cudd_8h.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae6d55585c0a16ded7753ebc19d765659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d55585c0a16ded7753ebc19d765659">&#9670;&nbsp;</a></span>Cudd_VariableType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cudd_8h.html#ae6d55585c0a16ded7753ebc19d765659">Cudd_VariableType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable type. </p>
<p>Used only in lazy sifting. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a09e9945c51e576ce46ef1b2dbd0a470a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e9945c51e576ce46ef1b2dbd0a470a">&#9670;&nbsp;</a></span>Cudd_addAgreement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addAgreement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>f if f==g; background if f!=g. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f op g otherwise, where f op g is f if f==g; background if f!=g.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="ae8300acf801bcde789878fccb3635d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8300acf801bcde789878fccb3635d5f">&#9670;&nbsp;</a></span>Cudd_addApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a2aa941e1d7fbaa50cae391a6dfd229b8">DD_AOP</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies op to the corresponding discriminants of f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if succssful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#a9c66863e6440ae56326f3383837d9966" title="Applies op to the discriminants of f.">Cudd_addMonadicApply</a> <a class="el" href="cuddAddApply_8c.html#ab378c5151c55c439cd5579d871f554ce" title="Integer and floating point addition.">Cudd_addPlus</a> <a class="el" href="cuddAddApply_8c.html#ab69854ec8f0a7ff4535c07cad3522de4" title="Integer and floating point multiplication.">Cudd_addTimes</a> <a class="el" href="cuddAddApply_8c.html#a8e98e508843c4aa0ad42311d5ab525d7" title="f if fg; 0 if f&lt;g.">Cudd_addThreshold</a> <a class="el" href="cuddAddApply_8c.html#a17119bcb91dba087618b08e7595ecb66" title="This operator sets f to the value of g wherever g != 0.">Cudd_addSetNZ</a> <a class="el" href="cuddAddApply_8c.html#a0a04a3a242f175d4db3e4444f7e9e8b8" title="Integer and floating point division.">Cudd_addDivide</a> <a class="el" href="cuddAddApply_8c.html#a1d3b49e50384beae41a27c5cf7f31faf" title="Integer and floating point subtraction.">Cudd_addMinus</a> <a class="el" href="cuddAddApply_8c.html#a432fc72cd4668cc0d6a6ce7ca1d1e7f3" title="Integer and floating point min.">Cudd_addMinimum</a> <a class="el" href="cuddAddApply_8c.html#a6be922ac5d59b292f527993509fda58f" title="Integer and floating point max.">Cudd_addMaximum</a> <a class="el" href="cuddAddApply_8c.html#a4954870e0caa4a99e915c40a9c3ff792" title="Returns 1 if f &gt; g and 0 otherwise.">Cudd_addOneZeroMaximum</a> <a class="el" href="cuddAddApply_8c.html#ac214dc5cef566e46a3699bae9f19ba47" title="Returns plusinfinity if f=g; returns min(f,g) if f!=g.">Cudd_addDiff</a> <a class="el" href="cuddAddApply_8c.html#a09e9945c51e576ce46ef1b2dbd0a470a" title="f if f==g; background if f!=g.">Cudd_addAgreement</a> <a class="el" href="cuddAddApply_8c.html#a924a761e68f7e19fa2a840bdbb84e898" title="Disjunction of two 0-1 ADDs.">Cudd_addOr</a> <a class="el" href="cuddAddApply_8c.html#a6cfa979af17da5b8c71fe71d44422beb" title="NAND of two 0-1 ADDs.">Cudd_addNand</a> <a class="el" href="cuddAddApply_8c.html#a9307c6070c4c7ec72a0427b96b4a8cb2" title="NOR of two 0-1 ADDs.">Cudd_addNor</a> <a class="el" href="cuddAddApply_8c.html#af0d32f9713422bd9fdbe073406b9c631" title="XOR of two 0-1 ADDs.">Cudd_addXor</a> <a class="el" href="cuddAddApply_8c.html#a9e0b42ff91ece2d4abef597a964ad0e9" title="XNOR of two 0-1 ADDs.">Cudd_addXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">op</td><td>operator </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfa95504dec573eada577783098b26b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa95504dec573eada577783098b26b6">&#9670;&nbsp;</a></span>Cudd_addBddInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addBddInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ADD to a BDD. </p>
<p>Replaces all discriminants greater than or equal to lower and less than or equal to upper with 1, and all other discriminants with 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#adf94a0491ea6d3464e488b667a0b42bd" title="Converts an ADD to a BDD.">Cudd_addBddThreshold</a> <a class="el" href="cuddBridge_8c.html#a17a7d31fbafb86bd3b335b2a5523444c" title="Converts an ADD to a BDD.">Cudd_addBddStrictThreshold</a> <a class="el" href="cuddBridge_8c.html#a6a80d92ddf13c5d54e61974f1855c22b" title="Converts an ADD to a BDD.">Cudd_addBddPattern</a> <a class="el" href="cuddBridge_8c.html#a2a0f570e1bbe987fdecc4786ac808e08" title="Converts a BDD to a 0-1 ADD.">Cudd_BddToAdd</a> </dd></dl>

</div>
</div>
<a id="aa8255c2649b61e0f28521792eea4065f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8255c2649b61e0f28521792eea4065f">&#9670;&nbsp;</a></span>Cudd_addBddIthBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addBddIthBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ADD to a BDD by extracting the i-th bit from the leaves. </p>
<p>Converts an ADD to a BDD by replacing all discriminants whose i-th bit is equal to 1 with 1, and all other discriminants with 0. The i-th bit refers to the integer representation of the leaf value. If the value has a fractional part, it is ignored. Repeated calls to this procedure allow one to transform an integer-valued ADD into an array of BDDs, one for each bit of the leaf values.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#adfa95504dec573eada577783098b26b6" title="Converts an ADD to a BDD.">Cudd_addBddInterval</a> <a class="el" href="cuddBridge_8c.html#a6a80d92ddf13c5d54e61974f1855c22b" title="Converts an ADD to a BDD.">Cudd_addBddPattern</a> <a class="el" href="cuddBridge_8c.html#a2a0f570e1bbe987fdecc4786ac808e08" title="Converts a BDD to a 0-1 ADD.">Cudd_BddToAdd</a> </dd></dl>

</div>
</div>
<a id="a6a80d92ddf13c5d54e61974f1855c22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a80d92ddf13c5d54e61974f1855c22b">&#9670;&nbsp;</a></span>Cudd_addBddPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addBddPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ADD to a BDD. </p>
<p>Replaces all discriminants different from 0 with 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#a2a0f570e1bbe987fdecc4786ac808e08" title="Converts a BDD to a 0-1 ADD.">Cudd_BddToAdd</a> <a class="el" href="cuddBridge_8c.html#adf94a0491ea6d3464e488b667a0b42bd" title="Converts an ADD to a BDD.">Cudd_addBddThreshold</a> <a class="el" href="cuddBridge_8c.html#adfa95504dec573eada577783098b26b6" title="Converts an ADD to a BDD.">Cudd_addBddInterval</a> <a class="el" href="cuddBridge_8c.html#a17a7d31fbafb86bd3b335b2a5523444c" title="Converts an ADD to a BDD.">Cudd_addBddStrictThreshold</a> </dd></dl>

</div>
</div>
<a id="a17a7d31fbafb86bd3b335b2a5523444c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a7d31fbafb86bd3b335b2a5523444c">&#9670;&nbsp;</a></span>Cudd_addBddStrictThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addBddStrictThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ADD to a BDD. </p>
<p>Replaces all discriminants STRICTLY greater than value with 1, and all other discriminants with 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#adfa95504dec573eada577783098b26b6" title="Converts an ADD to a BDD.">Cudd_addBddInterval</a> <a class="el" href="cuddBridge_8c.html#a6a80d92ddf13c5d54e61974f1855c22b" title="Converts an ADD to a BDD.">Cudd_addBddPattern</a> <a class="el" href="cuddBridge_8c.html#a2a0f570e1bbe987fdecc4786ac808e08" title="Converts a BDD to a 0-1 ADD.">Cudd_BddToAdd</a> <a class="el" href="cuddBridge_8c.html#adf94a0491ea6d3464e488b667a0b42bd" title="Converts an ADD to a BDD.">Cudd_addBddThreshold</a> </dd></dl>

</div>
</div>
<a id="adf94a0491ea6d3464e488b667a0b42bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf94a0491ea6d3464e488b667a0b42bd">&#9670;&nbsp;</a></span>Cudd_addBddThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addBddThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ADD to a BDD. </p>
<p>Replaces all discriminants greater than or equal to value with 1, and all other discriminants with 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#adfa95504dec573eada577783098b26b6" title="Converts an ADD to a BDD.">Cudd_addBddInterval</a> <a class="el" href="cuddBridge_8c.html#a6a80d92ddf13c5d54e61974f1855c22b" title="Converts an ADD to a BDD.">Cudd_addBddPattern</a> <a class="el" href="cuddBridge_8c.html#a2a0f570e1bbe987fdecc4786ac808e08" title="Converts a BDD to a 0-1 ADD.">Cudd_BddToAdd</a> <a class="el" href="cuddBridge_8c.html#a17a7d31fbafb86bd3b335b2a5523444c" title="Converts an ADD to a BDD.">Cudd_addBddStrictThreshold</a> </dd></dl>

</div>
</div>
<a id="a0776cc88f7f4911a8c7bede3f3aacdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0776cc88f7f4911a8c7bede3f3aacdfd">&#9670;&nbsp;</a></span>Cudd_addCmpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addCmpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the complement of an ADD a la C language. </p>
<p>The complement of 0 is 1 and the complement of everything else is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddNeg_8c.html#a5d9f8c929819d746e23fcb5ad51e175f" title="Computes the additive inverse of an ADD.">Cudd_addNegate</a> </dd></dl>

</div>
</div>
<a id="ad050bd964c7386f2a9eed09b8a1d25d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad050bd964c7386f2a9eed09b8a1d25d7">&#9670;&nbsp;</a></span>Cudd_addCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes g for x_v in the ADD for f. </p>
<p>v is the index of the variable to be substituted. g must be a 0-1 ADD. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="section return"><dt>Returns</dt><dd>the composed ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> </dd></dl>

</div>
</div>
<a id="a2e7d0901cba492671c25ee816510867c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7d0901cba492671c25ee816510867c">&#9670;&nbsp;</a></span>Cudd_addComputeCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addComputeCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cube of an array of ADD variables. </p>
<p>If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> </dd></dl>

</div>
</div>
<a id="a8b8fb347b6c5324ef9bce64aa73a63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8fb347b6c5324ef9bce64aa73a63bb">&#9670;&nbsp;</a></span>Cudd_addConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ADD for constant c. </p>
<p>Retrieves the ADD for constant c if it already exists, or creates a new ADD.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> </dd></dl>

</div>
</div>
<a id="a3bdc53bb832fb6b57528e7d5ceef7944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdc53bb832fb6b57528e7d5ceef7944">&#9670;&nbsp;</a></span>Cudd_addConstrain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addConstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes f constrain c for ADDs. </p>
<p>Computes f constrain c (f @ c), for f an ADD and c a 0-1 ADD. List of special cases: </p><ul>
<li>
F @ 0 = 0 </li>
<li>
F @ 1 = F </li>
<li>
0 @ c = 0 </li>
<li>
1 @ c = 1 </li>
<li>
F @ F = 1 </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> </dd></dl>

</div>
</div>
<a id="ac214dc5cef566e46a3699bae9f19ba47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac214dc5cef566e46a3699bae9f19ba47">&#9670;&nbsp;</a></span>Cudd_addDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns plusinfinity if f=g; returns min(f,g) if f!=g. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f op g otherwise, where f op g is plusinfinity if f=g; min(f,g) if f!=g.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a0a04a3a242f175d4db3e4444f7e9e8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a04a3a242f175d4db3e4444f7e9e8b8">&#9670;&nbsp;</a></span>Cudd_addDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point division. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f / g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a88cac595be91f0524a8be01c2b330661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cac595be91f0524a8be01c2b330661">&#9670;&nbsp;</a></span>Cudd_addEvalConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addEvalConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether ADD g is constant whenever ADD f is 1. </p>
<p>f must be a 0-1 ADD. If f is identically 0, the check is assumed to be successful, and the background value is returned. No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD (which may or may not be constant) or DD_NON_CONSTANT.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> <a class="el" href="cuddAddIte_8c.html#aef6faa7c3d70abff90b5187b2f505310" title="Determines whether f is less than or equal to g.">Cudd_addLeq</a> </dd></dl>

</div>
</div>
<a id="ac8603fe2007fd37712dd51ef0b78a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8603fe2007fd37712dd51ef0b78a5c7">&#9670;&nbsp;</a></span>Cudd_addExistAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addExistAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Existentially Abstracts all the variables in cube from f. </p>
<p>Abstracts all the variables in cube from f by summing over all possible values taken by the variables.</p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted ADD.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddAbs_8c.html#ae57290efa5451fcece67fc41046bd3a3" title="Universally Abstracts all the variables in cube from f.">Cudd_addUnivAbstract</a> <a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> <a class="el" href="cuddAddAbs_8c.html#a8c6fd0eef3dd314aedc861a30f4b71e7" title="Disjunctively abstracts all the variables in cube from the 0-1 ADD f.">Cudd_addOrAbstract</a> </dd></dl>

</div>
</div>
<a id="a8b8eb23dbb37eaa4d6bbd912b0b32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8eb23dbb37eaa4d6bbd912b0b32a8f">&#9670;&nbsp;</a></span>Cudd_addFindMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addFindMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum discriminant of f. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a constant ADD.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a598e352d575d7adb126c8b7958024bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598e352d575d7adb126c8b7958024bdd">&#9670;&nbsp;</a></span>Cudd_addFindMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addFindMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the minimum discriminant of f. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a constant ADD.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a0d52f7db30965ff17d5a8d5667162eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d52f7db30965ff17d5a8d5667162eb5">&#9670;&nbsp;</a></span>Cudd_addGeneralVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addGeneralVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of ADDs. </p>
<p>Given a vector of ADDs, creates a new ADD by substituting the ADDs for the variables of the ADD f. vectorOn contains ADDs to be substituted for the x_v and vectorOff the ADDs to be substituted for x_v'. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a1a2f14258e299c507e7e4b3dbbb9af3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2f14258e299c507e7e4b3dbbb9af3c">&#9670;&nbsp;</a></span>Cudd_addHamming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addHamming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>xVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>yVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Hamming distance ADD. </p>
<p>The two vectors xVars and yVars identify the variables that form the two arguments.</p>
<dl class="section return"><dt>Returns</dt><dd>an ADD that gives the Hamming distance between its two arguments if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a34a8110e2fedb3bf6674cbe9a83e6de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a8110e2fedb3bf6674cbe9a83e6de3">&#9670;&nbsp;</a></span>Cudd_addHarwell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_addHarwell </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>yn_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a matrix in the format of the Harwell-Boeing benchmark suite. </p>
<p>The variables are ordered as follows: </p><blockquote class="doxtable">
<p>x[0] y[0] x[1] y[1] ... </p>
</blockquote>
<p>0 is the most significant bit. On input, nx and ny hold the numbers of row and column variables already in existence.</p>
<dl class="section return"><dt>Returns</dt><dd>1 on success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n On output, nx and ny hold the numbers of row and column</dt><dd>variables actually used by the matrix. m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. The ADD for the sparse matrix is returned in E, and its reference count is &gt; 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRead_8c.html#a60fa1f494a6075b537e13b655c564e76" title="Reads in a sparse matrix.">Cudd_addRead</a> <a class="el" href="cuddRead_8c.html#aa3a5e49e217519cb4d29545aa0bbbb4d" title="Reads in a graph (without labels) given as a list of arcs.">Cudd_bddRead</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>pointer to the input file </td></tr>
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">E</td><td>characteristic function of the graph </td></tr>
    <tr><td class="paramname">x</td><td>array of row variables </td></tr>
    <tr><td class="paramname">y</td><td>array of column variables </td></tr>
    <tr><td class="paramname">xn</td><td>array of complemented row variables </td></tr>
    <tr><td class="paramname">yn_</td><td>array of complemented column variables </td></tr>
    <tr><td class="paramname">nx</td><td>number or row variables </td></tr>
    <tr><td class="paramname">ny</td><td>number or column variables </td></tr>
    <tr><td class="paramname">m</td><td>number of rows </td></tr>
    <tr><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramname">bx</td><td>first index of row variables </td></tr>
    <tr><td class="paramname">sx</td><td>step of row variables </td></tr>
    <tr><td class="paramname">by</td><td>first index of column variables </td></tr>
    <tr><td class="paramname">sy</td><td>step of column variables </td></tr>
    <tr><td class="paramname">pr</td><td>verbosity level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6884f064de544463f006f9104e4afa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6884f064de544463f006f9104e4afa74">&#9670;&nbsp;</a></span>Cudd_AddHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_AddHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the function is successfully added; 2 if the function was already in the list; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a0c732be4af510054662cd6e6f0a5772f" title="Removes a function from a hook.">Cudd_RemoveHook</a> </dd></dl>

</div>
</div>
<a id="a385a1fdc578cf9e41ff15ef50b6870df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385a1fdc578cf9e41ff15ef50b6870df">&#9670;&nbsp;</a></span>Cudd_addIte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addIte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements ITE(f,g,h). </p>
<p>This procedure assumes that f is a 0-1 ADD.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="ad1eae04162ef0a94b49121add887ee99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eae04162ef0a94b49121add887ee99">&#9670;&nbsp;</a></span>Cudd_addIteConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addIteConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements ITEconstant for ADDs. </p>
<p>f must be a 0-1 ADD. No new nodes are created. This function can be used, for instance, to check that g has a constant value (specified by h) whenever f is 1. If the constant value is unknown, then one should use Cudd_addEvalConst.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD (which may or may not be constant) or DD_NON_CONSTANT.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddIte_8c.html#a385a1fdc578cf9e41ff15ef50b6870df" title="Implements ITE(f,g,h).">Cudd_addIte</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>

</div>
</div>
<a id="a5c624ba988e4da35d5e576cda1532998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c624ba988e4da35d5e576cda1532998">&#9670;&nbsp;</a></span>Cudd_addIthBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addIthBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the i-th bit from an ADD. </p>
<p>Produces an ADD from another ADD by replacing all discriminants whose i-th bit is equal to 1 with 1, and all other discriminants with 0. The i-th bit refers to the integer representation of the leaf value. If the value has a fractional part, it is ignored. Repeated calls to this procedure allow one to transform an integer-valued ADD into an array of ADDs, one for each bit of the leaf values.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#aa8255c2649b61e0f28521792eea4065f" title="Converts an ADD to a BDD by extracting the i-th bit from the leaves.">Cudd_addBddIthBit</a> </dd></dl>

</div>
</div>
<a id="a19967d7c87650f63fc312f38c318e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19967d7c87650f63fc312f38c318e3e9">&#9670;&nbsp;</a></span>Cudd_addIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ADD variable with index i. </p>
<p>Retrieves the ADD variable with index i if it already exists, or creates a new ADD variable. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#a8b8fb347b6c5324ef9bce64aa73a63bb" title="Returns the ADD for constant c.">Cudd_addConst</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="aef6faa7c3d70abff90b5187b2f505310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6faa7c3d70abff90b5187b2f505310">&#9670;&nbsp;</a></span>Cudd_addLeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_addLeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether f is less than or equal to g. </p>
<p>No new nodes are created. This procedure works for arbitrary ADDs. For 0-1 ADDs Cudd_addEvalConst is more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if f is less than or equal to g; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> </dd></dl>

</div>
</div>
<a id="a229ddaff431bfaec7f7075e4a650540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ddaff431bfaec7f7075e4a650540f">&#9670;&nbsp;</a></span>Cudd_addLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Natural logarithm of an ADD. </p>
<p>The discriminants of f must be positive double's.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; log(f) otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#a9c66863e6440ae56326f3383837d9966" title="Applies op to the discriminants of f.">Cudd_addMonadicApply</a> </dd></dl>

</div>
</div>
<a id="a2a39a76a87a363ae2a4478b6181a580d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a39a76a87a363ae2a4478b6181a580d">&#9670;&nbsp;</a></span>Cudd_addMatrixMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addMatrixMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of two matrices represented as ADDs. </p>
<p>This procedure implements the quasiring multiplication algorithm. A is assumed to depend on variables x (rows) and z (columns). B is assumed to depend on variables z (rows) and y (columns). The product of A and B then depends on x (rows) and y (columns). Only the z variables have to be explicitly identified; they are the "summation" variables.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddMatMult_8c.html#a3ba6a6c9af4740842142de24bb1eb986" title="Calculates the product of two matrices represented as ADDs.">Cudd_addTimesPlus</a> <a class="el" href="cuddMatMult_8c.html#a98cb80a30ebe274373196765e3dd57a3" title="Performs the triangulation step for the shortest path computation.">Cudd_addTriangle</a> <a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> </dd></dl>

</div>
</div>
<a id="a6be922ac5d59b292f527993509fda58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be922ac5d59b292f527993509fda58f">&#9670;&nbsp;</a></span>Cudd_addMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addMaximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point max. </p>
<p>Integer and floating point max for Cudd_addApply.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; max(f,g) otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a432fc72cd4668cc0d6a6ce7ca1d1e7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432fc72cd4668cc0d6a6ce7ca1d1e7f3">&#9670;&nbsp;</a></span>Cudd_addMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addMinimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point min. </p>
<p>Integer and floating point min for Cudd_addApply.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; min(f,g) otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a1d3b49e50384beae41a27c5cf7f31faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3b49e50384beae41a27c5cf7f31faf">&#9670;&nbsp;</a></span>Cudd_addMinus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addMinus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point subtraction. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f - g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a9c66863e6440ae56326f3383837d9966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c66863e6440ae56326f3383837d9966">&#9670;&nbsp;</a></span>Cudd_addMonadicApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addMonadicApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8296f4822b35f456afd928f40ea7ff46">DD_MAOP</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies op to the discriminants of f. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if succssful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddAddApply_8c.html#a229ddaff431bfaec7f7075e4a650540f" title="Natural logarithm of an ADD.">Cudd_addLog</a> </dd></dl>

</div>
</div>
<a id="a6cfa979af17da5b8c71fe71d44422beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfa979af17da5b8c71fe71d44422beb">&#9670;&nbsp;</a></span>Cudd_addNand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NAND of two 0-1 ADDs. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f NAND g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a5d9f8c929819d746e23fcb5ad51e175f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9f8c929819d746e23fcb5ad51e175f">&#9670;&nbsp;</a></span>Cudd_addNegate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the additive inverse of an ADD. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddIte_8c.html#a0776cc88f7f4911a8c7bede3f3aacdfd" title="Computes the complement of an ADD a la C language.">Cudd_addCmpl</a> </dd></dl>

</div>
</div>
<a id="ad77f4dd2911bac8e25633fe84c6cfb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77f4dd2911bac8e25633fe84c6cfb8b">&#9670;&nbsp;</a></span>Cudd_addNewVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNewVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new ADD variable. </p>
<p>The new variable has an index equal to the largest previous index plus 1. An ADD variable differs from a BDD variable because it points to the arithmetic zero, instead of having a complement pointer to 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#a8b8fb347b6c5324ef9bce64aa73a63bb" title="Returns the ADD for constant c.">Cudd_addConst</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="aacea7b5ed8dc2595a1c0e01788bc205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacea7b5ed8dc2595a1c0e01788bc205a">&#9670;&nbsp;</a></span>Cudd_addNewVarAtLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNewVarAtLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new ADD variable at a specified level. </p>
<p>The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="a74339b069aaea8dbf1b321eaa773b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74339b069aaea8dbf1b321eaa773b59a">&#9670;&nbsp;</a></span>Cudd_addNonSimCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNonSimCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. This function implements non-simultaneous composition. If any of the functions being composed depends on any of the variables being substituted, then the result depends on the order of composition, which in turn depends on the variable order: The variables farther from the roots in the order are substituted first.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a id="a9307c6070c4c7ec72a0427b96b4a8cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9307c6070c4c7ec72a0427b96b4a8cb2">&#9670;&nbsp;</a></span>Cudd_addNor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NOR of two 0-1 ADDs. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f NOR g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a4954870e0caa4a99e915c40a9c3ff792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4954870e0caa4a99e915c40a9c3ff792">&#9670;&nbsp;</a></span>Cudd_addOneZeroMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addOneZeroMaximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if f &gt; g and 0 otherwise. </p>
<p>Used in conjunction with Cudd_addApply.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a924a761e68f7e19fa2a840bdbb84e898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a761e68f7e19fa2a840bdbb84e898">&#9670;&nbsp;</a></span>Cudd_addOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunction of two 0-1 ADDs. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f OR g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a8c6fd0eef3dd314aedc861a30f4b71e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6fd0eef3dd314aedc861a30f4b71e7">&#9670;&nbsp;</a></span>Cudd_addOrAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addOrAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunctively abstracts all the variables in cube from the 0-1 ADD f. </p>
<p>Abstracts all the variables in cube from the 0-1 ADD f by taking the disjunction over all possible values taken by the variables.</p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddAbs_8c.html#ae57290efa5451fcece67fc41046bd3a3" title="Universally Abstracts all the variables in cube from f.">Cudd_addUnivAbstract</a> <a class="el" href="cuddAddAbs_8c.html#ac8603fe2007fd37712dd51ef0b78a5c7" title="Existentially Abstracts all the variables in cube from f.">Cudd_addExistAbstract</a> </dd></dl>

</div>
</div>
<a id="aff2d12490bf8133f0893c9f587442ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2d12490bf8133f0893c9f587442ae2">&#9670;&nbsp;</a></span>Cudd_addOuterSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addOuterSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the minimum of a matrix and the outer sum of two vectors. </p>
<p>Takes the pointwise minimum of a matrix and the outer sum of two vectors. This procedure is used in the Floyd-Warshall all-pair shortest path algorithm.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a4926a513ab721d9bbc866740d40cbfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4926a513ab721d9bbc866740d40cbfcf">&#9670;&nbsp;</a></span>Cudd_addPermute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the variables of an ADD. </p>
<p>Given a permutation in array permut, creates a new ADD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a id="ab378c5151c55c439cd5579d871f554ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab378c5151c55c439cd5579d871f554ce">&#9670;&nbsp;</a></span>Cudd_addPlus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addPlus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point addition. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f+g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a60fa1f494a6075b537e13b655c564e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fa1f494a6075b537e13b655c564e76">&#9670;&nbsp;</a></span>Cudd_addRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_addRead </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>yn_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a sparse matrix. </p>
<p>Reads in a sparse matrix specified in a simple format. The first line of the input contains the numbers of rows and columns. The remaining lines contain the elements of the matrix, one per line. Given a background value (specified by the background field of the manager), only the values different from it are explicitly listed. Each foreground element is described by two integers, i.e., the row and column number, and a real number, i.e., the value.</p>
<p>Cudd_addRead produces an ADD that depends on two sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode the row index and the y variables (y[0] ... y[ny-1]) encode the column index. x[0] and y[0] are the most significant bits in the indices. The variables may already exist or may be created by the function. The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.</p>
<p>On input, nx and ny hold the numbers of row and column variables already in existence. On output, they hold the numbers of row and column variables actually used by the matrix. When Cudd_addRead creates the variable arrays, the index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy. When some variables already exist Cudd_addRead expects the indices of the existing x variables to be bx+i*sx, and the indices of the existing y variables to be by+i*sy.</p>
<p>m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. The ADD for the sparse matrix is returned in E, and its reference count is &gt; 0.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n nx and ny are set to the numbers of row and column</dt><dd>variables. m and n are set to the numbers of rows and columns. x and y are possibly extended to represent the array of row and column variables. Similarly for xn and yn_, which hold on return from Cudd_addRead the complements of the row and column variables.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddHarwell_8c.html#a34a8110e2fedb3bf6674cbe9a83e6de3" title="Reads in a matrix in the format of the Harwell-Boeing benchmark suite.">Cudd_addHarwell</a> <a class="el" href="cuddRead_8c.html#aa3a5e49e217519cb4d29545aa0bbbb4d" title="Reads in a graph (without labels) given as a list of arcs.">Cudd_bddRead</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>input file pointer </td></tr>
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">E</td><td>characteristic function of the graph </td></tr>
    <tr><td class="paramname">x</td><td>array of row variables </td></tr>
    <tr><td class="paramname">y</td><td>array of column variables </td></tr>
    <tr><td class="paramname">xn</td><td>array of complemented row variables </td></tr>
    <tr><td class="paramname">yn_</td><td>array of complemented column variables </td></tr>
    <tr><td class="paramname">nx</td><td>number or row variables </td></tr>
    <tr><td class="paramname">ny</td><td>number or column variables </td></tr>
    <tr><td class="paramname">m</td><td>number of rows </td></tr>
    <tr><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramname">bx</td><td>first index of row variables </td></tr>
    <tr><td class="paramname">sx</td><td>step of row variables </td></tr>
    <tr><td class="paramname">by</td><td>first index of column variables </td></tr>
    <tr><td class="paramname">sy</td><td>step of column variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5097993847962311dbbf670a6a3ca3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5097993847962311dbbf670a6a3ca3a5">&#9670;&nbsp;</a></span>Cudd_addResidue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addResidue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an ADD for the residue modulo m of an n-bit number. </p>
<p>The modulus must be at least 2, and the number of bits at least 1. Parameter options specifies whether the MSB should be on top or the LSB; and whther the number whose residue is computed is in two's complement notation or not. The macro CUDD_RESIDUE_DEFAULT specifies LSB on top and unsigned number. The macro CUDD_RESIDUE_MSB specifies MSB on top, and the macro CUDD_RESIDUE_TC specifies two's complement residue. To request MSB on top and two's complement residue simultaneously, one can OR the two macros: CUDD_RESIDUE_MSB | CUDD_RESIDUE_TC.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of bits </td></tr>
    <tr><td class="paramname">m</td><td>modulus </td></tr>
    <tr><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramname">top</td><td>index of top variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ab16f58da620eb1c2e927426aea22c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab16f58da620eb1c2e927426aea22c7">&#9670;&nbsp;</a></span>Cudd_addRestrict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addRestrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADD restrict according to Coudert and Madre's algorithm (ICCAD90). </p>
<p>If application of restrict results in an ADD larger than the input ADD, the input ADD is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the restricted ADD if successful; otherwise NULL.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944" title="Computes f constrain c for ADDs.">Cudd_addConstrain</a> <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a id="a072569b11bd6695a5b8536739be9611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072569b11bd6695a5b8536739be9611c">&#9670;&nbsp;</a></span>Cudd_addRoundOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addRoundOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds off the discriminants of an ADD. </p>
<p>The discriminants are rounded off to N digits after the decimal.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a0aadb4f60d820faf1a55ec4fe028dd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aadb4f60d820faf1a55ec4fe028dd5a">&#9670;&nbsp;</a></span>Cudd_addScalarInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addScalarInverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scalar inverse of an ADD. </p>
<p>Computes an n ADD where the discriminants are the multiplicative inverses of the corresponding discriminants of the argument ADD.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD in case of success. Returns NULL if any discriminants smaller than epsilon is encountered.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a17119bcb91dba087618b08e7595ecb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17119bcb91dba087618b08e7595ecb66">&#9670;&nbsp;</a></span>Cudd_addSetNZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addSetNZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator sets f to the value of g wherever g != 0. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f op g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a2ab066ce29ac83aa7d3891b96d4356e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab066ce29ac83aa7d3891b96d4356e1">&#9670;&nbsp;</a></span>Cudd_addSwapVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the ADD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a8e98e508843c4aa0ad42311d5ab525d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e98e508843c4aa0ad42311d5ab525d7">&#9670;&nbsp;</a></span>Cudd_addThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>f if f&ge;g; 0 if f&lt;g. </p>
<p>Threshold operator for Apply (f if f &ge;g; 0 if f&lt;g).</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f op g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="ab69854ec8f0a7ff4535c07cad3522de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69854ec8f0a7ff4535c07cad3522de4">&#9670;&nbsp;</a></span>Cudd_addTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addTimes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer and floating point multiplication. </p>
<p>This function can be used also to take the AND of two 0-1 ADDs.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f * g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a3ba6a6c9af4740842142de24bb1eb986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6a6c9af4740842142de24bb1eb986">&#9670;&nbsp;</a></span>Cudd_addTimesPlus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addTimesPlus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of two matrices represented as ADDs. </p>
<p>Calculates the product of two matrices, A and B, represented as ADDs, using the CMU matrix by matrix multiplication procedure by Clarke et al.. Matrix A has x's as row variables and z's as column variables, while matrix B has z's as row variables and y's as column variables. The resulting matrix has x's as row variables and y's as column variables.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddMatMult_8c.html#a2a39a76a87a363ae2a4478b6181a580d" title="Calculates the product of two matrices represented as ADDs.">Cudd_addMatrixMultiply</a> </dd></dl>

</div>
</div>
<a id="a98cb80a30ebe274373196765e3dd57a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cb80a30ebe274373196765e3dd57a3">&#9670;&nbsp;</a></span>Cudd_addTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the triangulation step for the shortest path computation. </p>
<p>Implements the semiring multiplication algorithm used in the triangulation step for the shortest path computation. f is assumed to depend on variables x (rows) and z (columns). g is assumed to depend on variables z (rows) and y (columns). The product of f and g then depends on x (rows) and y (columns). Only the z variables have to be explicitly identified; they are the "abstraction" variables.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddMatMult_8c.html#a2a39a76a87a363ae2a4478b6181a580d" title="Calculates the product of two matrices represented as ADDs.">Cudd_addMatrixMultiply</a> <a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> </dd></dl>

</div>
</div>
<a id="ae57290efa5451fcece67fc41046bd3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57290efa5451fcece67fc41046bd3a3">&#9670;&nbsp;</a></span>Cudd_addUnivAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addUnivAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Universally Abstracts all the variables in cube from f. </p>
<p>Abstracts all the variables in cube from f by taking the product over all possible values taken by the variable.</p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddAbs_8c.html#ac8603fe2007fd37712dd51ef0b78a5c7" title="Existentially Abstracts all the variables in cube from f.">Cudd_addExistAbstract</a> <a class="el" href="cuddBddAbs_8c.html#ac6b9475e3c302e6515fe4986686b6be1" title="Universally abstracts all the variables in cube from f.">Cudd_bddUnivAbstract</a> <a class="el" href="cuddAddAbs_8c.html#a8c6fd0eef3dd314aedc861a30f4b71e7" title="Disjunctively abstracts all the variables in cube from the 0-1 ADD f.">Cudd_addOrAbstract</a> </dd></dl>

</div>
</div>
<a id="a62543c529dab3780047f2a45f1e5c50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62543c529dab3780047f2a45f1e5c50f">&#9670;&nbsp;</a></span>Cudd_addVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a16a821a60a42494e3e12d91956a754c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a821a60a42494e3e12d91956a754c2">&#9670;&nbsp;</a></span>Cudd_addWalsh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addWalsh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a Walsh matrix in ADD form. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the matrixi if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a13a3aade7bb40fe511c203dfee9c0f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a3aade7bb40fe511c203dfee9c0f33">&#9670;&nbsp;</a></span>Cudd_addXeqy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addXeqy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an ADD for the function x==y. </p>
<p>This function generates an ADD for the function x==y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1]. The ADD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#ac9817150682e961ceac761a6055cbecd" title="Generates a BDD for the function x==y.">Cudd_Xeqy</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x and y variables </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e0b42ff91ece2d4abef597a964ad0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0b42ff91ece2d4abef597a964ad0e9">&#9670;&nbsp;</a></span>Cudd_addXnor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addXnor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XNOR of two 0-1 ADDs. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f XNOR g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="af0d32f9713422bd9fdbe073406b9c631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d32f9713422bd9fdbe073406b9c631">&#9670;&nbsp;</a></span>Cudd_addXor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XOR of two 0-1 ADDs. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if not a terminal case; f XOR g otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> </dd></dl>

</div>
</div>
<a id="a1827c23504bb6637971495369ebfff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1827c23504bb6637971495369ebfff34">&#9670;&nbsp;</a></span>Cudd_ApaAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> Cudd_ApaAdd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two arbitrary precision integers. </p>
<dl class="section return"><dt>Returns</dt><dd>the carry out of the most significant digit.</dd></dl>
<dl class="section user"><dt>Side effects\n The result of the sum is stored in parameter sum.</dt><dd></dd></dl>

</div>
</div>
<a id="a1bf56c6bcd0064dc9cfd8cf6c416dcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf56c6bcd0064dc9cfd8cf6c416dcef">&#9670;&nbsp;</a></span>Cudd_ApaCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaCompare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digitsFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digitsSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two arbitrary precision integers. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the first number is larger; 0 if they are equal; -1 if the second number is larger.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af1747824c9276f5928472c086edaa10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1747824c9276f5928472c086edaa10a">&#9670;&nbsp;</a></span>Cudd_ApaCompareRatios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaCompareRatios </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digitsFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>firstNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstDen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digitsSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>secondNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>secondDen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the ratios of two arbitrary precision integers to two unsigned ints. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the first number is larger; 0 if they are equal; -1 if the second number is larger.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ae7a9e620d1f62d73fd79e79594189071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9e620d1f62d73fd79e79594189071">&#9670;&nbsp;</a></span>Cudd_ApaCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ApaCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a copy of an arbitrary precision integer. </p>
<dl class="section user"><dt>Side effects\n Changes parameter dest.</dt><dd></dd></dl>

</div>
</div>
<a id="a86d07f6e04e77467e44c0d209c3b450d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d07f6e04e77467e44c0d209c3b450d">&#9670;&nbsp;</a></span>Cudd_ApaCountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> Cudd_ApaCountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>digits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of minterms of a DD. </p>
<p>The function is assumed to depend on nvars variables. The minterm count is represented as an arbitrary precision unsigned integer, to allow for any number of variables CUDD supports.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array representing the number of minterms of the function rooted at node if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The number of digits of the result is returned in</dt><dd>parameter <code>digits</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> </dd></dl>

</div>
</div>
<a id="a9448a1159e8fd6453bbb0641f658965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9448a1159e8fd6453bbb0641f658965a">&#9670;&nbsp;</a></span>Cudd_ApaIntDivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ApaIntDivision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>quotient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides an arbitrary precision integer by an integer. </p>
<p>Divides an arbitrary precision integer by a 32-bit unsigned integer. This procedure relies on the assumption that the number of bits of a DdApaDigit plus the number of bits of an unsigned int is less the number of bits of the mantissa of a double. This guarantees that the product of a DdApaDigit and an unsigned int can be represented without loss of precision by a double. On machines where this assumption is not satisfied, this procedure will malfunction.</p>
<dl class="section return"><dt>Returns</dt><dd>the remainder.</dd></dl>
<dl class="section user"><dt>Side effects\n The quotient is returned in parameter quotient.</dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>The assumption on which the correctness of this function rests is not satisfied by modern-day 64-bit CPUs.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a4c6b2acc4d31928f58adeaae9d039b91" title="Divides an arbitrary precision integer by a digit.">Cudd_ApaShortDivision</a> </dd></dl>

</div>
</div>
<a id="a39cbcb6561b572e19065a374ad420c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cbcb6561b572e19065a374ad420c89">&#9670;&nbsp;</a></span>Cudd_ApaNumberOfDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaNumberOfDigits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binaryDigits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of digits for an arbitrary precision integer. </p>
<p>Finds the number of digits for an arbitrary precision integer given the maximum number of binary digits. The number of binary digits should be positive.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a69e0a5e5523b73c0f2ce2a3e9c45b3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e0a5e5523b73c0f2ce2a3e9c45b3c8">&#9670;&nbsp;</a></span>Cudd_ApaPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ApaPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an arbitrary precision integer to a power of two. </p>
<p>If the power of two is too large to be represented, the number is set to 0.</p>
<dl class="section user"><dt>Side effects\n The result is returned in parameter number.</dt><dd></dd></dl>

</div>
</div>
<a id="a05244bf059d03fde3b1fd755111d6ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05244bf059d03fde3b1fd755111d6ae5">&#9670;&nbsp;</a></span>Cudd_ApaPrintDecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintDecimal </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an arbitrary precision integer in decimal format. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a63afad708e512fca63010abd6dc9af2d" title="Prints an arbitrary precision integer in hexadecimal format.">Cudd_ApaPrintHex</a> <a class="el" href="cuddApa_8c.html#a804362fa5a31985744e5fc1333e08eec" title="Prints an arbitrary precision integer in exponential format.">Cudd_ApaPrintExponential</a> </dd></dl>

</div>
</div>
<a id="afc488ccdcafa9150ee2c76196f891faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc488ccdcafa9150ee2c76196f891faa">&#9670;&nbsp;</a></span>Cudd_ApaPrintDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintDensity </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the density of a BDD or ADD using arbitrary precision arithmetic. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a804362fa5a31985744e5fc1333e08eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804362fa5a31985744e5fc1333e08eec">&#9670;&nbsp;</a></span>Cudd_ApaPrintExponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintExponential </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an arbitrary precision integer in exponential format. </p>
<p>Prints as an integer if precision is at least the number of digits to be printed. If precision does not allow printing of all digits, rounds to nearest breaking ties so that the last printed digit is even.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a63afad708e512fca63010abd6dc9af2d" title="Prints an arbitrary precision integer in hexadecimal format.">Cudd_ApaPrintHex</a> <a class="el" href="cuddApa_8c.html#a05244bf059d03fde3b1fd755111d6ae5" title="Prints an arbitrary precision integer in decimal format.">Cudd_ApaPrintDecimal</a> </dd></dl>
<p>&lt; readable false</p>
<p>&lt; readable true </p>

</div>
</div>
<a id="a63afad708e512fca63010abd6dc9af2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63afad708e512fca63010abd6dc9af2d">&#9670;&nbsp;</a></span>Cudd_ApaPrintHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintHex </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an arbitrary precision integer in hexadecimal format. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a05244bf059d03fde3b1fd755111d6ae5" title="Prints an arbitrary precision integer in decimal format.">Cudd_ApaPrintDecimal</a> <a class="el" href="cuddApa_8c.html#a804362fa5a31985744e5fc1333e08eec" title="Prints an arbitrary precision integer in exponential format.">Cudd_ApaPrintExponential</a> </dd></dl>

</div>
</div>
<a id="a0594a9f95c1b1935685cbf922d3d59af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0594a9f95c1b1935685cbf922d3d59af">&#9670;&nbsp;</a></span>Cudd_ApaPrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintMinterm </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#aa30cec86f65e23284b10f288f98f2e43" title="Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithme...">Cudd_ApaPrintMintermExp</a> </dd></dl>

</div>
</div>
<a id="aa30cec86f65e23284b10f288f98f2e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30cec86f65e23284b10f288f98f2e43">&#9670;&nbsp;</a></span>Cudd_ApaPrintMintermExp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ApaPrintMintermExp </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithmetic. </p>
<p>Parameter precision controls the number of signficant digits printed.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a0594a9f95c1b1935685cbf922d3d59af" title="Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic.">Cudd_ApaPrintMinterm</a> </dd></dl>

</div>
</div>
<a id="ab982f99886e7bf960d43ce880caac189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab982f99886e7bf960d43ce880caac189">&#9670;&nbsp;</a></span>Cudd_ApaSetToLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ApaSetToLiteral </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an arbitrary precision integer to a one-digit literal. </p>
<dl class="section user"><dt>Side effects\n The result is returned in parameter number.</dt><dd></dd></dl>

</div>
</div>
<a id="a40c5c6ab170b95e24dbc291e6c41772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5c6ab170b95e24dbc291e6c41772e">&#9670;&nbsp;</a></span>Cudd_ApaShiftRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ApaShiftRight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts right an arbitrary precision integer by one binary place. </p>
<p>The most significant binary digit of the result is taken from parameter <code>in</code>.</p>
<dl class="section user"><dt>Side effects\n The result is returned in parameter b.</dt><dd></dd></dl>

</div>
</div>
<a id="a4c6b2acc4d31928f58adeaae9d039b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6b2acc4d31928f58adeaae9d039b91">&#9670;&nbsp;</a></span>Cudd_ApaShortDivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> Cudd_ApaShortDivision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a>&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>quotient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides an arbitrary precision integer by a digit. </p>
<dl class="section return"><dt>Returns</dt><dd>the remainder digit.</dd></dl>
<dl class="section user"><dt>Side effects\n The quotient is returned in parameter quotient.</dt><dd></dd></dl>

</div>
</div>
<a id="af885a506f0f384da5b70eb3e4e3a2f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af885a506f0f384da5b70eb3e4e3a2f44">&#9670;&nbsp;</a></span>Cudd_ApaStringDecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cudd_ApaStringDecimal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts an arbitrary precision integer to a string in decimal format. </p>
<dl class="section return"><dt>Returns</dt><dd>the string if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a05244bf059d03fde3b1fd755111d6ae5" title="Prints an arbitrary precision integer in decimal format.">Cudd_ApaPrintDecimal</a> </dd></dl>

</div>
</div>
<a id="a622003514c774dc751db777dc6e51a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622003514c774dc751db777dc6e51a18">&#9670;&nbsp;</a></span>Cudd_ApaSubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a0232f2c556e9387699aa619167ba4fd5">DdApaDigit</a> Cudd_ApaSubtract </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#af0707285ea52e1973b46d113392eb48b">DdConstApaNumber</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts two arbitrary precision integers. </p>
<dl class="section return"><dt>Returns</dt><dd>the borrow out of the most significant digit.</dd></dl>
<dl class="section user"><dt>Side effects\n The result of the subtraction is stored in parameter</dt><dd><code>diff</code>. </dd></dl>

</div>
</div>
<a id="affd2c1c2a110944c1d760de577aed431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd2c1c2a110944c1d760de577aed431">&#9670;&nbsp;</a></span>Cudd_AutodynDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables automatic dynamic reordering. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> <a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> </dd></dl>

</div>
</div>
<a id="a219ccb201e3c1aa25ebef007399849fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219ccb201e3c1aa25ebef007399849fa">&#9670;&nbsp;</a></span>Cudd_AutodynDisableZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynDisableZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables automatic dynamic reordering of ZDDs. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> <a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> </dd></dl>

</div>
</div>
<a id="a6a0d69b4288f36d5d377c460d49066a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0d69b4288f36d5d377c460d49066a6">&#9670;&nbsp;</a></span>Cudd_AutodynEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables automatic dynamic reordering of BDDs and ADDs. </p>
<p>Parameter method is used to determine the method used for reordering. If CUDD_REORDER_SAME is passed, the method is unchanged.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> <a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> </dd></dl>

</div>
</div>
<a id="a709e0e15a38d6d6e9c83ff8b8a9d07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709e0e15a38d6d6e9c83ff8b8a9d07f2">&#9670;&nbsp;</a></span>Cudd_AutodynEnableZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_AutodynEnableZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables automatic dynamic reordering of ZDDs. </p>
<p>Parameter method is used to determine the method used for reordering ZDDs. If CUDD_REORDER_SAME is passed, the method is unchanged.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> <a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> </dd></dl>

</div>
</div>
<a id="a142a0af9f50ad2f6430d354193497c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a0af9f50ad2f6430d354193497c16">&#9670;&nbsp;</a></span>Cudd_AverageDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_AverageDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average distance between adjacent nodes in the manager. </p>
<p>Adjacent nodes are node pairs such that the second node is the then child, else child, or next node in the collision list.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a6e976b573531badb9a023f86dcdbeb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e976b573531badb9a023f86dcdbeb40">&#9670;&nbsp;</a></span>Cudd_bddAdjPermuteX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAdjPermuteX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges a set of variables in the BDD B. </p>
<p>The size of the set is given by n. This procedure is intended for the &lsquo;randomization&rsquo; of the priority functions.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> <a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> </dd></dl>

</div>
</div>
<a id="a8374b23de03000aeafb9b6deecee4b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8374b23de03000aeafb9b6deecee4b3c">&#9670;&nbsp;</a></span>Cudd_bddAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the conjunction of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af85814dd5f29584d937ad0129cee1afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85814dd5f29584d937ad0129cee1afe">&#9670;&nbsp;</a></span>Cudd_bddAndAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAndAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the AND of two BDDs and simultaneously abstracts the variables in cube. </p>
<p>The variables are existentially abstracted. Cudd_bddAndAbstract implements the semiring matrix multiplication algorithm for the boolean semiring.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result is successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddMatMult_8c.html#a2a39a76a87a363ae2a4478b6181a580d" title="Calculates the product of two matrices represented as ADDs.">Cudd_addMatrixMultiply</a> <a class="el" href="cuddMatMult_8c.html#a98cb80a30ebe274373196765e3dd57a3" title="Performs the triangulation step for the shortest path computation.">Cudd_addTriangle</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> </dd></dl>

</div>
</div>
<a id="a8c596310dd547baf86fcfbf128d326ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c596310dd547baf86fcfbf128d326ca">&#9670;&nbsp;</a></span>Cudd_bddAndAbstractLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAndAbstractLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the AND of two BDDs and simultaneously abstracts variables unless too many nodes are needed. </p>
<p>The variables in cube are existentially abstracted.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result is successful; NULL otherwise. In particular, if the number of new nodes created exceeds <code>limit</code>, this function returns NULL.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> </dd></dl>

</div>
</div>
<a id="adfbb2fd5b9c884df0d684a86dc26a97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbb2fd5b9c884df0d684a86dc26a97d">&#9670;&nbsp;</a></span>Cudd_bddAndLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAndLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the conjunction of two BDDs f and g unless too many nodes are required. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a536e36dac9b4ddf90edb3a48934b7886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e36dac9b4ddf90edb3a48934b7886">&#9670;&nbsp;</a></span>Cudd_bddApproxConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the use of supersetting to obtain an initial factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the first factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d8d2d24ef2842db6b6ab5794d2bb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d8d2d24ef2842db6b6ab5794d2bb6e">&#9670;&nbsp;</a></span>Cudd_bddApproxDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5acdc5b22c44f316a98c894998ca93d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acdc5b22c44f316a98c894998ca93d8">&#9670;&nbsp;</a></span>Cudd_bddBindVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddBindVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents sifting of a variable. </p>
<p>This function sets a flag to prevent sifting of a variable.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise (i.e., invalid variable index).</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the "bindVar" flag in DdSubtable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a944f587db5ad4427ea36912313adccaa" title="Allows the sifting of a variable.">Cudd_bddUnbindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d1414b911b3c614355a57d28f419e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d1414b911b3c614355a57d28f419e5">&#9670;&nbsp;</a></span>Cudd_bddBooleanDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddBooleanDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the boolean difference of f with respect to x. </p>
<p>Computes the boolean difference of f with respect to the variable with index x.</p>
<dl class="section return"><dt>Returns</dt><dd>the BDD of the boolean difference if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a1a4482b94e76db44ff22087277d09b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4482b94e76db44ff22087277d09b4d">&#9670;&nbsp;</a></span>Cudd_bddCharToVect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddCharToVect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a vector of BDDs whose image equals a non-zero function. </p>
<p>The result depends on the variable order. The i-th component of the vector depends only on the first i variables in the order. Each BDD in the vector is not larger than the BDD of the given characteristic function. This function is based on the description of char-to-vect in "Verification of
Sequential Machines Using Boolean Functional Vectors" by O. Coudert, C. Berthet and J. C. Madre.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array containing the result if successful; NULL otherwise. The size of the array equals the number of variables in the manager. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> </dd></dl>

</div>
</div>
<a id="aeb785f2cff5e691fba1d005b645f9b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb785f2cff5e691fba1d005b645f9b16">&#9670;&nbsp;</a></span>Cudd_bddClippingAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddClippingAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximates the conjunction of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first conjunct </td></tr>
    <tr><td class="paramname">g</td><td>second conjunct </td></tr>
    <tr><td class="paramname">maxDepth</td><td>maximum recursion depth </td></tr>
    <tr><td class="paramname">direction</td><td>under (0) or over (1) approximation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7894f643b69f42b26d4aa2554296fd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7894f643b69f42b26d4aa2554296fd15">&#9670;&nbsp;</a></span>Cudd_bddClippingAndAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddClippingAndAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximates the conjunction of two BDDs f and g and simultaneously abstracts the variables in cube. </p>
<p>The variables are existentially abstracted.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> <a class="el" href="cuddClip_8c.html#aeb785f2cff5e691fba1d005b645f9b16" title="Approximates the conjunction of two BDDs f and g.">Cudd_bddClippingAnd</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first conjunct </td></tr>
    <tr><td class="paramname">g</td><td>second conjunct </td></tr>
    <tr><td class="paramname">cube</td><td>cube of variables to be abstracted </td></tr>
    <tr><td class="paramname">maxDepth</td><td>maximum recursion depth </td></tr>
    <tr><td class="paramname">direction</td><td>under (0) or over (1) approximation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac994164b09f82c2cd44b875fa583c60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac994164b09f82c2cd44b875fa583c60d">&#9670;&nbsp;</a></span>Cudd_bddClosestCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddClosestCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a cube of f at minimum Hamming distance from the minterms of g. </p>
<p>All the minterms of the cube are at the minimum distance. If the distance is 0, the cube belongs to the intersection of f and g.</p>
<dl class="section return"><dt>Returns</dt><dd>the cube if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The distance is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#ac5d75e07d01a7a29c1cfd1b2fae8f4c8" title="Returns the minimum Hamming distance between f and minterm.">Cudd_MinHammingDist</a> </dd></dl>

</div>
</div>
<a id="ab5ccb7b9d27d9d383d0f407cf894f118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ccb7b9d27d9d383d0f407cf894f118">&#9670;&nbsp;</a></span>Cudd_bddCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes g for x_v in the BDD for f. </p>
<p>v is the index of the variable to be substituted. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="section return"><dt>Returns</dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a id="ab538e936fe0bdfe380f0ad2ecd2c6581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab538e936fe0bdfe380f0ad2ecd2c6581">&#9670;&nbsp;</a></span>Cudd_bddComputeCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddComputeCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cube of an array of BDD variables. </p>
<p>If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a2e7d0901cba492671c25ee816510867c" title="Computes the cube of an array of ADD variables.">Cudd_addComputeCube</a> <a class="el" href="cuddUtil_8c.html#a2815667bcad915fac2620161a577c46b" title="Builds a cube of BDD variables from an array of indices.">Cudd_IndicesToCube</a> <a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="a250f801a2e5814da9d67a3436f0e3376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f801a2e5814da9d67a3436f0e3376">&#9670;&nbsp;</a></span>Cudd_bddConstrain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddConstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes f constrain c. </p>
<p>Computes f constrain c (f @ c). Uses a canonical form: (f' @ c) = (f @ c)'. (Note: this is not true for c.) List of special cases: </p><ul>
<li>
f @ 0 = 0 </li>
<li>
f @ 1 = f </li>
<li>
0 @ c = 0 </li>
<li>
1 @ c = 1 </li>
<li>
f @ f = 1 </li>
<li>
f @ f'= 0 </li>
</ul>
<p>Note that if F=(f1,...,fn) and reordering takes place while computing F @ c, then the image restriction property (Img(F,c) = Img(F @ c)) is lost.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944" title="Computes f constrain c for ADDs.">Cudd_addConstrain</a> </dd></dl>

</div>
</div>
<a id="aaaf0b345123f5065ac6b2ea951b7bfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf0b345123f5065ac6b2ea951b7bfe8">&#9670;&nbsp;</a></span>Cudd_bddConstrainDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddConstrainDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD conjunctive decomposition as in McMillan's CAV96 paper. </p>
<p>The decomposition is canonical only for a given variable order. If canonicity is required, variable ordering must be disabled after the decomposition has been computed. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package).</p>
<dl class="section return"><dt>Returns</dt><dd>an array with one entry for each BDD variable in the manager if successful; otherwise NULL.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> </dd></dl>

</div>
</div>
<a id="a0419deb183e4225531473b7775f06f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0419deb183e4225531473b7775f06f9d">&#9670;&nbsp;</a></span>Cudd_bddCorrelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_bddCorrelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the correlation of f and g. </p>
<p>If f == g, their correlation is 1. If f == g', their correlation is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the fraction of minterms in the ON-set of the EXNOR of f and g. If it runs out of memory, returns (double)CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddCorr_8c.html#a79ee92dcdb59f091b2e809f0c461ccef" title="Computes the correlation of f and g for given input probabilities.">Cudd_bddCorrelationWeights</a> </dd></dl>

</div>
</div>
<a id="a79ee92dcdb59f091b2e809f0c461ccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ee92dcdb59f091b2e809f0c461ccef">&#9670;&nbsp;</a></span>Cudd_bddCorrelationWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_bddCorrelationWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the correlation of f and g for given input probabilities. </p>
<p>On input, prob[i] is supposed to contain the probability of the i-th input variable to be 1. If f == g, their correlation is</p><ol type="1">
<li>If f == g', their correlation is 0. The correlation of f and the constant one gives the probability of f.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>the probability that f and g have the same value. If it runs out of memory, returns (double)CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddCorr_8c.html#a0419deb183e4225531473b7775f06f9d" title="Computes the correlation of f and g.">Cudd_bddCorrelation</a> </dd></dl>

</div>
</div>
<a id="a38ddb1590403cc2c2d6c382b68835269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddb1590403cc2c2d6c382b68835269">&#9670;&nbsp;</a></span>Cudd_bddExistAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddExistAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Existentially abstracts all the variables in cube from f. </p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddAbs_8c.html#ac6b9475e3c302e6515fe4986686b6be1" title="Universally abstracts all the variables in cube from f.">Cudd_bddUnivAbstract</a> <a class="el" href="cuddAddAbs_8c.html#ac8603fe2007fd37712dd51ef0b78a5c7" title="Existentially Abstracts all the variables in cube from f.">Cudd_addExistAbstract</a> </dd></dl>

</div>
</div>
<a id="a667b6eab32e0bb6976d26125ce048e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667b6eab32e0bb6976d26125ce048e5a">&#9670;&nbsp;</a></span>Cudd_bddExistAbstractLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddExistAbstractLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Existentially abstracts all the variables in cube from f. </p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> </dd></dl>

</div>
</div>
<a id="a8de1749d0e92e061d1b3edafc56956b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de1749d0e92e061d1b3edafc56956b3">&#9670;&nbsp;</a></span>Cudd_bddGenConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the fact tht it generalizes the decomposition based on the cofactors with respect to one variable. The conjuncts produced by this procedure tend to be balanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7cc1a34d26e9bbf9d3919e258dd952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7cc1a34d26e9bbf9d3919e258dd952">&#9670;&nbsp;</a></span>Cudd_bddGenDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be balanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee71bb03723625bacf2c0b369a187125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee71bb03723625bacf2c0b369a187125">&#9670;&nbsp;</a></span>Cudd_bddInterpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddInterpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an interpolant of two functions. </p>
<p>Given BDDs <code>l</code> and <code>u</code>, representing the lower bound and upper bound of a function interval, Cudd_bddInterpolate produces the BDD of a function within the interval that only depends on the variables common to <code>l</code> and <code>u</code>.</p>
<p>The approach is based on quantification as in <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict()</a>. The function assumes that <code>l</code> implies <code>u</code>, but does not check whether that's true.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">l</td><td>lower bound </td></tr>
    <tr><td class="paramname">u</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dc109a28a03aae73d3390dc5846a8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc109a28a03aae73d3390dc5846a8cb">&#9670;&nbsp;</a></span>Cudd_bddIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a function included in the intersection of f and g. </p>
<p>The function computed (if not zero) is a witness that the intersection is not empty. Cudd_bddIntersect tries to build as few new nodes as possible. If the only result of interest is whether f and g intersect, Cudd_bddLeq should be used instead.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a705817ee319b2dd8e95b229722b0b65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705817ee319b2dd8e95b229722b0b65e">&#9670;&nbsp;</a></span>Cudd_bddInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lowerB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>upperB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function lowerB &le; x &le; upperB. </p>
<p>This function generates a BDD for the function lowerB &le; x &le; upperB, where x is an N-bit number, x[0] x[1] ... x[N-1], with 0 the most significant bit (important!). The number of variables N should be sufficient to represent the bounds; otherwise, the bounds are truncated to their N least significant bits. Two BDDs are built bottom-up for lowerB &le; x and x &le; upperB, and they are finally conjoined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x variables </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">lowerB</td><td>lower bound </td></tr>
    <tr><td class="paramname">upperB</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4fca0bea12745bf32f153a72dc269f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4fca0bea12745bf32f153a72dc269f">&#9670;&nbsp;</a></span>Cudd_bddIsNsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsNsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is next state. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> </dd></dl>

</div>
</div>
<a id="a17691865ef8b69e1d04ce5651da841e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17691865ef8b69e1d04ce5651da841e0">&#9670;&nbsp;</a></span>Cudd_bddIsop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIsop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a BDD in the interval between L and U with a simple sum-of-product cover. </p>
<p>This procedure is similar to Cudd_zddIsop, but it does not return the ZDD for the cover.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddIsop_8c.html#a2b5124feb3accdd31cfeb287ffff59f7" title="Computes an ISOP in ZDD form from BDDs.">Cudd_zddIsop</a> </dd></dl>

</div>
</div>
<a id="a8807a8333099dbd0d32cccf9da8841b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8807a8333099dbd0d32cccf9da8841b2">&#9670;&nbsp;</a></span>Cudd_bddIsPiVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsPiVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is primary input. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is primary input; 0 if the variable exists but is not a primary input; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390b021da58cb55e9c912f4490a5845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390b021da58cb55e9c912f4490a5845e">&#9670;&nbsp;</a></span>Cudd_bddIsPsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsPsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is present state. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable's type is present state; 0 if the variable exists but is not a present state; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>

</div>
</div>
<a id="a7174f24036c4eae624311b273df978da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7174f24036c4eae624311b273df978da">&#9670;&nbsp;</a></span>Cudd_bddIsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if the given node is a BDD variable; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a705c1545f9efe374d475c99a9110803c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c1545f9efe374d475c99a9110803c">&#9670;&nbsp;</a></span>Cudd_bddIsVarEssential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarEssential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a given variable is essential with a given phase in a BDD. </p>
<p>Uses Cudd_bddIteConstant. Returns 1 if phase == 1 and f--&gt;x_id, or if phase == 0 and f--&gt;x_id'.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddEssent_8c.html#a4615437702b72ce2d5d4b25e8f2e3bbc" title="Finds the essential variables of a DD.">Cudd_FindEssential</a> </dd></dl>

</div>
</div>
<a id="a14eda0885ab454e4e518639208e0c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eda0885ab454e4e518639208e0c920">&#9670;&nbsp;</a></span>Cudd_bddIsVarHardGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarHardGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be in a hard group. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable is marked to be in a hard group; 0 if the variable exists, but it is not marked to be in a hard group; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a956ea07041f3e4f560bc936404461b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ea07041f3e4f560bc936404461b2a">&#9670;&nbsp;</a></span>Cudd_bddIsVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a8e0ef3b582414eb1907ad98fb4cc16e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0ef3b582414eb1907ad98fb4cc16e9">&#9670;&nbsp;</a></span>Cudd_bddIsVarToBeUngrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIsVarToBeUngrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is set to be ungrouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable is marked to be ungrouped; 0 if the variable exists, but it is not marked to be ungrouped; -1 if the variable does not exist.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acdd0386d3adadf96af5a95939586dc7b" title="Sets a variable to be ungrouped.">Cudd_bddSetVarToBeUngrouped</a> </dd></dl>

</div>
</div>
<a id="a3f5761d50898785418ebcaccefb18a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5761d50898785418ebcaccefb18a93">&#9670;&nbsp;</a></span>Cudd_bddIte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements ITE(f,g,h). </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAddIte_8c.html#a385a1fdc578cf9e41ff15ef50b6870df" title="Implements ITE(f,g,h).">Cudd_addIte</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>third operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae893c6ab0472d7058bd424d02bc9420f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae893c6ab0472d7058bd424d02bc9420f">&#9670;&nbsp;</a></span>Cudd_bddIteConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIteConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements ITEconstant(f,g,h). </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD (which may or may not be constant) or DD_NON_CONSTANT.</dd></dl>
<p>No new nodes are created.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>thord operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41cc655c685b3822fc21663dfaebdfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cc655c685b3822fc21663dfaebdfc6">&#9670;&nbsp;</a></span>Cudd_bddIteLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIteLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements ITE(f,g,h) unless too many nodes are required. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>third operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7b54f1fae0417dcb3eeab6f1be792fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b54f1fae0417dcb3eeab6f1be792fa">&#9670;&nbsp;</a></span>Cudd_bddIterConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the iterated use of supersetting to obtain a factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac716bb2411a608764d34404fadf09379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac716bb2411a608764d34404fadf09379">&#9670;&nbsp;</a></span>Cudd_bddIterDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40fd71665cde402bd5bc4f39015c09ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fd71665cde402bd5bc4f39015c09ae">&#9670;&nbsp;</a></span>Cudd_bddIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the BDD variable with index i. </p>
<p>Retrieves the BDD variable with index i if it already exists, or creates a new BDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> <a class="el" href="cuddAPI_8c.html#a44d8f64c98953fd110d0e5146bcadaca" title="Returns the i-th element of the vars array.">Cudd_ReadVars</a> </dd></dl>

</div>
</div>
<a id="a3a45afd92abdea6f969399e7c0eb5c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a45afd92abdea6f969399e7c0eb5c8f">&#9670;&nbsp;</a></span>Cudd_bddLargestPrimeUnate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLargestPrimeUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>phaseBdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a largest prime implicant of a unate function. </p>
<p>The behavior is undefined if f is not unate. The third argument is used to determine whether f is unate positive (increasing) or negative (decreasing) in each of the variables in its support.</p>
<dl class="section return"><dt>Returns</dt><dd>the BDD for the prime if succesful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>unate function </td></tr>
    <tr><td class="paramname">phaseBdd</td><td>cube of the phases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89a46089e8572876a1521cdee6cb31a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a46089e8572876a1521cdee6cb31a2">&#9670;&nbsp;</a></span>Cudd_bddLeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddLeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether f is less than or equal to g. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if f is less than or equal to g; 0 otherwise.</dd></dl>
<p>No new nodes are created.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dcbf450b32f6937bc6dba252474638d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcbf450b32f6937bc6dba252474638d">&#9670;&nbsp;</a></span>Cudd_bddLeqUnless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddLeqUnless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether f is less than of equal to G unless D is 1. </p>
<p>f, g, and D are BDDs. No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if f is less than of equal to G, and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a3e078600dd9087c623e1bdfea00d599d" title="Tells whether F and G are identical wherever D is 0.">Cudd_EquivDC</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>

</div>
</div>
<a id="a6c23e53c189d45d06b68a9a52b724141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c23e53c189d45d06b68a9a52b724141">&#9670;&nbsp;</a></span>Cudd_bddLICompaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLICompaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs safe minimization of a BDD. </p>
<p>Given the BDD <code>f</code> of a function to be minimized and a BDD <code>c</code> representing the care set, Cudd_bddLICompaction produces the BDD of a function that agrees with <code>f</code> wherever <code>c</code> is 1. Safe minimization means that the size of the result is guaranteed not to exceed the size of <code>f</code>. This function is based on the DAC97 paper by Hong et al..</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be minimized </td></tr>
    <tr><td class="paramname">c</td><td>constraint (care set) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b953384d8f552c774055694db06ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b953384d8f552c774055694db06ba4">&#9670;&nbsp;</a></span>Cudd_bddLiteralSetIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLiteralSetIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intesection of two sets of literals represented as BDDs. </p>
<p>Each set is represented as a cube of the literals in the set. The empty set is represented by the constant 1. No variable can be simultaneously present in both phases in a set.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD representing the intersected sets, if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a7b924211354f5d356009a7c804be2340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b924211354f5d356009a7c804be2340">&#9670;&nbsp;</a></span>Cudd_bddMakePrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMakePrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands cube to a prime implicant of f. </p>
<dl class="section return"><dt>Returns</dt><dd>the prime if successful; NULL otherwise. In particular, NULL is returned if cube is not a real cube or is not an implicant of f.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">cube</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">f</td><td>function of which the cube is to be made a prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accb9bb89f75fe6176be961c73a19be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb9bb89f75fe6176be961c73a19be09">&#9670;&nbsp;</a></span>Cudd_bddMaximallyExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMaximallyExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands lb to prime implicants of (f and ub). </p>
<p>Expands lb to all prime implicants of (f and ub) that contain lb. Assumes that lb is contained in ub.</p>
<dl class="section return"><dt>Returns</dt><dd>the disjunction of the primes if lb is contained in f; returns the zero BDD if lb is not contained in f; returns NULL in case of failure. In particular, NULL is returned if cube is not a real cube or is not an implicant of f. Returning the disjunction of all prime implicants works because the resulting function is unate.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a7b924211354f5d356009a7c804be2340" title="Expands cube to a prime implicant of f.">Cudd_bddMakePrime</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">lb</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound cube </td></tr>
    <tr><td class="paramname">f</td><td>function against which to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af47227c86f08d37cd5fd8ea2a89afcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47227c86f08d37cd5fd8ea2a89afcb7">&#9670;&nbsp;</a></span>Cudd_bddMinimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMinimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a small BDD that agrees with <code>f</code> over <code>c</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>

</div>
</div>
<a id="a98d4502750f55f79f7d21ce4674bd66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d4502750f55f79f7d21ce4674bd66f">&#9670;&nbsp;</a></span>Cudd_bddNand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the NAND of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a475c50e1a273569cc0ffc19ab98c28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c50e1a273569cc0ffc19ab98c28ce">&#9670;&nbsp;</a></span>Cudd_bddNewVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNewVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new BDD variable. </p>
<p>The new variable has an index equal to the largest previous index plus 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ad77f4dd2911bac8e25633fe84c6cfb8b" title="Returns a new ADD variable.">Cudd_addNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="ae35eac7df807101795efe0d582ff05fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35eac7df807101795efe0d582ff05fa">&#9670;&nbsp;</a></span>Cudd_bddNewVarAtLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNewVarAtLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new BDD variable at a specified level. </p>
<p>The new variable has an index equal to the largest previous index plus 1 and is positioned at the specified level in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#aacea7b5ed8dc2595a1c0e01788bc205a" title="Returns a new ADD variable at a specified level.">Cudd_addNewVarAtLevel</a> </dd></dl>

</div>
</div>
<a id="a3bb902e010f3213ba3a0e7917e93b70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb902e010f3213ba3a0e7917e93b70e">&#9670;&nbsp;</a></span>Cudd_bddNor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the NOR of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac859dc8f03d9f8dcbc54dcab5ee94912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac859dc8f03d9f8dcbc54dcab5ee94912">&#9670;&nbsp;</a></span>Cudd_bddNPAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNPAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes f non-polluting-and g. </p>
<p>The non-polluting AND of f and g is a hybrid of AND and Restrict. From Restrict, this operation takes the idea of existentially quantifying the top variable of the second operand if it does not appear in the first. Therefore, the variables that appear in the result also appear in f. For the rest, the function behaves like AND. Since the two operands play different roles, non-polluting AND is not commutative.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a id="ad9dd195b3599f9101ff65b57e494f445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dd195b3599f9101ff65b57e494f445">&#9670;&nbsp;</a></span>Cudd_bddOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the disjunction of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cbc77f8b658ac3c88a2549a84c58b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbc77f8b658ac3c88a2549a84c58b38">&#9670;&nbsp;</a></span>Cudd_bddOrLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddOrLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the disjunction of two BDDs f and g unless too many nodes are required. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa877bf86c670ea10d67d4f6e91fcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa877bf86c670ea10d67d4f6e91fcc98">&#9670;&nbsp;</a></span>Cudd_bddPermute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the variables of a BDD. </p>
<p>Given a permutation in array permut, creates a new BDD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a57c4e8e8d0b9ec3101e117629a2a459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c4e8e8d0b9ec3101e117629a2a459d">&#9670;&nbsp;</a></span>Cudd_bddPickArbitraryMinterms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddPickArbitraryMinterms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks k on-set minterms evenly distributed from given DD. </p>
<p>The minterms are in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterms built by this procedure may not be contained in <code>f</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>an array of BDDs for the minterms if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul>
<li>
It may run out of memory; </li>
<li>
the function <code>f</code> may be the constant 0; </li>
<li>
the minterms may not be contained in <code>f</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a57f68528887c0feb428d010c2173a59b" title="Picks one on-set minterm randomly from the given DD.">Cudd_bddPickOneMinterm</a> <a class="el" href="cuddUtil_8c.html#adcc47738ff8b49602d4e1442fd55576f" title="Picks one on-set cube randomly from the given DD.">Cudd_bddPickOneCube</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick k minterms </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">n</td><td>size of <code>vars</code> </td></tr>
    <tr><td class="paramname">k</td><td>number of minterms to find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc47738ff8b49602d4e1442fd55576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc47738ff8b49602d4e1442fd55576f">&#9670;&nbsp;</a></span>Cudd_bddPickOneCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddPickOneCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>ddm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks one on-set cube randomly from the given DD. </p>
<p>The cube is written into an array of characters. The array must have at least as many entries as there are variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a57f68528887c0feb428d010c2173a59b" title="Picks one on-set minterm randomly from the given DD.">Cudd_bddPickOneMinterm</a> </dd></dl>

</div>
</div>
<a id="a57f68528887c0feb428d010c2173a59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f68528887c0feb428d010c2173a59b">&#9670;&nbsp;</a></span>Cudd_bddPickOneMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddPickOneMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks one on-set minterm randomly from the given DD. </p>
<p>The minterm is in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterm built by this procedure may not be contained in <code>f</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the minterm if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul>
<li>
It may run out of memory; </li>
<li>
the function <code>f</code> may be the constant 0; </li>
<li>
the minterm may not be contained in <code>f</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#adcc47738ff8b49602d4e1442fd55576f" title="Picks one on-set cube randomly from the given DD.">Cudd_bddPickOneCube</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick one minterm </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">n</td><td>size of <code>vars</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b61fadaf6046697691b35fad8c9faf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b61fadaf6046697691b35fad8c9faf0">&#9670;&nbsp;</a></span>Cudd_bddPrintCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddPrintCover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a sum of prime implicants of a BDD. </p>
<p>Prints a sum of product cover for an incompletely specified function given by a lower bound and an upper bound. Each product is a prime implicant obtained by expanding the product corresponding to a path from node to the constant one. Uses the package default output file.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aeab82cceadafa2b81083e0467c102526" title="Prints a disjoint sum of products.">Cudd_PrintMinterm</a> </dd></dl>

</div>
</div>
<a id="aa3a5e49e217519cb4d29545aa0bbbb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a5e49e217519cb4d29545aa0bbbb4d">&#9670;&nbsp;</a></span>Cudd_bddRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddRead </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a graph (without labels) given as a list of arcs. </p>
<p>Reads in a graph (without labels) given as an adjacency matrix. The first line of the input contains the numbers of rows and columns of the adjacency matrix. The remaining lines contain the arcs of the graph, one per line. Each arc is described by two integers, i.e., the row and column number, or the indices of the two endpoints. Cudd_bddRead produces a BDD that depends on two sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode the row index and the y variables (y[0] ... y[ny-1]) encode the column index. x[0] and y[0] are the most significant bits in the indices. The variables may already exist or may be created by the function. The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.</p>
<p>On input, nx and ny hold the numbers of row and column variables already in existence. On output, they hold the numbers of row and column variables actually used by the matrix. When Cudd_bddRead creates the variable arrays, the index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy. When some variables already exist, Cudd_bddRead expects the indices of the existing x variables to be bx+i*sx, and the indices of the existing y variables to be by+i*sy.</p>
<p>m and n are set to the numbers of rows and columns of the matrix. Their values on input are immaterial. The BDD for the graph is returned in E, and its reference count is &gt; 0.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n nx and ny are set to the numbers of row and column</dt><dd>variables. m and n are set to the numbers of rows and columns. x and y are possibly extended to represent the array of row and column variables.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddHarwell_8c.html#a34a8110e2fedb3bf6674cbe9a83e6de3" title="Reads in a matrix in the format of the Harwell-Boeing benchmark suite.">Cudd_addHarwell</a> <a class="el" href="cuddRead_8c.html#a60fa1f494a6075b537e13b655c564e76" title="Reads in a sparse matrix.">Cudd_addRead</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>input file pointer </td></tr>
    <tr><td class="paramname">dd</td><td><a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> manager </td></tr>
    <tr><td class="paramname">E</td><td>characteristic function of the graph </td></tr>
    <tr><td class="paramname">x</td><td>array of row variables </td></tr>
    <tr><td class="paramname">y</td><td>array of column variables </td></tr>
    <tr><td class="paramname">nx</td><td>number or row variables </td></tr>
    <tr><td class="paramname">ny</td><td>number or column variables </td></tr>
    <tr><td class="paramname">m</td><td>number of rows </td></tr>
    <tr><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramname">bx</td><td>first index of row variables </td></tr>
    <tr><td class="paramname">sx</td><td>step of row variables </td></tr>
    <tr><td class="paramname">by</td><td>first index of column variables </td></tr>
    <tr><td class="paramname">sy</td><td>step of column variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a642b76a558f6dafd89648f9f7c470b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b76a558f6dafd89648f9f7c470b68">&#9670;&nbsp;</a></span>Cudd_bddReadPairIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddReadPairIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a corresponding pair index for a given index. </p>
<p>These pair indices are present and next state variable.</p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding variable index if the variable exists; -1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac11beec034c2fc7842ca370aaeed9b21" title="Sets a corresponding pair index for a given index.">Cudd_bddSetPairIndex</a> </dd></dl>

</div>
</div>
<a id="a3eb093bdd80db0b880f61017f3e36de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb093bdd80db0b880f61017f3e36de2">&#9670;&nbsp;</a></span>Cudd_bddRealignDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_bddRealignDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables realignment of ZDD order to BDD order. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a2d0d34d836668fc62e7c7835fa95132d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0d34d836668fc62e7c7835fa95132d">&#9670;&nbsp;</a></span>Cudd_bddRealignEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_bddRealignEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables realignment of BDD order to ZDD order. </p>
<p>Enables realignment of the BDD variable order to the ZDD variable order after the ZDDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_zddReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddReord_8c.html#ab2a6a57fc8464e16e222c130aed593d9" title="Main dynamic reordering routine for ZDDs.">Cudd_zddReduceHeap</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a516183604a75b38337b81fd17c291826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516183604a75b38337b81fd17c291826">&#9670;&nbsp;</a></span>Cudd_bddRealignmentEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddRealignmentEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the realignment of BDD order to ZDD order is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the realignment of BDD order to ZDD order is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> </dd></dl>

</div>
</div>
<a id="ac8613c4063493aebe3dc9e0e14562114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8613c4063493aebe3dc9e0e14562114">&#9670;&nbsp;</a></span>Cudd_bddResetVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddResetVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a variable not to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a776ff1149be00414f9dfb9d8e5236b6a" title="Sets a variable to be grouped.">Cudd_bddSetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a3c8d8bb0210e368eb7258b2961c3cf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8d8bb0210e368eb7258b2961c3cf3e">&#9670;&nbsp;</a></span>Cudd_bddRestrict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddRestrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BDD restrict according to Coudert and Madre's algorithm (ICCAD90). </p>
<p>If application of restrict results in a BDD larger than the input BDD, the input BDD is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the restricted BDD if successful; otherwise NULL.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddGenCof_8c.html#a4ab16f58da620eb1c2e927426aea22c7" title="ADD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_addRestrict</a> </dd></dl>

</div>
</div>
<a id="a9259947e31d7d43fee7209e08e0257f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9259947e31d7d43fee7209e08e0257f0">&#9670;&nbsp;</a></span>Cudd_bddSetNsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetNsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to next state. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a5f4fca0bea12745bf32f153a72dc269f" title="Checks whether a variable is next state.">Cudd_bddIsNsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac11beec034c2fc7842ca370aaeed9b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11beec034c2fc7842ca370aaeed9b21">&#9670;&nbsp;</a></span>Cudd_bddSetPairIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPairIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pairIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a corresponding pair index for a given index. </p>
<p>These pair indices are present and next state variable.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a642b76a558f6dafd89648f9f7c470b68" title="Reads a corresponding pair index for a given index.">Cudd_bddReadPairIndex</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
    <tr><td class="paramname">pairIndex</td><td>corresponding variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac6849dc17bbba2043922cb0efcd21ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6849dc17bbba2043922cb0efcd21ec">&#9670;&nbsp;</a></span>Cudd_bddSetPiVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPiVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to primary input. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac8deaa5bc364ba47901043ea405b6909" title="Sets a variable type to present state.">Cudd_bddSetPsVar</a> <a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a8807a8333099dbd0d32cccf9da8841b2" title="Checks whether a variable is primary input.">Cudd_bddIsPiVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8deaa5bc364ba47901043ea405b6909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8deaa5bc364ba47901043ea405b6909">&#9670;&nbsp;</a></span>Cudd_bddSetPsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetPsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable type to present state. </p>
<p>The variable type is used by lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac6849dc17bbba2043922cb0efcd21ec" title="Sets a variable type to primary input.">Cudd_bddSetPiVar</a> <a class="el" href="cuddAPI_8c.html#a9259947e31d7d43fee7209e08e0257f0" title="Sets a variable type to next state.">Cudd_bddSetNsVar</a> <a class="el" href="cuddAPI_8c.html#a390b021da58cb55e9c912f4490a5845e" title="Checks whether a variable is present state.">Cudd_bddIsPsVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f3008fcc7c507d061c10a343a6c01ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3008fcc7c507d061c10a343a6c01ce">&#9670;&nbsp;</a></span>Cudd_bddSetVarHardGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarHardGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be a hard group. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a776ff1149be00414f9dfb9d8e5236b6a" title="Sets a variable to be grouped.">Cudd_bddSetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#ac8613c4063493aebe3dc9e0e14562114" title="Resets a variable not to be grouped.">Cudd_bddResetVarToBeGrouped</a> <a class="el" href="cuddAPI_8c.html#a14eda0885ab454e4e518639208e0c920" title="Checks whether a variable is set to be in a hard group.">Cudd_bddIsVarHardGroup</a> </dd></dl>

</div>
</div>
<a id="a776ff1149be00414f9dfb9d8e5236b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ff1149be00414f9dfb9d8e5236b6a">&#9670;&nbsp;</a></span>Cudd_bddSetVarToBeGrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarToBeGrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be grouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2f3008fcc7c507d061c10a343a6c01ce" title="Sets a variable to be a hard group.">Cudd_bddSetVarHardGroup</a> <a class="el" href="cuddAPI_8c.html#ac8613c4063493aebe3dc9e0e14562114" title="Resets a variable not to be grouped.">Cudd_bddResetVarToBeGrouped</a> </dd></dl>

</div>
</div>
<a id="acdd0386d3adadf96af5a95939586dc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd0386d3adadf96af5a95939586dc7b">&#9670;&nbsp;</a></span>Cudd_bddSetVarToBeUngrouped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddSetVarToBeUngrouped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a variable to be ungrouped. </p>
<p>This function is used for lazy sifting.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n modifies the manager</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a8e0ef3b582414eb1907ad98fb4cc16e9" title="Checks whether a variable is set to be ungrouped.">Cudd_bddIsVarToBeUngrouped</a> </dd></dl>

</div>
</div>
<a id="afbc2329b3d7a6cb0b8adc5582fc7fe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc2329b3d7a6cb0b8adc5582fc7fe2c">&#9670;&nbsp;</a></span>Cudd_bddSqueeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddSqueeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a small BDD in a function interval. </p>
<p>Given BDDs <code>l</code> and <code>u</code>, representing the lower bound and upper bound of a function interval, Cudd_bddSqueeze produces the BDD of a function within the interval with a small BDD.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">l</td><td>lower bound </td></tr>
    <tr><td class="paramname">u</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab6b6123e102f9b0b61c9d2961f707e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab6b6123e102f9b0b61c9d2961f707e">&#9670;&nbsp;</a></span>Cudd_bddSwapVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the BDD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a id="a2a0f570e1bbe987fdecc4786ac808e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0f570e1bbe987fdecc4786ac808e08">&#9670;&nbsp;</a></span>Cudd_BddToAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BddToAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a BDD to a 0-1 ADD. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBridge_8c.html#a6a80d92ddf13c5d54e61974f1855c22b" title="Converts an ADD to a BDD.">Cudd_addBddPattern</a> <a class="el" href="cuddBridge_8c.html#adf94a0491ea6d3464e488b667a0b42bd" title="Converts an ADD to a BDD.">Cudd_addBddThreshold</a> <a class="el" href="cuddBridge_8c.html#adfa95504dec573eada577783098b26b6" title="Converts an ADD to a BDD.">Cudd_addBddInterval</a> <a class="el" href="cuddBridge_8c.html#a17a7d31fbafb86bd3b335b2a5523444c" title="Converts an ADD to a BDD.">Cudd_addBddStrictThreshold</a> </dd></dl>

</div>
</div>
<a id="ab53ebc58628a5a659b86025e6ed9c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53ebc58628a5a659b86025e6ed9c492">&#9670;&nbsp;</a></span>Cudd_BddToCubeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_BddToCubeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a positional array from the BDD of a cube. </p>
<p>Array must have one entry for each BDD variable. The positional array has 1 in i-th position if the variable of index i appears in true form in the cube; it has 0 in i-th position if the variable of index i appears in complemented form in the cube; finally, it has 2 in i-th position if the variable of index i does not appear in the cube.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful (the BDD is indeed a cube); 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The result is in the array passed by reference.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="a5744cfcff87a1a83b2cbaab2aba51494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5744cfcff87a1a83b2cbaab2aba51494">&#9670;&nbsp;</a></span>Cudd_bddTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>ddSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>ddDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a BDD from a manager to another one. </p>
<p>The orders of the variables in the two managers may be different.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD in the destination manager if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a944f587db5ad4427ea36912313adccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944f587db5ad4427ea36912313adccaa">&#9670;&nbsp;</a></span>Cudd_bddUnbindVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddUnbindVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the sifting of a variable. </p>
<p>This function resets the flag that prevents the sifting of a variable. In successive variable reorderings, the variable will NOT be skipped, that is, sifted. Initially all variables can be sifted. It is necessary to call this function only to re-enable sifting after a call to Cudd_bddBindVar.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise (i.e., invalid variable index).</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the "bindVar" flag in DdSubtable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5acdc5b22c44f316a98c894998ca93d8" title="Prevents sifting of a variable.">Cudd_bddBindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b9475e3c302e6515fe4986686b6be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b9475e3c302e6515fe4986686b6be1">&#9670;&nbsp;</a></span>Cudd_bddUnivAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddUnivAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Universally abstracts all the variables in cube from f. </p>
<dl class="section return"><dt>Returns</dt><dd>the abstracted BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> <a class="el" href="cuddAddAbs_8c.html#ae57290efa5451fcece67fc41046bd3a3" title="Universally Abstracts all the variables in cube from f.">Cudd_addUnivAbstract</a> </dd></dl>

</div>
</div>
<a id="aaa21da753c8a5798886891fed4baaaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa21da753c8a5798886891fed4baaaa4">&#9670;&nbsp;</a></span>Cudd_bddVarConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>Conjunctively decomposes one BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>(f+x)(f+x')</code>. The variable is chosen so as to balance the sizes of the two conjuncts and to keep them small.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a057207ca7a87e980a040bb1183db3645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057207ca7a87e980a040bb1183db3645">&#9670;&nbsp;</a></span>Cudd_bddVarDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>Performs two-way disjunctive decomposition of a BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>f*x + f*x'</code>. The variable is chosen so as to balance the sizes of the two disjuncts and to keep them small.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d01993b4162e8ece02e339ecb0a456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d01993b4162e8ece02e339ecb0a456">&#9670;&nbsp;</a></span>Cudd_bddVarIsBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarIsBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether a variable can be sifted. </p>
<p>This function returns 1 if a variable is enabled for sifting. Initially all variables can be sifted. This function returns 0 if there has been a previous call to Cudd_bddBindVar for that variable not followed by a call to Cudd_bddUnbindVar. The function returns 0 also in the case in which the index of the variable is out of bounds.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5acdc5b22c44f316a98c894998ca93d8" title="Prevents sifting of a variable.">Cudd_bddBindVar</a> <a class="el" href="cuddAPI_8c.html#a944f587db5ad4427ea36912313adccaa" title="Allows the sifting of a variable.">Cudd_bddUnbindVar</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">index</td><td>variable index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4175e1b1c5fe59957da7be2966036a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4175e1b1c5fe59957da7be2966036a77">&#9670;&nbsp;</a></span>Cudd_bddVarIsDependent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarIsDependent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a variable is dependent on others in a function. </p>
<p>No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variable is dependent; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">var</td><td>variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b6ff390b8f205a28d2804d723118d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b6ff390b8f205a28d2804d723118d9">&#9670;&nbsp;</a></span>Cudd_bddVarMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remaps the variables of a BDD using the default variable map. </p>
<p>A typical use of this function is to swap two sets of variables. The variable map must be registered with Cudd_SetVarMap.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddCompose_8c.html#a3d0ed2b9c7a7158ed78273908a2a5386" title="Registers a variable mapping with the manager.">Cudd_SetVarMap</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>function in which to remap variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bffb3a79510753ee6648a998aaaae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bffb3a79510753ee6648a998aaaae97">&#9670;&nbsp;</a></span>Cudd_bddVectorCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes a BDD with a vector of BDDs. </p>
<p>Given a vector of BDDs, creates a new BDD by substituting the BDDs for the variables of the BDD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> <a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> </dd></dl>

</div>
</div>
<a id="a452caf40a12400757e44fe5a8569e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452caf40a12400757e44fe5a8569e20c">&#9670;&nbsp;</a></span>Cudd_bddXnor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXnor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the exclusive NOR of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7422788984a855fb387643f27294014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7422788984a855fb387643f27294014">&#9670;&nbsp;</a></span>Cudd_bddXnorLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXnorLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the exclusive NOR of two BDDs f and g unless too many nodes are required. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than <code>limit</code> are required.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2215420b94afbcd00d011fe2787c5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2215420b94afbcd00d011fe2787c5e7">&#9670;&nbsp;</a></span>Cudd_bddXor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the exclusive OR of two BDDs f and g. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32bc16ad340eb8baf7803d2e425fdfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bc16ad340eb8baf7803d2e425fdfee">&#9670;&nbsp;</a></span>Cudd_bddXorExistAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXorExistAbstract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the exclusive OR of two BDDs and simultaneously abstracts the variables in cube. </p>
<p>The variables are existentially abstracted.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result is successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddAbs_8c.html#ac6b9475e3c302e6515fe4986686b6be1" title="Universally abstracts all the variables in cube from f.">Cudd_bddUnivAbstract</a> <a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> <a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> </dd></dl>

</div>
</div>
<a id="ab6ecb253ad0a11cc9430f0d527e6eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ecb253ad0a11cc9430f0d527e6eaa0">&#9670;&nbsp;</a></span>Cudd_BiasedOverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the biased underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2" title="Extracts a dense subset from a BDD with the biased underapproximation method.">Cudd_BiasedUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">b</td><td>bias function </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fe204aedfdf7705234573d8781729e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe204aedfdf7705234573d8781729e2">&#9670;&nbsp;</a></span>Cudd_BiasedUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the biased underapproximation method. </p>
<p>This procedure uses a biased remapping technique and density as the cost function. The bias is a function. This procedure tries to approximate where the bias is 0 and preserve the given function where the bias is 1. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">b</td><td>bias function </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe87964c4eda5c1b32acdd98fb43a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe87964c4eda5c1b32acdd98fb43a727">&#9670;&nbsp;</a></span>Cudd_CheckCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_CheckCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether g is the BDD of a cube. </p>
<p>The constant 1 is a valid cube, but all other constant functions cause cuddCheckCube to return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a081e08d440a7ca8b7406e79b25dfaef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081e08d440a7ca8b7406e79b25dfaef5">&#9670;&nbsp;</a></span>Cudd_CheckKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_CheckKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for several conditions that should not occur. </p>
<p>Checks for the following conditions: </p><ul>
<li>
Wrong sizes of subtables. </li>
<li>
Wrong number of keys found in unique subtable. </li>
<li>
Wrong number of dead found in unique subtable. </li>
<li>
Wrong number of keys found in the constant table </li>
<li>
Wrong number of dead found in the constant table </li>
<li>
Wrong number of total slots found </li>
<li>
Wrong number of maximum keys found </li>
<li>
Wrong number of total dead found </li>
</ul>
<p>Reports the average length of non-empty lists.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of subtables for which the number of keys is wrong.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCheck_8c.html#ae4784371f26794a254bcc6a2ad875b5e" title="Checks for inconsistencies in the DD heap.">Cudd_DebugCheck</a> </dd></dl>

</div>
</div>
<a id="a0d388f1545438a43167bb55d6c432ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d388f1545438a43167bb55d6c432ef0">&#9670;&nbsp;</a></span>Cudd_CheckZeroRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_CheckZeroRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the unique table for nodes with non-zero reference counts. </p>
<p>It is normally called before Cudd_Quit to make sure that there are no memory leaks due to missing Cudd_RecursiveDeref's. Takes into account that reference counts may saturate and that the basic constants and the projection functions are referenced by the manager.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes with non-zero reference count. (Except for the cases mentioned above.)</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2caf3183bbb7822b76bacd8b70aebc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caf3183bbb7822b76bacd8b70aebc94">&#9670;&nbsp;</a></span>Cudd_ClassifySupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ClassifySupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>onlyF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>onlyG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classifies the variables in the support of two DDs. </p>
<p>Classifies the variables in the support of two DDs <code>f</code> and <code>g</code>, depending on whether they appear in both DDs, only in <code>f</code>, or only in <code>g</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cubes of the three classes of variables are</dt><dd>returned as side effects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first DD </td></tr>
    <tr><td class="paramname">g</td><td>second DD </td></tr>
    <tr><td class="paramname">common</td><td>cube of shared variables </td></tr>
    <tr><td class="paramname">onlyF</td><td>cube of variables only in f </td></tr>
    <tr><td class="paramname">onlyG</td><td>cube of variables only in g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed3a189c261ed9f698ace55ade32af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3a189c261ed9f698ace55ade32af01">&#9670;&nbsp;</a></span>Cudd_ClearErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ClearErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the error code of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a988b83058c815b1ca112c6a9c74525ad" title="Returns the code of the last error.">Cudd_ReadErrorCode</a> </dd></dl>

</div>
</div>
<a id="acd5c75ae199f9383cf86cfa5d754faa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5c75ae199f9383cf86cfa5d754faa3">&#9670;&nbsp;</a></span>Cudd_Cofactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Cofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cofactor of f with respect to g. </p>
<p>g must be the BDD or the ADD of a cube.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cofactor if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a id="a86d22c9f437512fb0cc44107174f3bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d22c9f437512fb0cc44107174f3bab">&#9670;&nbsp;</a></span>Cudd_CofMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* Cudd_CofMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the fraction of minterms in the on-set of all the positive cofactors of a BDD or ADD. </p>
<p>The array has as many positions as there are BDD variables in the manager plus one. The last position of the array contains the fraction of the minterms in the ON-set of the function represented by the BDD or ADD. The other positions of the array hold the variable signatures.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to an array of doubles if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2af4867b046a794f5db312c69922790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af4867b046a794f5db312c69922790d">&#9670;&nbsp;</a></span>Cudd_CountLeaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_CountLeaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of leaves in a DD. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of leaves in the DD rooted at node if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> </dd></dl>

</div>
</div>
<a id="aa1f187be7f86701d59f924860970a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f187be7f86701d59f924860970a0b9">&#9670;&nbsp;</a></span>Cudd_CountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the minterms of an ADD or BDD. </p>
<p>The function is assumed to depend on <code>nvars</code> variables. The minterm count is represented as a double; hence overflow is possible. For functions with many variables (more than 1023 if floating point conforms to IEEE 754), one should consider <a class="el" href="cudd_8h.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm()</a> or <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of minterms of the function rooted at node if successful; +infinity if the number of minterms is known to be larger than the maximum value representable as a double; <code>(double) CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91cb9e0fde5043297b133ce6516e9a99" title="Returns the number of minterms of aa ADD or BDD as a long double.">Cudd_LdblCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882" title="Counts the paths of a DD.">Cudd_CountPath</a> </dd></dl>

</div>
</div>
<a id="a95929aeb92541971db3e5798920e6882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95929aeb92541971db3e5798920e6882">&#9670;&nbsp;</a></span>Cudd_CountPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the paths of a DD. </p>
<p>Paths to all terminal nodes are counted. The path count is represented as a double; hence overflow is possible.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node if successful; <code>(double) CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> </dd></dl>

</div>
</div>
<a id="a2b1533ac1641e3ee3260d336e863052c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1533ac1641e3ee3260d336e863052c">&#9670;&nbsp;</a></span>Cudd_CountPathsToNonZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountPathsToNonZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the paths to a non-zero terminal of a DD. </p>
<p>The path count is represented as a double; hence overflow is possible.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882" title="Counts the paths of a DD.">Cudd_CountPath</a> </dd></dl>

</div>
</div>
<a id="a88c2b80e8f71d86bd2f1db454e7fe1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c2b80e8f71d86bd2f1db454e7fe1b2">&#9670;&nbsp;</a></span>Cudd_CProjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_CProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the compatible projection of R w.r.t. cube Y. </p>
<p>Computes the compatible projection of relation R with respect to cube Y. For a comparison between Cudd_CProjection and Cudd_PrioritySelect, see the documentation of the latter.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the c-projection if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> </dd></dl>

</div>
</div>
<a id="a4ac2d2f87d831cfe727250103fc880da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac2d2f87d831cfe727250103fc880da">&#9670;&nbsp;</a></span>Cudd_CubeArrayToBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_CubeArrayToBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the BDD of a cube from a positional array. </p>
<p>The array must have one integer entry for each BDD variable. If the i-th entry is 1, the variable of index i appears in true form in the cube; If the i-th entry is 0, the variable of index i appears complemented in the cube; otherwise the variable does not appear in the cube.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the cube if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> <a class="el" href="cuddUtil_8c.html#a2815667bcad915fac2620161a577c46b" title="Builds a cube of BDD variables from an array of indices.">Cudd_IndicesToCube</a> <a class="el" href="cuddUtil_8c.html#ab53ebc58628a5a659b86025e6ed9c492" title="Builds a positional array from the BDD of a cube.">Cudd_BddToCubeArray</a> </dd></dl>

</div>
</div>
<a id="a95cf613390a7dbeaad14b3963d68de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf613390a7dbeaad14b3963d68de24">&#9670;&nbsp;</a></span>Cudd_DagSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DagSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a DD. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes in the graph rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a49d57cfc6ede9ae452a40779b58a3bac" title="Counts the number of nodes in an array of DDs.">Cudd_SharingSize</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> </dd></dl>

</div>
</div>
<a id="ae34d186620ce66627e57bbccfa24a892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34d186620ce66627e57bbccfa24a892">&#9670;&nbsp;</a></span>Cudd_DeadAreCounted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DeadAreCounted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether dead nodes are counted towards triggering reordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if dead nodes are counted; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af0b407453f68498df9b9783f88401cf5" title="Causes the dead nodes to be counted towards triggering reordering.">Cudd_TurnOnCountDead</a> <a class="el" href="cuddAPI_8c.html#a5b822894a35380ffca9e555286213484" title="Causes the dead nodes not to be counted towards triggering reordering.">Cudd_TurnOffCountDead</a> </dd></dl>

</div>
</div>
<a id="ae4784371f26794a254bcc6a2ad875b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4784371f26794a254bcc6a2ad875b5e">&#9670;&nbsp;</a></span>Cudd_DebugCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DebugCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for inconsistencies in the DD heap. </p>
<p>The following inconsistencies are checked: </p><ul>
<li>
node has illegal index </li>
<li>
live node has dead children </li>
<li>
node has illegal Then or Else pointers </li>
<li>
BDD/ADD node has identical children </li>
<li>
ZDD node has zero then child </li>
<li>
wrong number of total nodes </li>
<li>
wrong number of dead nodes </li>
<li>
ref count error at node </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 if no inconsistencies are found; DD_OUT_OF_MEM if there is not enough memory; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCheck_8c.html#a081e08d440a7ca8b7406e79b25dfaef5" title="Checks for several conditions that should not occur.">Cudd_CheckKeys</a> </dd></dl>

</div>
</div>
<a id="a66a70b011fca8b95fbc3953e8b1be1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a70b011fca8b95fbc3953e8b1be1fe">&#9670;&nbsp;</a></span>Cudd_Decreasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Decreasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a BDD is negative unate in a variable. </p>
<p>Determines whether the function represented by BDD f is negative unate (monotonic decreasing) in variable i. This function does not generate any new nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>the constant one is f is unate and the (logical) constant zero if it is not.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a4f87b23df844d48727ee53f75d868be6" title="Checks whether a BDD is positive unate in a variable.">Cudd_Increasing</a> </dd></dl>

</div>
</div>
<a id="afe8587ef00c2f8e947d5d78f98a5f4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8587ef00c2f8e947d5d78f98a5f4e7">&#9670;&nbsp;</a></span>Cudd_DelayedDerefBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_DelayedDerefBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count of BDD node n. </p>
<p>Enqueues node n for later dereferencing. If the queue is full decreases the reference count of the oldest node N to make room for n. If N dies, recursively decreases the reference counts of its children. It is used to dispose of a BDD that is currently not needed, but may be useful again in the near future. The dereferencing proper is done as in Cudd_IterDerefBdd.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a0944d022761660bf481167b78759f599" title="Decreases the reference count of node n.">Cudd_RecursiveDeref</a> <a class="el" href="cuddRef_8c.html#a15905d5750b5f2f948329ce0f67a0fc8" title="Decreases the reference count of BDD node n.">Cudd_IterDerefBdd</a> </dd></dl>

</div>
</div>
<a id="a31d6258d2a451f8d852941de13d623dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d6258d2a451f8d852941de13d623dc">&#9670;&nbsp;</a></span>Cudd_Density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_Density </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the density of a BDD or ADD. </p>
<p>The density is the ratio of the number of minterms to the number of nodes. If 0 is passed as number of variables, the number of variables existing in the manager is used.</p>
<dl class="section return"><dt>Returns</dt><dd>the density if successful; (double) CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function whose density is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>size of the support of f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1878b826a0a318e816d419ca5bcea97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1878b826a0a318e816d419ca5bcea97b">&#9670;&nbsp;</a></span>Cudd_Deref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_Deref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count of node. </p>
<p>It is primarily used in recursive procedures to decrease the ref count of a result node before returning it. This accomplishes the goal of removing the protection applied by a previous Cudd_Ref.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a0944d022761660bf481167b78759f599" title="Decreases the reference count of node n.">Cudd_RecursiveDeref</a> <a class="el" href="cuddRef_8c.html#a08641a3718655a85000069cc58cdd172" title="Decreases the reference count of ZDD node n.">Cudd_RecursiveDerefZdd</a> <a class="el" href="cuddRef_8c.html#a3d0d9959640235fc073699c776914fca" title="Increases the reference count of a node, if it is not saturated.">Cudd_Ref</a> </dd></dl>

</div>
</div>
<a id="ab1def55437ab00e012fba1a98bc3a941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1def55437ab00e012fba1a98bc3a941">&#9670;&nbsp;</a></span>Cudd_DisableGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_DisableGarbageCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables garbage collection. </p>
<p>Garbage collection is initially enabled. This function may be called to disable it. However, garbage collection will still occur when a new node must be created and no memory is left, or when garbage collection is required for correctness. (E.g., before reordering.)</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a95a5511bcc805af71fc1fb5abba96f1e" title="Enables garbage collection.">Cudd_EnableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#adf441cdb56f24a9e3e20f6e87cc571c8" title="Tells whether garbage collection is enabled.">Cudd_GarbageCollectionEnabled</a> </dd></dl>

</div>
</div>
<a id="a1363eeb294a402d754f142c2022d4562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1363eeb294a402d754f142c2022d4562">&#9670;&nbsp;</a></span>Cudd_DisableOrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DisableOrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables monitoring of ordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Removes functions from the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa547783b2cd3e54062864543fba0de" title="Enables monitoring of ordering.">Cudd_EnableOrderingMonitoring</a> </dd></dl>

</div>
</div>
<a id="a249298e38710246ab1ead014cfe54dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249298e38710246ab1ead014cfe54dd9">&#9670;&nbsp;</a></span>Cudd_DisableReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DisableReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables reporting of reordering stats. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Removes functions from the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a4a634a339969d6d84e3db858f3f77be4" title="Returns 1 if reporting of reordering stats is enabled; 0 otherwise.">Cudd_ReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="a0d01be53f7cf9bb538d67aec6a576288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d01be53f7cf9bb538d67aec6a576288">&#9670;&nbsp;</a></span>Cudd_Disequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Disequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function x - y != c. </p>
<p>This function generates a BDD for the function x -y != c. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The BDD is built bottom-up. It has a linear number of nodes if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x and y variables </td></tr>
    <tr><td class="paramname">c</td><td>right-hand side constant </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c08d26e1d5f2d7e2bc0011b36b3b5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c08d26e1d5f2d7e2bc0011b36b3b5bc">&#9670;&nbsp;</a></span>Cudd_DumpBlif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpBlif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a blif file representing the argument BDDs. </p>
<p>Each BDD is written as a network of multiplexers. Cudd_DumpBlif does not close the file: This is the caller responsibility. Cudd_DumpBlif uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory, file system full, or an ADD with constants different from 0 and 1).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a835ff0352975be7c9f4da9c69340c4ab" title="Writes a blif body representing the argument BDDs.">Cudd_DumpBlifBody</a> <a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">mname</td><td>model name (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
    <tr><td class="paramname">mv</td><td>0: blif, 1: blif-MV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a835ff0352975be7c9f4da9c69340c4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835ff0352975be7c9f4da9c69340c4ab">&#9670;&nbsp;</a></span>Cudd_DumpBlifBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpBlifBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a blif body representing the argument BDDs. </p>
<p>Each BDD is written as a network of multiplexers. No header (.model, .inputs, and .outputs) and footer (.end) are produced by this function. One multiplexer is written for each BDD node. Cudd_DumpBlifBody does not close the file: This is the caller responsibility. Cudd_DumpBlifBody uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. This function prints out only .names part.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory, file system full, or an ADD with constants different from 0 and 1).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
    <tr><td class="paramname">mv</td><td>0: blif, 1: blif-MV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47caf9418e7518e24bccc79fca1bbbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47caf9418e7518e24bccc79fca1bbbe1">&#9670;&nbsp;</a></span>Cudd_DumpDaVinci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpDaVinci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a daVinci file representing the argument BDDs. </p>
<p>Writes a daVinci file representing the argument BDDs. Cudd_DumpDaVinci does not close the file: This is the caller responsibility. Cudd_DumpDaVinci uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory or file system full).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19d7d833ebc018dee098de99271aa16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7d833ebc018dee098de99271aa16a">&#9670;&nbsp;</a></span>Cudd_DumpDDcal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpDDcal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a DDcal file representing the argument BDDs. </p>
<p>Writes a DDcal file representing the argument BDDs. Cudd_DumpDDcal does not close the file: This is the caller responsibility. Cudd_DumpDDcal uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory or file system full).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dfdcf8b654eec068f30275ff3f3e1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfdcf8b654eec068f30275ff3f3e1b6">&#9670;&nbsp;</a></span>Cudd_DumpDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a dot file representing the argument DDs. </p>
<p>Writes a file representing the argument DDs in a format suitable for the graph drawing program dot. Cudd_DumpDot does not close the file: This is the caller responsibility. Cudd_DumpDot uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. Cudd_DumpDot uses the following convention to draw arcs: </p><ul>
<li>
solid line: THEN arcs; </li>
<li>
dotted line: complement arcs; </li>
<li>
dashed line: regular ELSE arcs. </li>
</ul>
<p>The dot options are chosen so that the drawing fits on a letter-size sheet.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory, file system full).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ecc4c06d659702717cee07a5501145e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecc4c06d659702717cee07a5501145e">&#9670;&nbsp;</a></span>Cudd_DumpFactoredForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DumpFactoredForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes factored forms representing the argument BDDs. </p>
<p>Writes factored forms representing the argument BDDs. The format of the factored form is the one used in the genlib files for technology mapping in sis. Cudd_DumpFactoredForm does not close the file: This is the caller responsibility. Caution must be exercised because a factored form may be exponentially larger than the argument BDD. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. If the number of output nodes is 0, it is interpreted as 1, but no output name followed by equal sign is printed before the factored form.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., file system full).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ee4055f67c91825ec6edbea00ce9f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee4055f67c91825ec6edbea00ce9f83">&#9670;&nbsp;</a></span>Cudd_Dxygtdxz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Dxygtdxz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function d(x,y) &gt; d(x,z). </p>
<p>This function generates a BDD for the function d(x,y) &gt; d(x,z); x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0] z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is defined as: <img class="formulaInl" alt="$\sum_{i=0}^{N-1}(|x_i - y_i| \cdot 2^{N-i-1})$" src="form_0.png"/>. The BDD is built bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> <a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> <a class="el" href="cuddCompose_8c.html#a6e976b573531badb9a023f86dcdbeb40" title="Rearranges a set of variables in the BDD B.">Cudd_bddAdjPermuteX</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x, y, and z variables </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
    <tr><td class="paramname">z</td><td>array of z variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab118ad9c8350d51d5ce1b824db5423fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab118ad9c8350d51d5ce1b824db5423fd">&#9670;&nbsp;</a></span>Cudd_Dxygtdyz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Dxygtdyz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function d(x,y) &gt; d(y,z). </p>
<p>This function generates a BDD for the function d(x,y) &gt; d(y,z); x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0] z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is defined as: <img class="formulaInl" alt="$\sum_{i=0}^{N-1}(|x_i - y_i| \cdot 2^{N-i-1})$" src="form_0.png"/>. The BDD is built bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> <a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> <a class="el" href="cuddCompose_8c.html#a6e976b573531badb9a023f86dcdbeb40" title="Rearranges a set of variables in the BDD B.">Cudd_bddAdjPermuteX</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x, y, and z variables </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
    <tr><td class="paramname">z</td><td>array of z variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601a736699b3e5c8eb7149e6049ea131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601a736699b3e5c8eb7149e6049ea131">&#9670;&nbsp;</a></span>Cudd_E()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_E </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the else child of an internal node. </p>
<p>If <code>node</code> is a constant node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aeed52f5319f877acc6ac7c27490111b6" title="Returns the then child of an internal node.">Cudd_T</a> <a class="el" href="cuddAPI_8c.html#a9ebe62ac5ac8a49dc13bce839ae09c88" title="Returns the value of a constant node.">Cudd_V</a> </dd></dl>

</div>
</div>
<a id="a95a5511bcc805af71fc1fb5abba96f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a5511bcc805af71fc1fb5abba96f1e">&#9670;&nbsp;</a></span>Cudd_EnableGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_EnableGarbageCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables garbage collection. </p>
<p>Garbage collection is initially enabled. Therefore it is necessary to call this function only if garbage collection has been explicitly disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab1def55437ab00e012fba1a98bc3a941" title="Disables garbage collection.">Cudd_DisableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#adf441cdb56f24a9e3e20f6e87cc571c8" title="Tells whether garbage collection is enabled.">Cudd_GarbageCollectionEnabled</a> </dd></dl>

</div>
</div>
<a id="a6aa547783b2cd3e54062864543fba0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa547783b2cd3e54062864543fba0de">&#9670;&nbsp;</a></span>Cudd_EnableOrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EnableOrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables monitoring of ordering. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Installs functions in the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="adfe5374e85cf3fb0827307b1e3cc5e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe5374e85cf3fb0827307b1e3cc5e07">&#9670;&nbsp;</a></span>Cudd_EnableReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EnableReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables reporting of reordering stats. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Installs functions in the pre-reordering and post-reordering</dt><dd>hooks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a249298e38710246ab1ead014cfe54dd9" title="Disables reporting of reordering stats.">Cudd_DisableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a4a634a339969d6d84e3db858f3f77be4" title="Returns 1 if reporting of reordering stats is enabled; 0 otherwise.">Cudd_ReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="aa5a38e134284702f2455b5454ff0ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a38e134284702f2455b5454ff0ece5">&#9670;&nbsp;</a></span>Cudd_EpdPrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EpdPrintMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the number of minterms of an ADD or BDD with extended range. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddApa_8c.html#aa30cec86f65e23284b10f288f98f2e43" title="Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithme...">Cudd_ApaPrintMintermExp</a> </dd></dl>

</div>
</div>
<a id="abe0be57ead326db49e00a51d7acf75f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0be57ead326db49e00a51d7acf75f9">&#9670;&nbsp;</a></span>Cudd_EqualSupNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EqualSupNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ADDs for equality within tolerance. </p>
<p>Two ADDs are reported to be equal if the maximum difference between them (the sup norm of their difference) is less than or equal to the tolerance parameter. If parameter <code>pr</code> is positive the first failure is reported to the standard output.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the two ADDs are equal (within tolerance); 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first ADD </td></tr>
    <tr><td class="paramname">g</td><td>second ADD </td></tr>
    <tr><td class="paramname">tolerance</td><td>maximum allowed difference </td></tr>
    <tr><td class="paramname">pr</td><td>verbosity level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e078600dd9087c623e1bdfea00d599d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e078600dd9087c623e1bdfea00d599d">&#9670;&nbsp;</a></span>Cudd_EquivDC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EquivDC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether F and G are identical wherever D is 0. </p>
<p>F and G are either two ADDs or two BDDs. D is either a 0-1 ADD or a BDD. No new nodes are created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if F and G are equivalent, and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a5dcbf450b32f6937bc6dba252474638d" title="Tells whether f is less than of equal to G unless D is 1.">Cudd_bddLeqUnless</a> </dd></dl>

</div>
</div>
<a id="a3a3de83b78306f45ce8ea65c2fd15122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3de83b78306f45ce8ea65c2fd15122">&#9670;&nbsp;</a></span>Cudd_EstimateCofactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EstimateCofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of nodes in a cofactor of a DD. </p>
<p>This function uses a refinement of the algorithm of Cabodi et al. (ICCAD96). The refinement allows the procedure to account for part of the recombination that may occur in the part of the cofactor above the cofactoring variable. This procedure does not create any new node. It does keep a small table of results; therefore it may run out of memory. If this is a concern, one should use Cudd_EstimateCofactorSimple, which is faster, does not allocate any memory, but is less accurate.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of nodes in a cofactor of the graph rooted at node with respect to the variable whose index is i. In case of failure, returns CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> <a class="el" href="cuddUtil_8c.html#a3e23b2111b9f214571866c6e88035a9d" title="Estimates the number of nodes in a cofactor of a DD.">Cudd_EstimateCofactorSimple</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">i</td><td>index of variable </td></tr>
    <tr><td class="paramname">phase</td><td>1: positive; 0: negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e23b2111b9f214571866c6e88035a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23b2111b9f214571866c6e88035a9d">&#9670;&nbsp;</a></span>Cudd_EstimateCofactorSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EstimateCofactorSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of nodes in a cofactor of a DD. </p>
<p>Returns an estimate of the number of nodes in the positive cofactor of the graph rooted at node with respect to the variable whose index is i. This procedure implements with minor changes the algorithm of Cabodi et al. (ICCAD96). It does not allocate any memory, it does not change the state of the manager, and it is fast. However, it has been observed to overestimate the size of the cofactor by as much as a factor of 2.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>

</div>
</div>
<a id="a0f11262fedecf0c0f4376432b478e6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f11262fedecf0c0f4376432b478e6e8">&#9670;&nbsp;</a></span>Cudd_Eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a DD for a given variable assignment. </p>
<p>The variable assignment is passed in an array of int's, that should specify a zero or a one for each variable in the support of the function.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a constant node. No new nodes are produced.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>

</div>
</div>
<a id="a31d06c2608e7c5b08b3fd6c6e200662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d06c2608e7c5b08b3fd6c6e200662f">&#9670;&nbsp;</a></span>Cudd_ExpectedUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ExpectedUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the expected fraction of used slots in the unique table. </p>
<p>This expected value is based on the assumption that the hash function distributes the keys randomly; it can be compared with the result of Cudd_ReadUsedSlots to monitor the performance of the unique table hash function.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3787560300153655851b4fe3c7646b0c" title="Returns the total number of slots of the unique table.">Cudd_ReadSlots</a> <a class="el" href="cuddAPI_8c.html#a0941cb7338ba1a71f3451f4c2a747093" title="Reads the fraction of used slots in the unique table.">Cudd_ReadUsedSlots</a> </dd></dl>

</div>
</div>
<a id="a045101a55bae5da1745e2dafed1d4e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045101a55bae5da1745e2dafed1d4e97">&#9670;&nbsp;</a></span>Cudd_FactoredFormString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cudd_FactoredFormString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with the factored form of the argument BDDs. </p>
<p>The factored form uses &amp; for conjunction, | for disjunction and ! for negation. Caution must be exercised because a factored form may be exponentially larger than the argument BDD. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs.</p>
<dl class="section return"><dt>Returns</dt><dd>a string in case of success; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddExport_8c.html#a1c08d26e1d5f2d7e2bc0011b36b3b5bc" title="Writes a blif file representing the argument BDDs.">Cudd_DumpBlif</a> <a class="el" href="cuddExport_8c.html#a47caf9418e7518e24bccc79fca1bbbe1" title="Writes a daVinci file representing the argument BDDs.">Cudd_DumpDaVinci</a> <a class="el" href="cuddExport_8c.html#a19d7d833ebc018dee098de99271aa16a" title="Writes a DDcal file representing the argument BDDs.">Cudd_DumpDDcal</a> <a class="el" href="cuddExport_8c.html#a4ecc4c06d659702717cee07a5501145e" title="Writes factored forms representing the argument BDDs.">Cudd_DumpFactoredForm</a> </dd></dl>

</div>
</div>
<a id="a4615437702b72ce2d5d4b25e8f2e3bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4615437702b72ce2d5d4b25e8f2e3bbc">&#9670;&nbsp;</a></span>Cudd_FindEssential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_FindEssential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the essential variables of a DD. </p>
<p>Returns the cube of the essential variables. A positive literal means that the variable must be set to 1 for the function to be</p><ol type="1">
<li>A negative literal means that the variable must be set to 0 for the function to be 1.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cube BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddEssent_8c.html#a705c1545f9efe374d475c99a9110803c" title="Determines whether a given variable is essential with a given phase in a BDD.">Cudd_bddIsVarEssential</a> </dd></dl>

</div>
</div>
<a id="a443f012688629072a193cbf7639d20f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443f012688629072a193cbf7639d20f5">&#9670;&nbsp;</a></span>Cudd_FindTwoLiteralClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdTlcInfo.html">DdTlcInfo</a>* Cudd_FindTwoLiteralClauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the two literal clauses of a DD. </p>
<p>Returns the one- and two-literal clauses of a DD. For a constant DD, the empty set of clauses is returned. This is obviously correct for a non-zero constant. For the constant zero, it is based on the assumption that only those clauses containing variables in the support of the function are considered. Since the support of a constant function is empty, no clauses are returned.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the structure holding the clauses if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddEssent_8c.html#a4615437702b72ce2d5d4b25e8f2e3bbc" title="Finds the essential variables of a DD.">Cudd_FindEssential</a> </dd></dl>

</div>
</div>
<a id="a139d8dd64955ecf3e2fd4c5d6ceeebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139d8dd64955ecf3e2fd4c5d6ceeebb4">&#9670;&nbsp;</a></span>Cudd_FirstCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first cube of a decision diagram. </p>
<p>Defines an iterator on the onset of a decision diagram and finds its first cube.</p>
<p>A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a disjoint cover of the function associated with the diagram. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.</p>
<p>For each cube, a value is also returned. This value is always 1 for a BDD, while it may be different from 1 for an ADD. For BDDs, the offset is the set of cubes whose value is the logical zero. For ADDs, the offset is the set of cubes whose value is the background value. The cubes of the offset are not enumerated.</p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first cube and its value are returned as side effects.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> </dd></dl>

</div>
</div>
<a id="a0cbbad0f18b5767a4924ff6b069bbc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbbad0f18b5767a4924ff6b069bbc7f">&#9670;&nbsp;</a></span>Cudd_FirstNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first node of a decision diagram. </p>
<p>Defines an iterator on the nodes of a decision diagram and finds its first node. The nodes are enumerated in a reverse topological order, so that a node is always preceded in the enumeration by its descendants.</p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first node is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> </dd></dl>

</div>
</div>
<a id="a65691b560210512cf1f8d92f0c1ece9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65691b560210512cf1f8d92f0c1ece9a">&#9670;&nbsp;</a></span>Cudd_FirstPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first prime of a Boolean function. </p>
<p>Defines an iterator on a pair of BDDs describing a (possibly incompletely specified) Boolean functions and finds the first cube of a cover of the function.</p>
<p>The two argument BDDs are the lower and upper bounds of an interval. It is a mistake to call this function with a lower bound that is not less than or equal to the upper bound.</p>
<p>A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a prime and irredundant cover of the function associated with the two BDDs. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.</p>
<p>This iterator can only be used on BDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first cube is returned as side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a6b1ce1bc5df95326f9eabcfeca1e7ded" title="Iterates over the primes of a Boolean function.">Cudd_ForeachPrime</a> <a class="el" href="cuddUtil_8c.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73" title="Generates the next prime of a Boolean function.">Cudd_NextPrime</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> </dd></dl>

</div>
</div>
<a id="a551741844918bc505f84d11613814660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551741844918bc505f84d11613814660">&#9670;&nbsp;</a></span>Cudd_FreeApaNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_FreeApaNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an arbitrary precision integer. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#ac45962862c26d56dc134d2e76062ec96" title="Allocates memory for an arbitrary precision integer.">Cudd_NewApaNumber</a> </dd></dl>

</div>
</div>
<a id="adf441cdb56f24a9e3e20f6e87cc571c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf441cdb56f24a9e3e20f6e87cc571c8">&#9670;&nbsp;</a></span>Cudd_GarbageCollectionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_GarbageCollectionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether garbage collection is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if garbage collection is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a95a5511bcc805af71fc1fb5abba96f1e" title="Enables garbage collection.">Cudd_EnableGarbageCollection</a> <a class="el" href="cuddAPI_8c.html#ab1def55437ab00e012fba1a98bc3a941" title="Disables garbage collection.">Cudd_DisableGarbageCollection</a> </dd></dl>

</div>
</div>
<a id="aa16a8509f9959aff3a0c553a0427e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16a8509f9959aff3a0c553a0427e656">&#9670;&nbsp;</a></span>Cudd_GenFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_GenFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a CUDD generator. </p>
<dl class="section return"><dt>Returns</dt><dd>always 0.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> </dd></dl>

</div>
</div>
<a id="a333169d352f3ab54002eaae738a39d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333169d352f3ab54002eaae738a39d68">&#9670;&nbsp;</a></span>Cudd_IncreaseTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_IncreaseTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>increase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the time limit for the manager. </p>
<p>The time increase must be expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a4f87b23df844d48727ee53f75d868be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87b23df844d48727ee53f75d868be6">&#9670;&nbsp;</a></span>Cudd_Increasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Increasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a BDD is positive unate in a variable. </p>
<p>Determines whether the function represented by BDD f is positive unate (monotonic increasing) in variable i. It is based on Cudd_Decreasing and the fact that f is monotonic increasing in i if and only if its complement is monotonic decreasing in i.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a66a70b011fca8b95fbc3953e8b1be1fe" title="Checks whether a BDD is negative unate in a variable.">Cudd_Decreasing</a> </dd></dl>

</div>
</div>
<a id="a2815667bcad915fac2620161a577c46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2815667bcad915fac2620161a577c46b">&#9670;&nbsp;</a></span>Cudd_IndicesToCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_IndicesToCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a cube of BDD variables from an array of indices. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> <a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="ae74aaf027fda040d4d484ff970f370eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74aaf027fda040d4d484ff970f370eb">&#9670;&nbsp;</a></span>Cudd_Inequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Inequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function x - y &ge; c. </p>
<p>This function generates a BDD for the function x -y &ge; c. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The BDD is built bottom-up. It has a linear number of nodes if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x and y variables </td></tr>
    <tr><td class="paramname">c</td><td>right-hand side constant </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45075f018d4c680c12573bbd1c44ddb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45075f018d4c680c12573bbd1c44ddb9">&#9670;&nbsp;</a></span>Cudd_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdManager.html">DdManager</a>* Cudd_Init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numVarsZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSlots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxMemory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> manager. </p>
<p>Initializes the table, the basic constants and the projection functions. If maxMemory is 0, Cudd_Init decides suitable values for the maximum size of the cache and for the limit for fast unique table growth based on the available memory.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the manager if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddInit_8c.html#a2889ace3fcf7d4e00915de52554fd475" title="Deletes resources associated with a DD manager.">Cudd_Quit</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVars</td><td>initial number of BDD variables (i.e., subtables) </td></tr>
    <tr><td class="paramname">numVarsZ</td><td>initial number of ZDD variables (i.e., subtables) </td></tr>
    <tr><td class="paramname">numSlots</td><td>initial size of the unique tables </td></tr>
    <tr><td class="paramname">cacheSize</td><td>initial size of the cache </td></tr>
    <tr><td class="paramname">maxMemory</td><td>target maximum memory occupation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8941f373e5e1156b2e42af09f4247d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8941f373e5e1156b2e42af09f4247d47">&#9670;&nbsp;</a></span>Cudd_InstallOutOfMemoryHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> Cudd_InstallOutOfMemoryHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td>
          <td class="paramname"><em>newHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a handler for failed memory allocations. </p>
<p>Changing the handler only has an effect if the wrappers in <a class="el" href="safe__mem_8c.html" title="Interface routines to be placed between a program and the system memory allocator.">safe_mem.c</a> are in use.</p>
<dl class="section return"><dt>Returns</dt><dd>the current handler. </dd></dl>

</div>
</div>
<a id="a018bdc54a42aacf14959f83cbf6992b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018bdc54a42aacf14959f83cbf6992b6">&#9670;&nbsp;</a></span>Cudd_IsConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if the node is a constant node. </p>
<p>A constant node is not an internal node. The pointer passed to Cudd_IsConstant may be either regular or complemented.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a46290c6915c9d64fbe24a3faf40ced5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46290c6915c9d64fbe24a3faf40ced5d">&#9670;&nbsp;</a></span>Cudd_IsGenEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsGenEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the status of a generator. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the generator is empty or NULL; 0 otherswise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> </dd></dl>

</div>
</div>
<a id="a55eb04332db0a87f173b7638080ec856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eb04332db0a87f173b7638080ec856">&#9670;&nbsp;</a></span>Cudd_IsInHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsInHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a function is in a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the function is found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6884f064de544463f006f9104e4afa74" title="Adds a function to a hook.">Cudd_AddHook</a> <a class="el" href="cuddAPI_8c.html#a0c732be4af510054662cd6e6f0a5772f" title="Removes a function from a hook.">Cudd_RemoveHook</a> </dd></dl>

</div>
</div>
<a id="a4ac0cf7ba2eba7a6652a886deb4723fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac0cf7ba2eba7a6652a886deb4723fa">&#9670;&nbsp;</a></span>Cudd_IsNonConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsNonConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if a DD node is not constant. </p>
<p>This function is useful to test the results of Cudd_bddIteConstant, Cudd_addIteConstant, Cudd_addEvalConst. These results may be a special value signifying non-constant. In the other cases Cudd_IsConstant can be used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a018bdc54a42aacf14959f83cbf6992b6" title="Returns 1 if the node is a constant node.">Cudd_IsConstant</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>

</div>
</div>
<a id="a15905d5750b5f2f948329ce0f67a0fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15905d5750b5f2f948329ce0f67a0fc8">&#9670;&nbsp;</a></span>Cudd_IterDerefBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_IterDerefBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count of BDD node n. </p>
<p>If n dies, recursively decreases the reference counts of its children. It is used to dispose of a BDD that is no longer needed. It is more efficient than Cudd_RecursiveDeref, but it cannot be used on ADDs. The greater efficiency comes from being able to assume that no constant node will ever die as a result of a call to this procedure.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a0944d022761660bf481167b78759f599" title="Decreases the reference count of node n.">Cudd_RecursiveDeref</a> <a class="el" href="cuddRef_8c.html#afe8587ef00c2f8e947d5d78f98a5f4e7" title="Decreases the reference count of BDD node n.">Cudd_DelayedDerefBdd</a> </dd></dl>

</div>
</div>
<a id="a5722a5bf76d99cd30783ad87ba03bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5722a5bf76d99cd30783ad87ba03bf96">&#9670;&nbsp;</a></span>Cudd_LargestCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_LargestCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a largest cube in a DD. </p>
<p>f is the DD we want to get the largest cube for. The problem is translated into the one of finding a shortest path in f, when both THEN and ELSE arcs are assumed to have unit length. This yields a largest cube in the disjoint cover corresponding to the DD. Therefore, it is not necessarily the largest implicant of f.</p>
<dl class="section return"><dt>Returns</dt><dd>the largest cube as a BDD.</dd></dl>
<dl class="section user"><dt>Side effects\n The number of literals of the cube is returned in the location</dt><dd>pointed by length if it is non-null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a id="a91cb9e0fde5043297b133ce6516e9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb9e0fde5043297b133ce6516e9a99">&#9670;&nbsp;</a></span>Cudd_LdblCountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double Cudd_LdblCountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of minterms of aa ADD or BDD as a long double. </p>
<p>On systems where double and long double are the same type, <a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm()</a> is preferable. On systems where long double values have 15-bit exponents, this function avoids overflow for up to 16383 variables. It applies scaling to try to avoid overflow when the number of variables is larger than 16383, but smaller than 32764.</p>
<dl class="section return"><dt>Returns</dt><dd>The nimterm count if successful; +infinity if the number is known to be too large for representation as a long double; <code>(long double)CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddApa_8c.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm</a> </dd></dl>

</div>
</div>
<a id="a71e686dece52e90ac6bf16751ca92859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e686dece52e90ac6bf16751ca92859">&#9670;&nbsp;</a></span>Cudd_MakeBddFromZddCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_MakeBddFromZddCover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ZDD cover to a BDD. </p>
<p>Converts a ZDD cover to a BDD for the function represented by the cover.</p>
<dl class="section return"><dt>Returns</dt><dd>a BDD node if successful; otherwise it returns NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddIsop_8c.html#a2b5124feb3accdd31cfeb287ffff59f7" title="Computes an ISOP in ZDD form from BDDs.">Cudd_zddIsop</a> </dd></dl>

</div>
</div>
<a id="ac5d75e07d01a7a29c1cfd1b2fae8f4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d75e07d01a7a29c1cfd1b2fae8f4c8">&#9670;&nbsp;</a></span>Cudd_MinHammingDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_MinHammingDist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>minterm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum Hamming distance between f and minterm. </p>
<p>Returns the minimum Hamming distance between the minterms of a function f and a reference minterm. The function is given as a BDD; the minterm is given as an array of integers, one for each variable in the manager.</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum distance if it is less than the upper bound; the upper bound if the minimum distance is at least as large; CUDD_OUT_OF_MEM in case of failure.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a1a2f14258e299c507e7e4b3dbbb9af3c" title="Computes the Hamming distance ADD.">Cudd_addHamming</a> <a class="el" href="cuddPriority_8c.html#ac994164b09f82c2cd44b875fa583c60d" title="Finds a cube of f at minimum Hamming distance from the minterms of g.">Cudd_bddClosestCube</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>function to examine </td></tr>
    <tr><td class="paramname">minterm</td><td>reference minterm </td></tr>
    <tr><td class="paramname">upperBound</td><td>distance above which an approximate answer is OK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac45962862c26d56dc134d2e76062ec96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45962862c26d56dc134d2e76062ec96">&#9670;&nbsp;</a></span>Cudd_NewApaNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ace8dbc87f1aa0e0c783fa3eb20f7eeab">DdApaNumber</a> Cudd_NewApaNumber </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for an arbitrary precision integer. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a551741844918bc505f84d11613814660" title="Frees an arbitrary precision integer.">Cudd_FreeApaNumber</a> </dd></dl>

</div>
</div>
<a id="a05f1698806d45eaba7f4a5721dd5c3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1698806d45eaba7f4a5721dd5c3c8">&#9670;&nbsp;</a></span>Cudd_NextCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the next cube of a decision diagram onset. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cube and its value are returned as side effects. The</dt><dd>generator is modified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> </dd></dl>

</div>
</div>
<a id="a627f04ddcd448e741233d5bc16562171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f04ddcd448e741233d5bc16562171">&#9670;&nbsp;</a></span>Cudd_NextNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next node of a decision diagram. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The next node is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> </dd></dl>

</div>
</div>
<a id="ae9c8ccb352d96ca9bde4ab97a1ee8e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c8ccb352d96ca9bde4ab97a1ee8e73">&#9670;&nbsp;</a></span>Cudd_NextPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the next prime of a Boolean function. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cube and is returned as side effects. The</dt><dd>generator is modified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a6b1ce1bc5df95326f9eabcfeca1e7ded" title="Iterates over the primes of a Boolean function.">Cudd_ForeachPrime</a> <a class="el" href="cuddUtil_8c.html#a65691b560210512cf1f8d92f0c1ece9a" title="Finds the first prime of a Boolean function.">Cudd_FirstPrime</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> </dd></dl>

</div>
</div>
<a id="a53c38a74f4362bd57bcb44593a3f515d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c38a74f4362bd57bcb44593a3f515d">&#9670;&nbsp;</a></span>Cudd_NodeReadIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_NodeReadIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the node. </p>
<p>The node pointer can be either regular or complemented.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a2c0122cc772ed6f3012bcac42fac0c0c" title="Returns the current position in the order of variable index.">Cudd_ReadIndex</a> </dd></dl>

</div>
</div>
<a id="a93d721c40b8c47401a0739027cf5a571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d721c40b8c47401a0739027cf5a571">&#9670;&nbsp;</a></span>Cudd_OrderingMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_OrderingMonitoring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if monitoring of ordering is enabled; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa547783b2cd3e54062864543fba0de" title="Enables monitoring of ordering.">Cudd_EnableOrderingMonitoring</a> <a class="el" href="cuddAPI_8c.html#a1363eeb294a402d754f142c2022d4562" title="Disables monitoring of ordering.">Cudd_DisableOrderingMonitoring</a> </dd></dl>

</div>
</div>
<a id="a77cf07a23729b7f2621c74bf1e2ff830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cf07a23729b7f2621c74bf1e2ff830">&#9670;&nbsp;</a></span>Cudd_OutOfMem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_OutOfMem </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warns that a memory allocation failed. </p>
<p>This function can be used as replacement of MMout_of_memory to prevent the safe_mem functions of the util package from exiting when malloc returns NULL. One possible use is in case of discretionary allocations; for instance, an allocation of memory to enlarge the computed table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> <a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the allocation that failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6e655bc7b71ea719534f40fb8faa393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e655bc7b71ea719534f40fb8faa393">&#9670;&nbsp;</a></span>Cudd_OutOfMemSilent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_OutOfMemSilent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Doesn not warn that a memory allocation failed. </p>
<p>This function can be used as replacement of MMout_of_memory to prevent the safe_mem functions of the util package from exiting when malloc returns NULL. One possible use is in case of discretionary allocations; for instance, an allocation of memory to enlarge the computed table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the allocation that failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e725e579f19ac3e946c04cfdde95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e725e579f19ac3e946c04cfdde95f0">&#9670;&nbsp;</a></span>Cudd_OverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_OverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with Shiple's underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405445d35a7c41877fe916f6dfa11472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405445d35a7c41877fe916f6dfa11472">&#9670;&nbsp;</a></span>Cudd_Prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_Prime </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next prime &ge; p. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a1e46a1b9147411ce547a2e03305d6c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e46a1b9147411ce547a2e03305d6c22">&#9670;&nbsp;</a></span>Cudd_PrintDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to the manager standard output a DD and its statistics. </p>
<p>The statistics include the number of nodes, the number of leaves, and the number of minterms. (The number of minterms is the number of assignments to the variables that cause the function to be different from the logical zero (for BDDs) and from the background value (for ADDs.) The statistics are printed if pr &gt; 0. Specifically: </p><ul>
<li>
pr = 0 : prints nothing </li>
<li>
pr = 1 : prints counts of nodes and minterms </li>
<li>
pr = 2 : prints counts + disjoint sum of product </li>
<li>
pr = 3 : prints counts + list of nodes </li>
<li>
pr &gt; 3 : prints counts + disjoint sum of product + list of nodes </li>
</ul>
<p>For the purpose of counting the number of minterms, the function is supposed to depend on n variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> <a class="el" href="cuddUtil_8c.html#a2af4867b046a794f5db312c69922790d" title="Counts the number of leaves in a DD.">Cudd_CountLeaves</a> <a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#aeab82cceadafa2b81083e0467c102526" title="Prints a disjoint sum of products.">Cudd_PrintMinterm</a> </dd></dl>

</div>
</div>
<a id="aba970524139c009227b2fa0fc8cac0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba970524139c009227b2fa0fc8cac0eb">&#9670;&nbsp;</a></span>Cudd_PrintGroupedOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintGroupedOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook function to print the current variable order. </p>
<p>It may be called before or after reordering. Prints on the manager's stdout a parenthesized list that describes the variable groups.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a852da7502c07042fde873b504aaa4573" title="Sample hook function to call before reordering.">Cudd_StdPreReordHook</a> </dd></dl>

</div>
</div>
<a id="a0883e74086d9f61c2988ba614e9e649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0883e74086d9f61c2988ba614e9e649e">&#9670;&nbsp;</a></span>Cudd_PrintInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints out statistics and settings for a CUDD manager. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="afbb45adfdbde035d439271377f68a098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb45adfdbde035d439271377f68a098">&#9670;&nbsp;</a></span>Cudd_PrintLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintLinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the linear transform matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="aeab82cceadafa2b81083e0467c102526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab82cceadafa2b81083e0467c102526">&#9670;&nbsp;</a></span>Cudd_PrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a disjoint sum of products. </p>
<p>Prints a disjoint sum of product cover for the function rooted at node. Each product corresponds to a path from node to a leaf node different from the logical zero, and different from the background value. Uses the package default output file.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddUtil_8c.html#a8b61fadaf6046697691b35fad8c9faf0" title="Prints a sum of prime implicants of a BDD.">Cudd_bddPrintCover</a> </dd></dl>

</div>
</div>
<a id="ac610821afa1bb9ad8432a3c656eb81cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac610821afa1bb9ad8432a3c656eb81cd">&#9670;&nbsp;</a></span>Cudd_PrintSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintSummary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a one-line summary of an ADD or BDD to the manager stdout. </p>
<p>The summary includes the number of nodes, the number of leaves, and the number of minterms. The number of minterms is computed with arbitrary precision unlike <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug()</a>. For the purpose of counting minterms, the function <code>f</code> is supposed to depend on <code>n</code> variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddApa_8c.html#a0594a9f95c1b1935685cbf922d3d59af" title="Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic.">Cudd_ApaPrintMinterm</a> <a class="el" href="cuddApa_8c.html#aa30cec86f65e23284b10f288f98f2e43" title="Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithme...">Cudd_ApaPrintMintermExp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD to be summarized </td></tr>
    <tr><td class="paramname">n</td><td>number of variables for minterm computation </td></tr>
    <tr><td class="paramname">mode</td><td>integer (0) or exponential (1) format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a6866471a2b8da0c0faf9ee7fc79c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a6866471a2b8da0c0faf9ee7fc79c1">&#9670;&nbsp;</a></span>Cudd_PrintTwoLiteralClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintTwoLiteralClauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the one- and two-literal clauses of a DD. </p>
<p>The argument "names" can be NULL, in which case the variable indices are printed.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddEssent_8c.html#a443f012688629072a193cbf7639d20f5" title="Finds the two literal clauses of a DD.">Cudd_FindTwoLiteralClauses</a> </dd></dl>

</div>
</div>
<a id="acd64fd5ed246def2ad791e7b0ddeec2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd64fd5ed246def2ad791e7b0ddeec2b">&#9670;&nbsp;</a></span>Cudd_PrintVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_PrintVersion </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the package version number. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ab45fcda0a0e4d2cce08b955ff0964a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45fcda0a0e4d2cce08b955ff0964a98">&#9670;&nbsp;</a></span>Cudd_PrioritySelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_PrioritySelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afaac0abf7189a0db3e7ecd729c93188b">DD_PRFP</a>&#160;</td>
          <td class="paramname"><em>Pifunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects pairs from R using a priority function. </p>
<p>Selects pairs from a relation R(x,y) (given as a BDD) in such a way that a given x appears in one pair only. Uses a priority function to determine which y should be paired to a given x. Three of the arguments&ndash;x, y, and z&ndash;are vectors of BDD variables. The first two are the variables on which R depends. The third vector is a vector of auxiliary variables, used during the computation. This vector is optional. If a NULL value is passed instead, Cudd_PrioritySelect will create the working variables on the fly. The sizes of x and y (and z if it is not NULL) should equal n. The priority function Pi can be passed as a BDD, or can be built by Cudd_PrioritySelect. If NULL is passed instead of a <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> *, parameter Pifunc is used by Cudd_PrioritySelect to build a BDD for the priority function. (Pifunc is a pointer to a C function.) If Pi is not NULL, then Pifunc is ignored. Pifunc should have the same interface as the standard priority functions (e.g., Cudd_Dxygtdxz). Cudd_PrioritySelect and Cudd_CProjection can sometimes be used interchangeably. Specifically, calling Cudd_PrioritySelect with Cudd_Xgty as Pifunc produces the same result as calling Cudd_CProjection with the all-zero minterm as reference minterm. However, depending on the application, one or the other may be preferable: </p><ul>
<li>
When extracting representatives from an equivalence relation, Cudd_CProjection has the advantage of nor requiring the auxiliary variables. </li>
<li>
When computing matchings in general bipartite graphs, Cudd_PrioritySelect normally obtains better results because it can use more powerful matching schemes (e.g., Cudd_Dxygtdxz). </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the selected function if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n If called with z == NULL, will create new variables in</dt><dd>the manager.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> <a class="el" href="cuddPriority_8c.html#a931e96461db0102f8aea154caa3f516a" title="Generates a BDD for the function x &gt; y.">Cudd_Xgty</a> <a class="el" href="cuddCompose_8c.html#a6e976b573531badb9a023f86dcdbeb40" title="Rearranges a set of variables in the BDD B.">Cudd_bddAdjPermuteX</a> <a class="el" href="cuddPriority_8c.html#a88c2b80e8f71d86bd2f1db454e7fe1b2" title="Computes the compatible projection of R w.r.t. cube Y.">Cudd_CProjection</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">R</td><td>BDD of the relation </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
    <tr><td class="paramname">z</td><td>array of z variables (optional: may be NULL) </td></tr>
    <tr><td class="paramname">Pi</td><td>BDD of the priority function (optional: may be NULL) </td></tr>
    <tr><td class="paramname">n</td><td>size of x, y, and z </td></tr>
    <tr><td class="paramname">Pifunc</td><td>function used to build Pi if it is NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2889ace3fcf7d4e00915de52554fd475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2889ace3fcf7d4e00915de52554fd475">&#9670;&nbsp;</a></span>Cudd_Quit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_Quit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes resources associated with a DD manager. </p>
<p>Calling Cudd_Quit with a null pointer has no effect.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddInit_8c.html#a45075f018d4c680c12573bbd1c44ddb9" title="Creates a new DD manager.">Cudd_Init</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unique</td><td>pointer to manager </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aca63dd70f27ea0245f0c269ffff6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aca63dd70f27ea0245f0c269ffff6d1">&#9670;&nbsp;</a></span>Cudd_Random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Cudd_Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable random number generator. </p>
<p>Based on ran2 from "Numerical Recipes in C." It is a long period (&gt; 2 * 10^18) random number generator of L'Ecuyer with Bays-Durham shuffle. The random generator can be explicitly initialized by calling Cudd_Srandom. If no explicit initialization is performed, then the seed 1 is assumed.</p>
<dl class="section return"><dt>Returns</dt><dd>a long integer uniformly distributed between 0 and 2147483561 (inclusive of the endpoint values).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a20c2b03a12919a3d146c7e02b4f3e4bd" title="Initializer for the portable random number generator.">Cudd_Srandom</a> </dd></dl>

</div>
</div>
<a id="a9f98975109e7d3afd1bad0716e4d6666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f98975109e7d3afd1bad0716e4d6666">&#9670;&nbsp;</a></span>Cudd_ReadApplicationHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Cudd_ReadApplicationHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the application hook. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2d4a097e769d11868f760b920e6f1da8" title="Sets the application hook.">Cudd_SetApplicationHook</a> </dd></dl>

</div>
</div>
<a id="a89117a52be055c338311b1380d511375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89117a52be055c338311b1380d511375">&#9670;&nbsp;</a></span>Cudd_ReadArcviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadArcviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the arcviolation parameter used in group sifting. </p>
<p>This parameter is used to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3064405f352a9d93a6ee16cfa5d2512c" title="Sets the value of the arcviolation parameter used in group sifting.">Cudd_SetArcviolation</a> </dd></dl>

</div>
</div>
<a id="a041d561f9d388a943104665fe0c850c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d561f9d388a943104665fe0c850c0">&#9670;&nbsp;</a></span>Cudd_ReadBackground()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the background constant of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2281582d99df044cf8892204026b64b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2281582d99df044cf8892204026b64b9">&#9670;&nbsp;</a></span>Cudd_ReadCacheHits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheHits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of cache hits. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab4595bfefe543b3f8f74248c048b53fe" title="Returns the number of cache look-ups.">Cudd_ReadCacheLookUps</a> </dd></dl>

</div>
</div>
<a id="ab4595bfefe543b3f8f74248c048b53fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4595bfefe543b3f8f74248c048b53fe">&#9670;&nbsp;</a></span>Cudd_ReadCacheLookUps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheLookUps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of cache look-ups. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2281582d99df044cf8892204026b64b9" title="Returns the number of cache hits.">Cudd_ReadCacheHits</a> </dd></dl>

</div>
</div>
<a id="ab588943f358faadd3c7e8a4caf813fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab588943f358faadd3c7e8a4caf813fce">&#9670;&nbsp;</a></span>Cudd_ReadCacheSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadCacheSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the number of slots in the cache. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aac309a335487dbb3ba77b088c90e085c" title="Reads the fraction of used slots in the cache.">Cudd_ReadCacheUsedSlots</a> </dd></dl>

</div>
</div>
<a id="aac309a335487dbb3ba77b088c90e085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac309a335487dbb3ba77b088c90e085c">&#9670;&nbsp;</a></span>Cudd_ReadCacheUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadCacheUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the fraction of used slots in the cache. </p>
<p>The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and cache resizing may cause used slots to become unused.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab588943f358faadd3c7e8a4caf813fce" title="Reads the number of slots in the cache.">Cudd_ReadCacheSlots</a> </dd></dl>

</div>
</div>
<a id="a4074f697e7ea725a1b853d9a468a082e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4074f697e7ea725a1b853d9a468a082e">&#9670;&nbsp;</a></span>Cudd_ReadDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of dead nodes in the unique table. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5bc6805752cf0bc83080322d778759e6" title="Returns the number of nodes in the unique table.">Cudd_ReadKeys</a> </dd></dl>

</div>
</div>
<a id="ab6cafb71c46dedb3eaa27acd56b855b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cafb71c46dedb3eaa27acd56b855b8">&#9670;&nbsp;</a></span>Cudd_ReadElapsedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadElapsedTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time elapsed since the start time of the manager. </p>
<p>The time is expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="ac711d8ce9d243e16246b83e3c1f04199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac711d8ce9d243e16246b83e3c1f04199">&#9670;&nbsp;</a></span>Cudd_ReadEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> Cudd_ReadEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the epsilon parameter of the manager. </p>
<p>The epsilon parameter control the comparison between floating point numbers.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a30ef132c1f56bdb0e26efc81fa695cf3" title="Sets the epsilon parameter of the manager to ep.">Cudd_SetEpsilon</a> </dd></dl>

</div>
</div>
<a id="a988b83058c815b1ca112c6a9c74525ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988b83058c815b1ca112c6a9c74525ad">&#9670;&nbsp;</a></span>Cudd_ReadErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a27114b4342bc1b987f35d751eae2444b">Cudd_ErrorType</a> Cudd_ReadErrorCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the code of the last error. </p>
<p>The error codes are defined in <a class="el" href="cudd_8h.html" title="The University of Colorado decision diagram package.">cudd.h</a>.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aed3a189c261ed9f698ace55ade32af01" title="Clear the error code of a manager.">Cudd_ClearErrorCode</a> </dd></dl>

</div>
</div>
<a id="a50aaebdd320041ddca11fdb0f3414f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aaebdd320041ddca11fdb0f3414f0c">&#9670;&nbsp;</a></span>Cudd_ReadGarbageCollections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadGarbageCollections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times garbage collection has occurred. </p>
<p>The number includes both the calls from reordering procedures and those caused by requests to create new nodes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a653fa9231b3d68947521175de74f26b8" title="Returns the time spent in garbage collection.">Cudd_ReadGarbageCollectionTime</a> </dd></dl>

</div>
</div>
<a id="a653fa9231b3d68947521175de74f26b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653fa9231b3d68947521175de74f26b8">&#9670;&nbsp;</a></span>Cudd_ReadGarbageCollectionTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadGarbageCollectionTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time spent in garbage collection. </p>
<p>Returns the number of milliseconds spent doing garbage collection since the manager was initialized.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a50aaebdd320041ddca11fdb0f3414f0c" title="Returns the number of times garbage collection has occurred.">Cudd_ReadGarbageCollections</a> </dd></dl>

</div>
</div>
<a id="a8f2639c79f7b9c58367cbfc0f55ca3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2639c79f7b9c58367cbfc0f55ca3b5">&#9670;&nbsp;</a></span>Cudd_ReadGroupcheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a> Cudd_ReadGroupcheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the groupcheck parameter of the manager. </p>
<p>The groupcheck parameter determines the aggregation criterion in group sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aee7e7fa94656ed131aa67ca1ea15a031" title="Sets the parameter groupcheck of the manager to gc.">Cudd_SetGroupcheck</a> </dd></dl>

</div>
</div>
<a id="ae16ce73ed2e5afcd0dd1c1db43884d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ce73ed2e5afcd0dd1c1db43884d2a">&#9670;&nbsp;</a></span>Cudd_ReadInvPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadInvPerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the variable currently in the i-th position of the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> <a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> </dd></dl>

</div>
</div>
<a id="a30f47219044e26a1be7699014dcc021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f47219044e26a1be7699014dcc021a">&#9670;&nbsp;</a></span>Cudd_ReadInvPermZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadInvPermZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the ZDD variable currently in the i-th position of the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> <a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> </dd></dl>

</div>
</div>
<a id="afdc962357e00829128241006e6749692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc962357e00829128241006e6749692">&#9670;&nbsp;</a></span>Cudd_ReadIthClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadIthClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdTlcInfo.html">DdTlcInfo</a> *&#160;</td>
          <td class="paramname"><em>tlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>var1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>var2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the i-th clause of a DD. </p>
<p>Accesses the i-th clause of a DD given the clause set which must be already computed.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 if i is out of range, or in case of error.</dd></dl>
<dl class="section user"><dt>Side effects\n the four components of a clause are returned as side effects.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddEssent_8c.html#a443f012688629072a193cbf7639d20f5" title="Finds the two literal clauses of a DD.">Cudd_FindTwoLiteralClauses</a> </dd></dl>

</div>
</div>
<a id="a5bc6805752cf0bc83080322d778759e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc6805752cf0bc83080322d778759e6">&#9670;&nbsp;</a></span>Cudd_ReadKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in the unique table. </p>
<p>Returns the total number of nodes currently in the unique table, including the dead nodes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4074f697e7ea725a1b853d9a468a082e" title="Returns the number of dead nodes in the unique table.">Cudd_ReadDead</a> </dd></dl>

</div>
</div>
<a id="a474cd847607bf4afaaff49e849626585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474cd847607bf4afaaff49e849626585">&#9670;&nbsp;</a></span>Cudd_ReadLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadLinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry of the linear transform matrix. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>CUDD manager </td></tr>
    <tr><td class="paramname">x</td><td>row index </td></tr>
    <tr><td class="paramname">y</td><td>column index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd42d8cb5c86659170103a3068e13a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd42d8cb5c86659170103a3068e13a6">&#9670;&nbsp;</a></span>Cudd_ReadLogicZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadLogicZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logic zero constant of the manager. </p>
<p>The logic zero constant is the complement of the one constant, and is distinct from the arithmetic zero.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> <a class="el" href="cuddAPI_8c.html#a92900f3320df460a72eacc4ed801d69e" title="Returns the zero constant of the manager.">Cudd_ReadZero</a> </dd></dl>

</div>
</div>
<a id="ab452b9f1bbcdb8bf49cbea25f6e8ed8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452b9f1bbcdb8bf49cbea25f6e8ed8d">&#9670;&nbsp;</a></span>Cudd_ReadLooseUpTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadLooseUpTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the looseUpTo parameter of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1952bb97db9782bcf607d169c842b7ce" title="Sets the looseUpTo parameter of the manager.">Cudd_SetLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#a79695ef1e6f821d310f5613a6d8ba148" title="Reads the hit rate that causes resizinig of the computed table.">Cudd_ReadMinHit</a> <a class="el" href="cuddAPI_8c.html#ace82092e4e785b388c83f554daa23283" title="Reads the minDead parameter of the manager.">Cudd_ReadMinDead</a> </dd></dl>

</div>
</div>
<a id="a7dafbaafff7055890cce20fa791b2092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dafbaafff7055890cce20fa791b2092">&#9670;&nbsp;</a></span>Cudd_ReadMaxCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the soft limit for the cache size. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acfac0e32bb4bcfe7f0035f4fff401a0e" title="Reads the maxCacheHard parameter of the manager.">Cudd_ReadMaxCacheHard</a> </dd></dl>

</div>
</div>
<a id="acfac0e32bb4bcfe7f0035f4fff401a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfac0e32bb4bcfe7f0035f4fff401a0e">&#9670;&nbsp;</a></span>Cudd_ReadMaxCacheHard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxCacheHard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxCacheHard parameter of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4ced83212c4c45f94d8957e3fab485c5" title="Sets the maxCacheHard parameter of the manager.">Cudd_SetMaxCacheHard</a> <a class="el" href="cuddAPI_8c.html#a7dafbaafff7055890cce20fa791b2092" title="Returns the soft limit for the cache size.">Cudd_ReadMaxCache</a> </dd></dl>

</div>
</div>
<a id="a23f3600540de47d20e85eb4036af6e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f3600540de47d20e85eb4036af6e49">&#9670;&nbsp;</a></span>Cudd_ReadMaxGrowth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadMaxGrowth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxGrowth parameter of the manager. </p>
<p>This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa3a621a6133ce4203b8bfa351d5de4ea" title="Sets the maxGrowth parameter of the manager.">Cudd_SetMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> </dd></dl>

</div>
</div>
<a id="a692abb5fde2011b2a3cec010946eebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692abb5fde2011b2a3cec010946eebca">&#9670;&nbsp;</a></span>Cudd_ReadMaxGrowthAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadMaxGrowthAlternate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maxGrowthAlt parameter of the manager. </p>
<p>This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23f3600540de47d20e85eb4036af6e49" title="Reads the maxGrowth parameter of the manager.">Cudd_ReadMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="a1dbe3503e24e823a81bc2c8acb065345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbe3503e24e823a81bc2c8acb065345">&#9670;&nbsp;</a></span>Cudd_ReadMaxIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum possible index for a variable. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af6afbdb9c3955275888ec9cb60711a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afbdb9c3955275888ec9cb60711a57">&#9670;&nbsp;</a></span>Cudd_ReadMaxLive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxLive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maximum allowed number of live nodes. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac553f7975b60ebe4a38141cbff1eebea" title="Sets the maximum allowed number of live nodes.">Cudd_SetMaxLive</a> </dd></dl>

</div>
</div>
<a id="aef52798a6b7994a3038335d36ec9f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef52798a6b7994a3038335d36ec9f051">&#9670;&nbsp;</a></span>Cudd_ReadMaxMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_ReadMaxMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the maximum allowed memory. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a0d15a525874908e9230881bccabbb993" title="Sets the maximum allowed memory.">Cudd_SetMaxMemory</a> </dd></dl>

</div>
</div>
<a id="ad011aad1e779f0e31ab67cf7a1d7f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011aad1e779f0e31ab67cf7a1d7f591">&#9670;&nbsp;</a></span>Cudd_ReadMaxReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMaxReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of times reordering may be invoked. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> <a class="el" href="cuddAPI_8c.html#a3a2e39aeebc215847d374a01bb1f182b" title="Sets the maximum number of times reordering may be invoked.">Cudd_SetMaxReorderings</a> <a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> </dd></dl>

</div>
</div>
<a id="a952c97ec2d8b0a73f759e7e993e1e367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952c97ec2d8b0a73f759e7e993e1e367">&#9670;&nbsp;</a></span>Cudd_ReadMemoryInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_ReadMemoryInUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory in use by the manager measured in bytes. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ace82092e4e785b388c83f554daa23283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace82092e4e785b388c83f554daa23283">&#9670;&nbsp;</a></span>Cudd_ReadMinDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMinDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the minDead parameter of the manager. </p>
<p>The minDead parameter is used by the package to decide whether to collect garbage or resize a subtable of the unique table when the subtable becomes too full. The application can indirectly control the value of minDead by setting the looseUpTo parameter.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4074f697e7ea725a1b853d9a468a082e" title="Returns the number of dead nodes in the unique table.">Cudd_ReadDead</a> <a class="el" href="cuddAPI_8c.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d" title="Reads the looseUpTo parameter of the manager.">Cudd_ReadLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#a1952bb97db9782bcf607d169c842b7ce" title="Sets the looseUpTo parameter of the manager.">Cudd_SetLooseUpTo</a> </dd></dl>

</div>
</div>
<a id="a79695ef1e6f821d310f5613a6d8ba148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79695ef1e6f821d310f5613a6d8ba148">&#9670;&nbsp;</a></span>Cudd_ReadMinHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadMinHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the hit rate that causes resizinig of the computed table. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae96f3e2036a77ab8c1318e607dea232b" title="Sets the hit rate that causes resizinig of the computed table.">Cudd_SetMinHit</a> </dd></dl>

</div>
</div>
<a id="ae0ff7f850bf0b84af8ea0779ec0800ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff7f850bf0b84af8ea0779ec0800ac">&#9670;&nbsp;</a></span>Cudd_ReadMinusInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadMinusInfinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the minus-infinity constant from the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="adc3820fb326bce09797fda8439b5daa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3820fb326bce09797fda8439b5daa4">&#9670;&nbsp;</a></span>Cudd_ReadNextReordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadNextReordering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the threshold for the next dynamic reordering. </p>
<p>The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3d62c965eabd4ec777af47acd790ee47" title="Sets the threshold for the next dynamic reordering.">Cudd_SetNextReordering</a> </dd></dl>

</div>
</div>
<a id="a9ba2c88b8f70df51791c26ffde800fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba2c88b8f70df51791c26ffde800fc7">&#9670;&nbsp;</a></span>Cudd_ReadNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of nodes in BDDs and ADDs. </p>
<p>This number does not include the isolated projection functions and the unused constants. These nodes that are not counted are not part of the DDs manipulated by the application.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> <a class="el" href="cuddAPI_8c.html#a4c015c746d9c71fb9b57249f2a4ccd72" title="Reports the number of nodes in ZDDs.">Cudd_zddReadNodeCount</a> </dd></dl>

</div>
</div>
<a id="ae7e283a368a08c5ac96101ee7e9b525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e283a368a08c5ac96101ee7e9b525c">&#9670;&nbsp;</a></span>Cudd_ReadNodesDropped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadNodesDropped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes dropped. </p>
<p>Returns the number of nodes killed by dereferencing if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af525911b0006fddcbcf698a077b874cb" title="Returns the number of nodes freed.">Cudd_ReadNodesFreed</a> </dd></dl>

</div>
</div>
<a id="af525911b0006fddcbcf698a077b874cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af525911b0006fddcbcf698a077b874cb">&#9670;&nbsp;</a></span>Cudd_ReadNodesFreed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadNodesFreed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes freed. </p>
<p>Returns the number of nodes returned to the free list if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_STATS defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae7e283a368a08c5ac96101ee7e9b525c" title="Returns the number of nodes dropped.">Cudd_ReadNodesDropped</a> </dd></dl>

</div>
</div>
<a id="a2609fe9051be1a8ab6d305d38bfb5956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2609fe9051be1a8ab6d305d38bfb5956">&#9670;&nbsp;</a></span>Cudd_ReadNumberXovers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadNumberXovers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current number of crossovers used by the genetic algorithm for variable reordering. </p>
<p>A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae8b2c48e26b4178cf6536f4ce253d9b1" title="Sets the number of crossovers used by the genetic algorithm for variable reordering.">Cudd_SetNumberXovers</a> </dd></dl>

</div>
</div>
<a id="a2651c953d81570d3f4f794bcbef40afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651c953d81570d3f4f794bcbef40afe">&#9670;&nbsp;</a></span>Cudd_ReadOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the one constant of the manager. </p>
<p>The one constant is common to ADDs and BDDs.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a92900f3320df460a72eacc4ed801d69e" title="Returns the zero constant of the manager.">Cudd_ReadZero</a> <a class="el" href="cuddAPI_8c.html#a1dd42d8cb5c86659170103a3068e13a6" title="Returns the logic zero constant of the manager.">Cudd_ReadLogicZero</a> <a class="el" href="cuddAPI_8c.html#ad6d6950021b06a3bf4a6bcd05b1753e7" title="Returns the ZDD for the constant 1 function.">Cudd_ReadZddOne</a> </dd></dl>

</div>
</div>
<a id="a93f6c6fc1714330d1554a0f2e562ae1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f6c6fc1714330d1554a0f2e562ae1f">&#9670;&nbsp;</a></span>Cudd_ReadOrderRandomization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadOrderRandomization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the order randomization factor. </p>
<p>If non-zero this factor is used to determine a perturbation of the next reordering threshold. Larger factors cause larger perturbations.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3e58f1cfc002a5a2af126f29e7377243" title="Sets the order randomization factor.">Cudd_SetOrderRandomization</a> </dd></dl>

</div>
</div>
<a id="a120dd8ff3d2b0a4df7600a820175f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120dd8ff3d2b0a4df7600a820175f1d4">&#9670;&nbsp;</a></span>Cudd_ReadPeakLiveNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPeakLiveNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the peak number of live nodes. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> <a class="el" href="cuddAPI_8c.html#a0883e74086d9f61c2988ba614e9e649e" title="Prints out statistics and settings for a CUDD manager.">Cudd_PrintInfo</a> <a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> </dd></dl>

</div>
</div>
<a id="a39633df05be731b6b145d65f83aed572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39633df05be731b6b145d65f83aed572">&#9670;&nbsp;</a></span>Cudd_ReadPeakNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadPeakNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the peak number of nodes. </p>
<p>This number includes node on the free list. At the peak, the number of nodes on the free list is guaranteed to be less than DD_MEM_CHUNK.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> <a class="el" href="cuddAPI_8c.html#a0883e74086d9f61c2988ba614e9e649e" title="Prints out statistics and settings for a CUDD manager.">Cudd_PrintInfo</a> </dd></dl>

</div>
</div>
<a id="aacfa59899b792c9f47a612ceba42c976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa59899b792c9f47a612ceba42c976">&#9670;&nbsp;</a></span>Cudd_ReadPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current position of the i-th variable in the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae16ce73ed2e5afcd0dd1c1db43884d2a" title="Returns the index of the variable currently in the i-th position of the order.">Cudd_ReadInvPerm</a> <a class="el" href="cuddAPI_8c.html#a965c64ce6822b03441ce7445e8187aa3" title="Returns the current position of the i-th ZDD variable in the order.">Cudd_ReadPermZdd</a> </dd></dl>

</div>
</div>
<a id="a965c64ce6822b03441ce7445e8187aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965c64ce6822b03441ce7445e8187aa3">&#9670;&nbsp;</a></span>Cudd_ReadPermZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPermZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current position of the i-th ZDD variable in the order. </p>
<p>If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a30f47219044e26a1be7699014dcc021a" title="Returns the index of the ZDD variable currently in the i-th position of the order.">Cudd_ReadInvPermZdd</a> <a class="el" href="cuddAPI_8c.html#aacfa59899b792c9f47a612ceba42c976" title="Returns the current position of the i-th variable in the order.">Cudd_ReadPerm</a> </dd></dl>

</div>
</div>
<a id="af581badbfb76ba5909f83482c47d743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af581badbfb76ba5909f83482c47d743e">&#9670;&nbsp;</a></span>Cudd_ReadPlusInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadPlusInfinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the plus-infinity constant from the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a1e760e63a14cd28172b2371c8419b0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e760e63a14cd28172b2371c8419b0d9">&#9670;&nbsp;</a></span>Cudd_ReadPopulationSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadPopulationSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current size of the population used by the genetic algorithm for variable reordering. </p>
<p>A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#abbdf2ca87a414bb36bfbb6247a8915ec" title="Sets the size of the population used by the genetic algorithm for variable reordering.">Cudd_SetPopulationSize</a> </dd></dl>

</div>
</div>
<a id="ac305e7d5aaa2c3808db94795dc0a1150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac305e7d5aaa2c3808db94795dc0a1150">&#9670;&nbsp;</a></span>Cudd_ReadRecomb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadRecomb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the recombination parameter used in group sifting. </p>
<p>A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac68f934b27bc1d1ea947f410c8aedd36" title="Sets the value of the recombination parameter used in group sifting.">Cudd_SetRecomb</a> </dd></dl>

</div>
</div>
<a id="a3d8ec5d88cf36fd80006b157252be029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8ec5d88cf36fd80006b157252be029">&#9670;&nbsp;</a></span>Cudd_ReadRecursiveCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadRecursiveCalls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of recursive calls. </p>
<p>Returns the number of recursive calls if the package is compiled with DD_COUNT defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="aa5283d665223378e10425342dad1684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5283d665223378e10425342dad1684b">&#9670;&nbsp;</a></span>Cudd_ReadReorderingCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadReorderingCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the reordCycle parameter of the manager. </p>
<p>This parameter determines how often the alternate threshold on maximum growth is used in reordering.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="ac22056db7260493748eda0162431cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22056db7260493748eda0162431cd76">&#9670;&nbsp;</a></span>Cudd_ReadReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times reordering has occurred. </p>
<p>The number includes both the calls to Cudd_ReduceHeap from the application program and those automatically performed by the package. However, calls that do not even initiate reordering are not counted. A call may not initiate reordering if there are fewer than minsize live nodes in the manager, or if CUDD_REORDER_NONE is specified as reordering method. The calls to Cudd_ShuffleHeap are not counted.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> <a class="el" href="cuddAPI_8c.html#a61141274ba36755e4c88a4c1597b9847" title="Returns the time spent in reordering.">Cudd_ReadReorderingTime</a> </dd></dl>

</div>
</div>
<a id="a61141274ba36755e4c88a4c1597b9847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61141274ba36755e4c88a4c1597b9847">&#9670;&nbsp;</a></span>Cudd_ReadReorderingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_ReadReorderingTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time spent in reordering. </p>
<p>Returns the number of milliseconds spent reordering variables since the manager was initialized. The time spent in collecting garbage before reordering is included.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> </dd></dl>

</div>
</div>
<a id="a54fbfd8fa0597af542ad9dfa4eefa2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fbfd8fa0597af542ad9dfa4eefa2da">&#9670;&nbsp;</a></span>Cudd_ReadSiftMaxSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSiftMaxSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the siftMaxSwap parameter of the manager. </p>
<p>This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a112841ed78d8f90d31ee879684775b51" title="Reads the siftMaxVar parameter of the manager.">Cudd_ReadSiftMaxVar</a> <a class="el" href="cuddAPI_8c.html#a40246082da9de77243088f935be6e2e6" title="Sets the siftMaxSwap parameter of the manager.">Cudd_SetSiftMaxSwap</a> </dd></dl>

</div>
</div>
<a id="a112841ed78d8f90d31ee879684775b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112841ed78d8f90d31ee879684775b51">&#9670;&nbsp;</a></span>Cudd_ReadSiftMaxVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSiftMaxVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the siftMaxVar parameter of the manager. </p>
<p>This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a54fbfd8fa0597af542ad9dfa4eefa2da" title="Reads the siftMaxSwap parameter of the manager.">Cudd_ReadSiftMaxSwap</a> <a class="el" href="cuddAPI_8c.html#a23ad3e7bf12607f58756e15f2b1251aa" title="Sets the siftMaxVar parameter of the manager.">Cudd_SetSiftMaxVar</a> </dd></dl>

</div>
</div>
<a id="ab1647f3f86f4e555bea35673f9539f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1647f3f86f4e555bea35673f9539f94">&#9670;&nbsp;</a></span>Cudd_ReadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of BDD variables in existance. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a82a5d45fa3fb62aa72a3aa280c563f9d" title="Returns the number of ZDD variables in existance.">Cudd_ReadZddSize</a> </dd></dl>

</div>
</div>
<a id="a3787560300153655851b4fe3c7646b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787560300153655851b4fe3c7646b0c">&#9670;&nbsp;</a></span>Cudd_ReadSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Cudd_ReadSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of slots of the unique table. </p>
<p>This number is mainly for diagnostic purposes.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ae94781bf6e62d0c6a3439b4db11b50e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94781bf6e62d0c6a3439b4db11b50e5">&#9670;&nbsp;</a></span>Cudd_ReadStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the start time of the manager. </p>
<p>This is initially set to the number of milliseconds since the program started, but may be reset by the application.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> <a class="el" href="cuddAPI_8c.html#ac8bbaa787eb4bbf866292ea6f566e427" title="Resets the start time of the manager.">Cudd_ResetStartTime</a> <a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a9830fe86096e7721263e058ba7d93d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9830fe86096e7721263e058ba7d93d26">&#9670;&nbsp;</a></span>Cudd_ReadStderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* Cudd_ReadStderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the stderr of a manager. </p>
<p>This is the file pointer to which messages normally going to stderr are written. It is initialized to stderr. Cudd_SetStderr allows the application to redirect it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a910e7309dc7551140d71871619ead247" title="Sets the stderr of a manager.">Cudd_SetStderr</a> <a class="el" href="cuddAPI_8c.html#a811b2599d1ed4a66001b7577cbbbd33d" title="Reads the stdout of a manager.">Cudd_ReadStdout</a> </dd></dl>

</div>
</div>
<a id="a811b2599d1ed4a66001b7577cbbbd33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811b2599d1ed4a66001b7577cbbbd33d">&#9670;&nbsp;</a></span>Cudd_ReadStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* Cudd_ReadStdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the stdout of a manager. </p>
<p>This is the file pointer to which messages normally going to stdout are written. It is initialized to stdout. Cudd_SetStdout allows the application to redirect it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac3080103403d6ba1f79b04f4e701edbc" title="Sets the stdout of a manager.">Cudd_SetStdout</a> <a class="el" href="cuddAPI_8c.html#a9830fe86096e7721263e058ba7d93d26" title="Reads the stderr of a manager.">Cudd_ReadStderr</a> </dd></dl>

</div>
</div>
<a id="a2cb92ccf940cabf261d35ccc1945e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb92ccf940cabf261d35ccc1945e7cf">&#9670;&nbsp;</a></span>Cudd_ReadSwapSteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadSwapSteps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the number of elementary reordering steps. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>

</div>
</div>
<a id="a3028ccbe6fb46efd6565d0f4aab78738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3028ccbe6fb46efd6565d0f4aab78738">&#9670;&nbsp;</a></span>Cudd_ReadSymmviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadSymmviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value of the symmviolation parameter used in group sifting. </p>
<p>This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5bb84b628160417172cb44e22e2067b7" title="Sets the value of the symmviolation parameter used in group sifting.">Cudd_SetSymmviolation</a> </dd></dl>

</div>
</div>
<a id="a855a253235b54ff16fd66c6e43241069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a253235b54ff16fd66c6e43241069">&#9670;&nbsp;</a></span>Cudd_ReadTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_ReadTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time limit for the manager. </p>
<p>This is initially set to a very large number, but may be reset by the application. The time is expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> </dd></dl>

</div>
</div>
<a id="a4b1312ca893e36e0b628804b12e5df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1312ca893e36e0b628804b12e5df32">&#9670;&nbsp;</a></span>Cudd_ReadTimeoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a> Cudd_ReadTimeoutHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current timeout handler function. </p>
<dl class="section user"><dt>Side effects\n If argp is non-null, the second argument to</dt><dd>the handler is written to the location it points to.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a122a5e97bfebdc0362991d1caaa96115" title="Register a timeout handler function.">Cudd_RegisterTimeoutHandler</a> </dd></dl>

</div>
</div>
<a id="aaaa1d598d1d5830c72b33aca86e511c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa1d598d1d5830c72b33aca86e511c1">&#9670;&nbsp;</a></span>Cudd_ReadUniqueLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUniqueLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of links followed in the unique table. </p>
<p>Returns the number of links followed during look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. If an item is found in the first position of its collision list, the number of links followed is taken to be 0. If it is in second position, the number of links is 1, and so on. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acebf224e24889082c229d56db1f982f3" title="Returns the number of look-ups in the unique table.">Cudd_ReadUniqueLookUps</a> </dd></dl>

</div>
</div>
<a id="acebf224e24889082c229d56db1f982f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebf224e24889082c229d56db1f982f3">&#9670;&nbsp;</a></span>Cudd_ReadUniqueLookUps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUniqueLookUps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of look-ups in the unique table. </p>
<p>Returns the number of look-ups in the unique table if the keeping of this statistic is enabled; -1 otherwise. This statistic is enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aaaa1d598d1d5830c72b33aca86e511c1" title="Returns the number of links followed in the unique table.">Cudd_ReadUniqueLinks</a> </dd></dl>

</div>
</div>
<a id="a0941cb7338ba1a71f3451f4c2a747093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0941cb7338ba1a71f3451f4c2a747093">&#9670;&nbsp;</a></span>Cudd_ReadUsedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_ReadUsedSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the fraction of used slots in the unique table. </p>
<p>The unused slots are those in which no valid data is stored. Garbage collection, variable reordering, and subtable resizing may cause used slots to become unused.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3787560300153655851b4fe3c7646b0c" title="Returns the total number of slots of the unique table.">Cudd_ReadSlots</a> </dd></dl>

</div>
</div>
<a id="a44d8f64c98953fd110d0e5146bcadaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d8f64c98953fd110d0e5146bcadaca">&#9670;&nbsp;</a></span>Cudd_ReadVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the i-th element of the vars array. </p>
<p>Returns the i-th element of the vars array if it falls within the array bounds; NULL otherwise. If i is the index of an existing variable, this function produces the same result as Cudd_bddIthVar. However, if the i-th var does not exist yet, Cudd_bddIthVar will create it, whereas Cudd_ReadVars will not.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> </dd></dl>

</div>
</div>
<a id="ad6d6950021b06a3bf4a6bcd05b1753e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d6950021b06a3bf4a6bcd05b1753e7">&#9670;&nbsp;</a></span>Cudd_ReadZddOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadZddOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ZDD for the constant 1 function. </p>
<p>The representation of the constant 1 function as a ZDD depends on how many variables it (nominally) depends on. The index of the topmost variable in the support is given as argument <code>i</code>.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> </dd></dl>

</div>
</div>
<a id="a82a5d45fa3fb62aa72a3aa280c563f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a5d45fa3fb62aa72a3aa280c563f9d">&#9670;&nbsp;</a></span>Cudd_ReadZddSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReadZddSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of ZDD variables in existance. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>

</div>
</div>
<a id="a92900f3320df460a72eacc4ed801d69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92900f3320df460a72eacc4ed801d69e">&#9670;&nbsp;</a></span>Cudd_ReadZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ReadZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the zero constant of the manager. </p>
<p>The zero constant is the arithmetic zero, rather than the logic zero. The latter is the complement of the one constant.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2651c953d81570d3f4f794bcbef40afe" title="Returns the one constant of the manager.">Cudd_ReadOne</a> <a class="el" href="cuddAPI_8c.html#a1dd42d8cb5c86659170103a3068e13a6" title="Returns the logic zero constant of the manager.">Cudd_ReadLogicZero</a> </dd></dl>

</div>
</div>
<a id="a0944d022761660bf481167b78759f599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0944d022761660bf481167b78759f599">&#9670;&nbsp;</a></span>Cudd_RecursiveDeref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RecursiveDeref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count of node n. </p>
<p>If n dies, recursively decreases the reference counts of its children. It is used to dispose of a <a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> that is no longer needed.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a1878b826a0a318e816d419ca5bcea97b" title="Decreases the reference count of node.">Cudd_Deref</a> <a class="el" href="cuddRef_8c.html#a3d0d9959640235fc073699c776914fca" title="Increases the reference count of a node, if it is not saturated.">Cudd_Ref</a> <a class="el" href="cuddRef_8c.html#a08641a3718655a85000069cc58cdd172" title="Decreases the reference count of ZDD node n.">Cudd_RecursiveDerefZdd</a> </dd></dl>

</div>
</div>
<a id="a08641a3718655a85000069cc58cdd172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08641a3718655a85000069cc58cdd172">&#9670;&nbsp;</a></span>Cudd_RecursiveDerefZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RecursiveDerefZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decreases the reference count of ZDD node n. </p>
<p>If n dies, recursively decreases the reference counts of its children. It is used to dispose of a ZDD that is no longer needed.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a1878b826a0a318e816d419ca5bcea97b" title="Decreases the reference count of node.">Cudd_Deref</a> <a class="el" href="cuddRef_8c.html#a3d0d9959640235fc073699c776914fca" title="Increases the reference count of a node, if it is not saturated.">Cudd_Ref</a> <a class="el" href="cuddRef_8c.html#a0944d022761660bf481167b78759f599" title="Decreases the reference count of node n.">Cudd_RecursiveDeref</a> </dd></dl>

</div>
</div>
<a id="a02a5a86dfb8ebc7726d6cf56b6a7eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a5a86dfb8ebc7726d6cf56b6a7eec1">&#9670;&nbsp;</a></span>Cudd_ReduceHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReduceHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main dynamic reordering routine. </p>
<p>Calls one of the possible reordering procedures: </p><ul>
<li>
Swapping </li>
<li>
Sifting </li>
<li>
Symmetric Sifting </li>
<li>
Group Sifting </li>
<li>
Window Permutation </li>
<li>
Simulated Annealing </li>
<li>
Genetic Algorithm </li>
<li>
Dynamic Programming (exact) </li>
</ul>
<p>For sifting, symmetric sifting, group sifting, and window permutation it is possible to request reordering to convergence.</p>
<p>The core of all methods is the reordering procedure <a class="el" href="cuddReorder_8c.html#a02e55858557a72e60c2c2e81a53916d8" title="Swaps two adjacent variables.">cuddSwapInPlace()</a> which swaps two adjacent variables and is based on Rudell's paper.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise. In the case of symmetric sifting (with and without convergence) returns 1 plus the number of symmetric variables, in case of success.</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the variable order for all diagrams and clears</dt><dd>the cache. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>DD manager </td></tr>
    <tr><td class="paramname">heuristic</td><td>method used for reordering </td></tr>
    <tr><td class="paramname">minsize</td><td>bound below which no reordering occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d0d9959640235fc073699c776914fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d9959640235fc073699c776914fca">&#9670;&nbsp;</a></span>Cudd_Ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_Ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the reference count of a node, if it is not saturated. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddRef_8c.html#a0944d022761660bf481167b78759f599" title="Decreases the reference count of node n.">Cudd_RecursiveDeref</a> <a class="el" href="cuddRef_8c.html#a1878b826a0a318e816d419ca5bcea97b" title="Decreases the reference count of node.">Cudd_Deref</a> </dd></dl>

</div>
</div>
<a id="a6aa76d8075f1af649c8741af26369836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa76d8075f1af649c8741af26369836">&#9670;&nbsp;</a></span>Cudd_RegisterOutOfMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a> Cudd_RegisterOutOfMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab7b4676c7e2dd36567b3749740ca8b60">DD_OOMFP</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs an out-of-memory callback. </p>
<p>Registers a callback function that is called when a discretionary memory allocation fails.</p>
<dl class="section return"><dt>Returns</dt><dd>the old callback function.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1b6966d8f04f26fd49495f3703a771ce" title="Unregister an out-of-memory callback.">Cudd_UnregisterOutOfMemoryCallback</a> <a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> </dd></dl>

</div>
</div>
<a id="a5dbdd1ef4d92a8f7d60304e2cc17ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbdd1ef4d92a8f7d60304e2cc17ff6e">&#9670;&nbsp;</a></span>Cudd_RegisterTerminationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RegisterTerminationCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#ab19edd4d89e40f721e04dbdeb3e36684">DD_THFP</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a termination callback. </p>
<p>Registers a callback function that is called from time to time to decide whether computation should be abandoned.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a8014219cc6794497d58c3eeb140db8c8" title="Unregisters a termination callback.">Cudd_UnregisterTerminationCallback</a> </dd></dl>

</div>
</div>
<a id="a122a5e97bfebdc0362991d1caaa96115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122a5e97bfebdc0362991d1caaa96115">&#9670;&nbsp;</a></span>Cudd_RegisterTimeoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_RegisterTimeoutHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a55dd2f7df5ab2f9df7e9e5c969adc0aa">DD_TOHFP</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a timeout handler function. </p>
<p>To unregister a handler, register a NULL pointer.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a4b1312ca893e36e0b628804b12e5df32" title="Read the current timeout handler function.">Cudd_ReadTimeoutHandler</a> </dd></dl>

</div>
</div>
<a id="a88270c8ded877c10677d563b7041df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88270c8ded877c10677d563b7041df38">&#9670;&nbsp;</a></span>Cudd_RemapOverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the remapping underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f3e8b16e5df2eb681a68e6ee6906f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f3e8b16e5df2eb681a68e6ee6906f3">&#9670;&nbsp;</a></span>Cudd_RemapUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the remapping underapproximation method. </p>
<p>This procedure uses a remapping technique and density as the cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c732be4af510054662cd6e6f0a5772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c732be4af510054662cd6e6f0a5772f">&#9670;&nbsp;</a></span>Cudd_RemoveHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_RemoveHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a1a0b162633be038685ce87dac7a57382">DD_HFP</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#afbec19daded82939f6045c92b3a7bde2">Cudd_HookType</a>&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a function from a hook. </p>
<p>A hook is a list of application-provided functions called on certain occasions by the package.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 the function was not in the list.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6884f064de544463f006f9104e4afa74" title="Adds a function to a hook.">Cudd_AddHook</a> </dd></dl>

</div>
</div>
<a id="a4a634a339969d6d84e3db858f3f77be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a634a339969d6d84e3db858f3f77be4">&#9670;&nbsp;</a></span>Cudd_ReorderingReporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingReporting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 1 if reporting of reordering stats is enabled; 0 otherwise. </p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adfe5374e85cf3fb0827307b1e3cc5e07" title="Enables reporting of reordering stats.">Cudd_EnableReorderingReporting</a> <a class="el" href="cuddAPI_8c.html#a249298e38710246ab1ead014cfe54dd9" title="Disables reporting of reordering stats.">Cudd_DisableReorderingReporting</a> </dd></dl>

</div>
</div>
<a id="a3806c2327487b3cea3c7ffff75aead83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806c2327487b3cea3c7ffff75aead83">&#9670;&nbsp;</a></span>Cudd_ReorderingStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of automatic dynamic reordering of BDDs and ADDs. </p>
<p>The location pointed by parameter method is set to the reordering method currently selected if method is non-null.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if automatic reordering is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The location pointed by parameter method is set to the</dt><dd>reordering method currently selected if method is non-null.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6a0d69b4288f36d5d377c460d49066a6" title="Enables automatic dynamic reordering of BDDs and ADDs.">Cudd_AutodynEnable</a> <a class="el" href="cuddAPI_8c.html#affd2c1c2a110944c1d760de577aed431" title="Disables automatic dynamic reordering.">Cudd_AutodynDisable</a> <a class="el" href="cuddAPI_8c.html#ac6f65c44244489bfbb37137929baf0cd" title="Reports the status of automatic dynamic reordering of ZDDs.">Cudd_ReorderingStatusZdd</a> </dd></dl>

</div>
</div>
<a id="ac6f65c44244489bfbb37137929baf0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f65c44244489bfbb37137929baf0cd">&#9670;&nbsp;</a></span>Cudd_ReorderingStatusZdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ReorderingStatusZdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a> *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of automatic dynamic reordering of ZDDs. </p>
<p>Parameter method is set to the ZDD reordering method currently selected.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if automatic reordering is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Parameter method is set to the ZDD reordering method currently</dt><dd>selected.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a709e0e15a38d6d6e9c83ff8b8a9d07f2" title="Enables automatic dynamic reordering of ZDDs.">Cudd_AutodynEnableZdd</a> <a class="el" href="cuddAPI_8c.html#a219ccb201e3c1aa25ebef007399849fa" title="Disables automatic dynamic reordering of ZDDs.">Cudd_AutodynDisableZdd</a> <a class="el" href="cuddAPI_8c.html#a3806c2327487b3cea3c7ffff75aead83" title="Reports the status of automatic dynamic reordering of BDDs and ADDs.">Cudd_ReorderingStatus</a> </dd></dl>

</div>
</div>
<a id="ade6b694fd53078a6f3f6a0e73cd97fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6b694fd53078a6f3f6a0e73cd97fd9">&#9670;&nbsp;</a></span>Cudd_Reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_Reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand manager without creating variables. </p>
<p>Expand a manager by a specified number of subtables without actually creating new variables. This function can be used to reduce the frequency of resizing when an estimate of the number of variables is available. One would call this function instead of passing the number of variables to Cudd_Init if variables should not be created right away of if the estimate on their number became available only after the manager has been created.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddInit_8c.html#a45075f018d4c680c12573bbd1c44ddb9" title="Creates a new DD manager.">Cudd_Init</a> </dd></dl>

</div>
</div>
<a id="ac8bbaa787eb4bbf866292ea6f566e427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bbaa787eb4bbf866292ea6f566e427">&#9670;&nbsp;</a></span>Cudd_ResetStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_ResetStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the start time of the manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a2d4a097e769d11868f760b920e6f1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4a097e769d11868f760b920e6f1da8">&#9670;&nbsp;</a></span>Cudd_SetApplicationHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetApplicationHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application hook. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9f98975109e7d3afd1bad0716e4d6666" title="Reads the application hook.">Cudd_ReadApplicationHook</a> </dd></dl>

</div>
</div>
<a id="a3064405f352a9d93a6ee16cfa5d2512c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064405f352a9d93a6ee16cfa5d2512c">&#9670;&nbsp;</a></span>Cudd_SetArcviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetArcviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcviolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the arcviolation parameter used in group sifting. </p>
<p>This parameter is used to decide how many arcs into <code>y</code> not coming from <code>x</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a89117a52be055c338311b1380d511375" title="Returns the current value of the arcviolation parameter used in group sifting.">Cudd_ReadArcviolation</a> </dd></dl>

</div>
</div>
<a id="a3792749a2a10045b60d2a3d99d99928e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3792749a2a10045b60d2a3d99d99928e">&#9670;&nbsp;</a></span>Cudd_SetBackground()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>bck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the background constant of the manager. </p>
<p>It assumes that the <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> pointer bck is already referenced.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a30ef132c1f56bdb0e26efc81fa695cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ef132c1f56bdb0e26efc81fa695cf3">&#9670;&nbsp;</a></span>Cudd_SetEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the epsilon parameter of the manager to ep. </p>
<p>The epsilon parameter control the comparison between floating point numbers.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac711d8ce9d243e16246b83e3c1f04199" title="Reads the epsilon parameter of the manager.">Cudd_ReadEpsilon</a> </dd></dl>

</div>
</div>
<a id="aee7e7fa94656ed131aa67ca1ea15a031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7e7fa94656ed131aa67ca1ea15a031">&#9670;&nbsp;</a></span>Cudd_SetGroupcheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetGroupcheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8b2572b778b7e8bd68afcd4aa1f0ce33">Cudd_AggregationType</a>&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parameter groupcheck of the manager to gc. </p>
<p>The groupcheck parameter determines the aggregation criterion in group sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>Cudd_ReadGroupCheck </dd></dl>

</div>
</div>
<a id="a1952bb97db9782bcf607d169c842b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1952bb97db9782bcf607d169c842b7ce">&#9670;&nbsp;</a></span>Cudd_SetLooseUpTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetLooseUpTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the looseUpTo parameter of the manager. </p>
<p>This parameter of the manager controls the threshold beyond which no fast growth of the unique table is allowed. The threshold is given as a number of slots. If the value passed to this function is 0, the function determines a suitable value based on the available memory.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ab452b9f1bbcdb8bf49cbea25f6e8ed8d" title="Reads the looseUpTo parameter of the manager.">Cudd_ReadLooseUpTo</a> <a class="el" href="cuddAPI_8c.html#ae96f3e2036a77ab8c1318e607dea232b" title="Sets the hit rate that causes resizinig of the computed table.">Cudd_SetMinHit</a> </dd></dl>

</div>
</div>
<a id="a4ced83212c4c45f94d8957e3fab485c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ced83212c4c45f94d8957e3fab485c5">&#9670;&nbsp;</a></span>Cudd_SetMaxCacheHard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxCacheHard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxCacheHard parameter of the manager. </p>
<p>The cache cannot grow larger than maxCacheHard entries. This parameter allows an application to control the trade-off of memory versus speed. If the value passed to this function is 0, the function determines a suitable maximum cache size based on the available memory.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#acfac0e32bb4bcfe7f0035f4fff401a0e" title="Reads the maxCacheHard parameter of the manager.">Cudd_ReadMaxCacheHard</a> Cudd_SetMaxCache </dd></dl>

</div>
</div>
<a id="aa3a621a6133ce4203b8bfa351d5de4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a621a6133ce4203b8bfa351d5de4ea">&#9670;&nbsp;</a></span>Cudd_SetMaxGrowth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxGrowth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxGrowth parameter of the manager. </p>
<p>This parameter determines how much the number of nodes can grow during sifting of a variable. Overall, sifting never increases the size of the decision diagrams. This parameter only refers to intermediate results. A lower value will speed up sifting, possibly at the expense of quality.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23f3600540de47d20e85eb4036af6e49" title="Reads the maxGrowth parameter of the manager.">Cudd_ReadMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> </dd></dl>

</div>
</div>
<a id="a7d4358c1f00a31b657c937b8e64ec6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4358c1f00a31b657c937b8e64ec6e6">&#9670;&nbsp;</a></span>Cudd_SetMaxGrowthAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxGrowthAlternate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maxGrowthAlt parameter of the manager. </p>
<p>This parameter is analogous to the maxGrowth paramter, and is used every given number of reorderings instead of maxGrowth. The number of reorderings is set with Cudd_SetReorderingCycle. If the number of reorderings is 0 (default) maxGrowthAlt is never used.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#aa3a621a6133ce4203b8bfa351d5de4ea" title="Sets the maxGrowth parameter of the manager.">Cudd_SetMaxGrowth</a> <a class="el" href="cuddAPI_8c.html#afd23a86c046d74935d746757846d1148" title="Sets the reordCycle parameter of the manager.">Cudd_SetReorderingCycle</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="ac553f7975b60ebe4a38141cbff1eebea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac553f7975b60ebe4a38141cbff1eebea">&#9670;&nbsp;</a></span>Cudd_SetMaxLive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxLive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxLive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum allowed number of live nodes. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af6afbdb9c3955275888ec9cb60711a57" title="Reads the maximum allowed number of live nodes.">Cudd_ReadMaxLive</a> </dd></dl>

</div>
</div>
<a id="a0d15a525874908e9230881bccabbb993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d15a525874908e9230881bccabbb993">&#9670;&nbsp;</a></span>Cudd_SetMaxMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cudd_SetMaxMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxMemory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum allowed memory. </p>
<p>When this number is exceeded, the package returns NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous limit.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aef52798a6b7994a3038335d36ec9f051" title="Reads the maximum allowed memory.">Cudd_ReadMaxMemory</a> </dd></dl>

</div>
</div>
<a id="a3a2e39aeebc215847d374a01bb1f182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2e39aeebc215847d374a01bb1f182b">&#9670;&nbsp;</a></span>Cudd_SetMaxReorderings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMaxReorderings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of times reordering may be invoked. </p>
<p>The default value is (practically) infinite.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac22056db7260493748eda0162431cd76" title="Returns the number of times reordering has occurred.">Cudd_ReadReorderings</a> <a class="el" href="cuddAPI_8c.html#ad011aad1e779f0e31ab67cf7a1d7f591" title="Returns the maximum number of times reordering may be invoked.">Cudd_ReadMaxReorderings</a> <a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> </dd></dl>

</div>
</div>
<a id="ae96f3e2036a77ab8c1318e607dea232b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96f3e2036a77ab8c1318e607dea232b">&#9670;&nbsp;</a></span>Cudd_SetMinHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetMinHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the hit rate that causes resizinig of the computed table. </p>
<p>Sets the minHit parameter of the manager. This parameter controls the resizing of the computed table. If the hit rate is larger than the specified value, and the cache is not already too large, then its size is doubled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a79695ef1e6f821d310f5613a6d8ba148" title="Reads the hit rate that causes resizinig of the computed table.">Cudd_ReadMinHit</a> </dd></dl>

</div>
</div>
<a id="a3d62c965eabd4ec777af47acd790ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d62c965eabd4ec777af47acd790ee47">&#9670;&nbsp;</a></span>Cudd_SetNextReordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetNextReordering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the threshold for the next dynamic reordering. </p>
<p>The threshold is in terms of number of nodes and is in effect only if reordering is enabled. The count does not include the dead nodes, unless the countDead parameter of the manager has been changed from its default setting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#adc3820fb326bce09797fda8439b5daa4" title="Returns the threshold for the next dynamic reordering.">Cudd_ReadNextReordering</a> </dd></dl>

</div>
</div>
<a id="ae8b2c48e26b4178cf6536f4ce253d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b2c48e26b4178cf6536f4ce253d9b1">&#9670;&nbsp;</a></span>Cudd_SetNumberXovers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetNumberXovers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberXovers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of crossovers used by the genetic algorithm for variable reordering. </p>
<p>A larger number of crossovers will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as number of crossovers, with a maximum of 60.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a2609fe9051be1a8ab6d305d38bfb5956" title="Reads the current number of crossovers used by the genetic algorithm for variable reordering.">Cudd_ReadNumberXovers</a> </dd></dl>

</div>
</div>
<a id="a3e58f1cfc002a5a2af126f29e7377243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58f1cfc002a5a2af126f29e7377243">&#9670;&nbsp;</a></span>Cudd_SetOrderRandomization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetOrderRandomization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the order randomization factor. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a93f6c6fc1714330d1554a0f2e562ae1f" title="Returns the order randomization factor.">Cudd_ReadOrderRandomization</a> </dd></dl>

</div>
</div>
<a id="abbdf2ca87a414bb36bfbb6247a8915ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdf2ca87a414bb36bfbb6247a8915ec">&#9670;&nbsp;</a></span>Cudd_SetPopulationSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetPopulationSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>populationSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the population used by the genetic algorithm for variable reordering. </p>
<p>A larger population size will cause the genetic algorithm to take more time, but will generally produce better results. The default value is 0, in which case the package uses three times the number of variables as population size, with a maximum of 120.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a1e760e63a14cd28172b2371c8419b0d9" title="Reads the current size of the population used by the genetic algorithm for variable reordering.">Cudd_ReadPopulationSize</a> </dd></dl>

</div>
</div>
<a id="ac68f934b27bc1d1ea947f410c8aedd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f934b27bc1d1ea947f410c8aedd36">&#9670;&nbsp;</a></span>Cudd_SetRecomb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetRecomb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recomb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the recombination parameter used in group sifting. </p>
<p>A larger (positive) value makes the aggregation of variables due to the second difference criterion more likely. A smaller (negative) value makes aggregation less likely. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ac305e7d5aaa2c3808db94795dc0a1150" title="Returns the current value of the recombination parameter used in group sifting.">Cudd_ReadRecomb</a> </dd></dl>

</div>
</div>
<a id="afd23a86c046d74935d746757846d1148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd23a86c046d74935d746757846d1148">&#9670;&nbsp;</a></span>Cudd_SetReorderingCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetReorderingCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reordCycle parameter of the manager. </p>
<p>This parameter determines how often the alternate threshold on maximum growth is used in reordering.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a692abb5fde2011b2a3cec010946eebca" title="Reads the maxGrowthAlt parameter of the manager.">Cudd_ReadMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#a7d4358c1f00a31b657c937b8e64ec6e6" title="Sets the maxGrowthAlt parameter of the manager.">Cudd_SetMaxGrowthAlternate</a> <a class="el" href="cuddAPI_8c.html#aa5283d665223378e10425342dad1684b" title="Reads the reordCycle parameter of the manager.">Cudd_ReadReorderingCycle</a> </dd></dl>

</div>
</div>
<a id="a40246082da9de77243088f935be6e2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40246082da9de77243088f935be6e2e6">&#9670;&nbsp;</a></span>Cudd_SetSiftMaxSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSiftMaxSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the siftMaxSwap parameter of the manager. </p>
<p>This parameter gives the maximum number of swaps that will be attempted for each invocation of sifting. The real number of swaps may exceed the set limit because the package will always complete the sifting of the variable that causes the limit to be reached.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a23ad3e7bf12607f58756e15f2b1251aa" title="Sets the siftMaxVar parameter of the manager.">Cudd_SetSiftMaxVar</a> <a class="el" href="cuddAPI_8c.html#a54fbfd8fa0597af542ad9dfa4eefa2da" title="Reads the siftMaxSwap parameter of the manager.">Cudd_ReadSiftMaxSwap</a> </dd></dl>

</div>
</div>
<a id="a23ad3e7bf12607f58756e15f2b1251aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ad3e7bf12607f58756e15f2b1251aa">&#9670;&nbsp;</a></span>Cudd_SetSiftMaxVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSiftMaxVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the siftMaxVar parameter of the manager. </p>
<p>This parameter gives the maximum number of variables that will be sifted for each invocation of sifting.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40246082da9de77243088f935be6e2e6" title="Sets the siftMaxSwap parameter of the manager.">Cudd_SetSiftMaxSwap</a> <a class="el" href="cuddAPI_8c.html#a112841ed78d8f90d31ee879684775b51" title="Reads the siftMaxVar parameter of the manager.">Cudd_ReadSiftMaxVar</a> </dd></dl>

</div>
</div>
<a id="a2b42ab1fa12990140dbfd415bc7a6231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b42ab1fa12990140dbfd415bc7a6231">&#9670;&nbsp;</a></span>Cudd_SetStartTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the start time of the manager. </p>
<p>The time must be expressed in milliseconds.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#ae94781bf6e62d0c6a3439b4db11b50e5" title="Returns the start time of the manager.">Cudd_ReadStartTime</a> <a class="el" href="cuddAPI_8c.html#ac8bbaa787eb4bbf866292ea6f566e427" title="Resets the start time of the manager.">Cudd_ResetStartTime</a> <a class="el" href="cuddAPI_8c.html#ab6cafb71c46dedb3eaa27acd56b855b8" title="Returns the time elapsed since the start time of the manager.">Cudd_ReadElapsedTime</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a910e7309dc7551140d71871619ead247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910e7309dc7551140d71871619ead247">&#9670;&nbsp;</a></span>Cudd_SetStderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStderr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stderr of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a9830fe86096e7721263e058ba7d93d26" title="Reads the stderr of a manager.">Cudd_ReadStderr</a> <a class="el" href="cuddAPI_8c.html#ac3080103403d6ba1f79b04f4e701edbc" title="Sets the stdout of a manager.">Cudd_SetStdout</a> </dd></dl>

</div>
</div>
<a id="ac3080103403d6ba1f79b04f4e701edbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3080103403d6ba1f79b04f4e701edbc">&#9670;&nbsp;</a></span>Cudd_SetStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetStdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stdout of a manager. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a811b2599d1ed4a66001b7577cbbbd33d" title="Reads the stdout of a manager.">Cudd_ReadStdout</a> <a class="el" href="cuddAPI_8c.html#a910e7309dc7551140d71871619ead247" title="Sets the stderr of a manager.">Cudd_SetStderr</a> </dd></dl>

</div>
</div>
<a id="a5bb84b628160417172cb44e22e2067b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb84b628160417172cb44e22e2067b7">&#9670;&nbsp;</a></span>Cudd_SetSymmviolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SetSymmviolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmviolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the symmviolation parameter used in group sifting. </p>
<p>This parameter is used in group sifting to decide how many violations to the symmetry conditions <code>f10 = f01</code> or <code>f11 = f00</code> are tolerable when checking for aggregation due to extended symmetry. The value should be between 0 and 100. A small value causes fewer variables to be aggregated. The default value is 0.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a3028ccbe6fb46efd6565d0f4aab78738" title="Returns the current value of the symmviolation parameter used in group sifting.">Cudd_ReadSymmviolation</a> </dd></dl>

</div>
</div>
<a id="ac6e694e133632d34256646869f076ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e694e133632d34256646869f076ff5">&#9670;&nbsp;</a></span>Cudd_SetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Cudd_SetTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time limit for the manager. </p>
<p>The time must be expressed in milliseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>the old time limit.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a3d0ed2b9c7a7158ed78273908a2a5386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ed2b9c7a7158ed78273908a2a5386">&#9670;&nbsp;</a></span>Cudd_SetVarMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SetVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a variable mapping with the manager. </p>
<p>Registers with the manager a variable mapping described by two sets of variables. This variable mapping is then used by functions like Cudd_bddVarMap. This function is convenient for those applications that perform the same mapping several times. However, if several different permutations are used, it may be more efficient not to rely on the registered mapping, because changing mapping causes the cache to be cleared. (The initial setting, however, does not clear the cache.) The two sets of variables (x and y) must have the same size (x and y). The size is given by n. The two sets of variables are normally disjoint, but this restriction is not imposeded by the function. When new variables are created, the map is automatically extended (each new variable maps to itself). The typical use, however, is to wait until all variables are created, and then create the map.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the mapping is successfully registered with the manager; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Modifies the manager. May clear the cache.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9" title="Remaps the variables of a BDD using the default variable map.">Cudd_bddVarMap</a> <a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">x</td><td>first array of variables </td></tr>
    <tr><td class="paramname">y</td><td>second array of variables </td></tr>
    <tr><td class="paramname">n</td><td>length of both arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d57cfc6ede9ae452a40779b58a3bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d57cfc6ede9ae452a40779b58a3bac">&#9670;&nbsp;</a></span>Cudd_SharingSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SharingSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>nodeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in an array of DDs. </p>
<p>Shared nodes are counted only once.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of nodes.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>

</div>
</div>
<a id="addfc0e508dfd1d0bd0c74104a3dd15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfc0e508dfd1d0bd0c74104a3dd15e8">&#9670;&nbsp;</a></span>Cudd_ShortestLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ShortestLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the length of the shortest path(s) in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN edge coming from the node whose index is i. All ELSE edges have 0 weight.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the shortest path(s) if such a path is found; a large number if the function is identically 0, and CUDD_OUT_OF_MEM in case of failure.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a id="a78e2d36d1fdfa3d917ad345867bd4596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e2d36d1fdfa3d917ad345867bd4596">&#9670;&nbsp;</a></span>Cudd_ShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ShortestPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a shortest path in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN arc coming from the node whose index is i. If weight is NULL, then unit weights are assumed for all THEN arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support should point to arrays with at least as many entries as there are variables in the manager.</p>
<dl class="section return"><dt>Returns</dt><dd>the shortest path as the BDD of a cube.</dd></dl>
<dl class="section user"><dt>Side effects\n support contains on return the true support of f.</dt><dd>If support is NULL on entry, then Cudd_ShortestPath does not compute the true support info. length contains the length of the path.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSat_8c.html#addfc0e508dfd1d0bd0c74104a3dd15e8" title="Find the length of the shortest path(s) in a DD.">Cudd_ShortestLength</a> <a class="el" href="cuddSat_8c.html#a5722a5bf76d99cd30783ad87ba03bf96" title="Finds a largest cube in a DD.">Cudd_LargestCube</a> </dd></dl>

</div>
</div>
<a id="a8568f20319c54de096630b40c998e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8568f20319c54de096630b40c998e2e8">&#9670;&nbsp;</a></span>Cudd_ShuffleHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ShuffleHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders variables according to given permutation. </p>
<p>The i-th entry of the permutation array contains the index of the variable that should be brought to the i-th level. The size of the array should be equal or greater to the number of variables currently in use.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the variable order for all diagrams and clears</dt><dd>the cache.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>DD manager </td></tr>
    <tr><td class="paramname">permutation</td><td>required variable permutation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e6c21f42d3912604516687f47fd0f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6c21f42d3912604516687f47fd0f12">&#9670;&nbsp;</a></span>Cudd_SolveEqn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SolveEqn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>yIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the solution of F(x,y) = 0. </p>
<p>The return value is the consistency condition. The y variables are the unknowns and the remaining variables are the parameters. Cudd_SolveEqn allocates an array and fills it with the indices of the unknowns. This array is used by Cudd_VerifySol.</p>
<dl class="section return"><dt>Returns</dt><dd>the consistency condition if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The solution is returned in G; the indices of the y</dt><dd>variables are returned in yIndex.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSolve_8c.html#a232cca2744915ebae9aecedb78a83dd5" title="Checks the solution of F(x,y) = 0.">Cudd_VerifySol</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdd</td><td>CUDD manager </td></tr>
    <tr><td class="paramname">F</td><td>the left-hand side of the equation </td></tr>
    <tr><td class="paramname">Y</td><td>the cube of the y variables </td></tr>
    <tr><td class="paramname">G</td><td>the array of solutions (return parameter) </td></tr>
    <tr><td class="paramname">yIndex</td><td>index of y variables </td></tr>
    <tr><td class="paramname">n</td><td>numbers of unknowns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5386715b96f5d263045e0ee11703ee7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5386715b96f5d263045e0ee11703ee7c">&#9670;&nbsp;</a></span>Cudd_SplitSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SplitSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>xVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns m minterms from a BDD. </p>
<p>Returns <code>m</code> minterms from a BDD whose support has <code>n</code> variables at most. The procedure tries to create as few extra nodes as possible. The function represented by <code>S</code> depends on at most <code>n</code> of the variables in <code>xVars</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a BDD with <code>m</code> minterms of the on-set of S if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a20c2b03a12919a3d146c7e02b4f3e4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c2b03a12919a3d146c7e02b4f3e4bd">&#9670;&nbsp;</a></span>Cudd_Srandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_Srandom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for the portable random number generator. </p>
<p>Based on ran2 in "Numerical Recipes in C." The input is the seed for the generator. If it is negative, its absolute value is taken as seed. If it is 0, then 1 is taken as seed. The initialized sets up the two recurrences used to generate a long-period stream, and sets up the shuffle table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a7aca63dd70f27ea0245f0c269ffff6d1" title="Portable random number generator.">Cudd_Random</a> </dd></dl>

</div>
</div>
<a id="aa3b17a13db3a9537a0a13df5507f4d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b17a13db3a9537a0a13df5507f4d11">&#9670;&nbsp;</a></span>Cudd_StdPostReordHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_StdPostReordHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample hook function to call after reordering. </p>
<p>Prints on the manager's stdout final size and reordering time.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a852da7502c07042fde873b504aaa4573" title="Sample hook function to call before reordering.">Cudd_StdPreReordHook</a> </dd></dl>

</div>
</div>
<a id="a852da7502c07042fde873b504aaa4573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852da7502c07042fde873b504aaa4573">&#9670;&nbsp;</a></span>Cudd_StdPreReordHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_StdPreReordHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample hook function to call before reordering. </p>
<p>Prints on the manager's stdout reordering method and initial size.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa3b17a13db3a9537a0a13df5507f4d11" title="Sample hook function to call after reordering.">Cudd_StdPostReordHook</a> </dd></dl>

</div>
</div>
<a id="abbc5a582b85170a4c365e852b98c37da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc5a582b85170a4c365e852b98c37da">&#9670;&nbsp;</a></span>Cudd_SubsetCompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetCompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a dense subset of BDD <code>f</code>. </p>
<p>Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other subsetting procedures, but often produces better results. See Cudd_SubsetShortPaths for a description of the threshold and nvars parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> <a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD whose subset is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the subset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7579ecbb0187c4061cc2d45a3a21e68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7579ecbb0187c4061cc2d45a3a21e68e">&#9670;&nbsp;</a></span>Cudd_SubsetHeavyBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetHeavyBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the heavy branch heuristic. </p>
<p>This procedure builds a subset by throwing away one of the children of each node, starting from the root, until the result is small enough. The child that is eliminated from the result is the one that contributes the fewer minterms. The parameter numVars is the maximum number of variables to be used in minterm calculation and node count calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the subset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890a2da46a4d6cec913e2ae57a9ab626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890a2da46a4d6cec913e2ae57a9ab626">&#9670;&nbsp;</a></span>Cudd_SubsetShortPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetShortPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hardlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the shortest paths heuristic. </p>
<p>This procedure tries to preserve the shortest paths of the input BDD, because they give many minterms and contribute few nodes. This procedure may increase the number of nodes in trying to create the subset or reduce the number of nodes due to recombination as compared to the original BDD. Hence the threshold may not be strictly adhered to. In practice, recombination overshadows the increase in the number of nodes and results in small BDDs as compared to the threshold. The hardlimit specifies whether threshold needs to be strictly adhered to. If it is set to 1, the procedure ensures that result is never larger than the specified limit but may be considerably less than the threshold. The value for numVars should be as close as possible to the size of the support of f for better efficiency. However, it is safe to pass the value returned by Cudd_ReadSize for numVars. If 0 is passed, then the value returned by Cudd_ReadSize is used.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the subset if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the subset </td></tr>
    <tr><td class="paramname">hardlimit</td><td>flag: 1 if threshold is a hard limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8e7410606294a5fb0896c8787019db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7410606294a5fb0896c8787019db1">&#9670;&nbsp;</a></span>Cudd_SubsetWithMaskVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetWithMaskVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>maskVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a subset from a BDD. </p>
<p>Extracts a subset from a BDD in the following procedure.</p><ol type="1">
<li>Compute the weight for each mask variable by counting the number of minterms for both positive and negative cofactors of the BDD with respect to each mask variable. (weight = # positive - # negative)</li>
<li>Find a representative cube of the BDD by using the weight. From the top variable of the BDD, for each variable, if the weight is greater than 0.0, choose THEN branch, othereise ELSE branch, until meeting the constant 1.</li>
<li>Quantify out the variables not in maskVars from the representative cube and if a variable in maskVars is don't care, replace the variable with a constant(1 or 0) depending on the weight.</li>
<li>Make a subset of the BDD by multiplying with the modified cube.</li>
</ol>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick a cube </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">nvars</td><td>size of <code>vars</code> </td></tr>
    <tr><td class="paramname">maskVars</td><td>array of variables </td></tr>
    <tr><td class="paramname">mvars</td><td>size of <code>maskVars</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a194308bd7e4afce7aa668833f8a4e2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194308bd7e4afce7aa668833f8a4e2ff">&#9670;&nbsp;</a></span>Cudd_SupersetCompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SupersetCompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a dense superset of BDD <code>f</code>. </p>
<p>Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other supersetting procedures, but often produces better results. See Cudd_SupersetShortPaths for a description of the threshold and nvars parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddGenCof_8c.html#abbc5a582b85170a4c365e852b98c37da" title="Find a dense subset of BDD f.">Cudd_SubsetCompress</a> Cudd_SupersetRemap <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD whose superset is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the superset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5562f42d8ed481485bcb9d5469b2cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5562f42d8ed481485bcb9d5469b2cedd">&#9670;&nbsp;</a></span>Cudd_SupersetHeavyBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SupersetHeavyBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the heavy branch heuristic. </p>
<p>The procedure is identical to the subset procedure except for the fact that it receives the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. This procedure builds a superset by throwing away one of the children of each node starting from the root of the complement function, until the result is small enough. The child that is eliminated from the result is the one that contributes the fewer minterms. The parameter numVars is the maximum number of variables to be used in minterm calculation and node count calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the superset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d8ed34596ee3ef413bc804f08de8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d8ed34596ee3ef413bc804f08de8f7">&#9670;&nbsp;</a></span>Cudd_SupersetShortPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SupersetShortPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hardlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the shortest paths heuristic. </p>
<p>The procedure is identical to the subset procedure except for the fact that it receives the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. This procedure tries to preserve the shortest paths of the complement BDD, because they give many minterms and contribute few nodes. This procedure may increase the number of nodes in trying to create the superset or reduce the number of nodes due to recombination as compared to the original BDD. Hence the threshold may not be strictly adhered to. In practice, recombination overshadows the increase in the number of nodes and results in small BDDs as compared to the threshold. The hardlimit specifies whether threshold needs to be strictly adhered to. If it is set to 1, the procedure ensures that result is never larger than the specified limit but may be considerably less than the threshold. The value for numVars should be as close as possible to the size of the support of f for better efficiency. However, it is safe to pass the value returned by Cudd_ReadSize for numVar. If 0 is passed, then the value returned by Cudd_ReadSize is used.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the superset if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the subset </td></tr>
    <tr><td class="paramname">hardlimit</td><td>flag: 1 if threshold is a hard limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e1f8e5b8efe97330f8650e1378ad172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1f8e5b8efe97330f8650e1378ad172">&#9670;&nbsp;</a></span>Cudd_Support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>a BDD consisting of the product of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc898f0fe024bece58bb9e992845bb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc898f0fe024bece58bb9e992845bb73">&#9670;&nbsp;</a></span>Cudd_SupportIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* Cudd_SupportIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>an index array of the variables if successful; NULL otherwise. The size of the array equals the number of variables in the manager. Each entry of the array is 1 if the corresponding variable is in the support of the DD and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a455e317288c1b57e0097013d52435d23" title="Finds the variables on which a DD depends.">Cudd_SupportIndices</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a455e317288c1b57e0097013d52435d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455e317288c1b57e0097013d52435d23">&#9670;&nbsp;</a></span>Cudd_SupportIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SupportIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The indices of the support variables are returned as</dt><dd>side effects. If the function is constant, no array is allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
    <tr><td class="paramname">indices</td><td>array containing (on return) the indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e7cde5c4dfd8832de07de9b31e9469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7cde5c4dfd8832de07de9b31e9469e">&#9670;&nbsp;</a></span>Cudd_SupportSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SupportSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>the variables on which a DD depends.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a455e317288c1b57e0097013d52435d23" title="Finds the variables on which a DD depends.">Cudd_SupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support size is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83fd2716996fec765f23ec7bca30f14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fd2716996fec765f23ec7bca30f14b">&#9670;&nbsp;</a></span>Cudd_SymmProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_SymmProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints statistics on symmetric variables. </p>
<p>The information is accurate only if this function is called right after reordering with methods CUDD_REORDER_SYMM_SIFT or CUDD_REORDER_SYMM_SIFT_CONV.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="aeed52f5319f877acc6ac7c27490111b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed52f5319f877acc6ac7c27490111b6">&#9670;&nbsp;</a></span>Cudd_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the then child of an internal node. </p>
<p>If <code>node</code> is a constant node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a601a736699b3e5c8eb7149e6049ea131" title="Returns the else child of an internal node.">Cudd_E</a> <a class="el" href="cuddAPI_8c.html#a9ebe62ac5ac8a49dc13bce839ae09c88" title="Returns the value of a constant node.">Cudd_V</a> </dd></dl>

</div>
</div>
<a id="a7c3b2370790803f37aace1dfc0a7d1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3b2370790803f37aace1dfc0a7d1cc">&#9670;&nbsp;</a></span>Cudd_TimeLimited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_TimeLimited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the time limit for the manager is set. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> </dd></dl>

</div>
</div>
<a id="a67a4c74db7901421a4595343ca588128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a4c74db7901421a4595343ca588128">&#9670;&nbsp;</a></span>Cudd_tlcInfoFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_tlcInfoFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdTlcInfo.html">DdTlcInfo</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structDdTlcInfo.html" title="This structure holds the set of clauses for a node.">DdTlcInfo</a> Structure. </p>
<p>Also frees the memory pointed by it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a5b822894a35380ffca9e555286213484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b822894a35380ffca9e555286213484">&#9670;&nbsp;</a></span>Cudd_TurnOffCountDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_TurnOffCountDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the dead nodes not to be counted towards triggering reordering. </p>
<p>This causes less frequent reorderings. By default dead nodes are not counted. Therefore there is no need to call this function unless Cudd_TurnOnCountDead has been previously called.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#af0b407453f68498df9b9783f88401cf5" title="Causes the dead nodes to be counted towards triggering reordering.">Cudd_TurnOnCountDead</a> <a class="el" href="cuddAPI_8c.html#ae34d186620ce66627e57bbccfa24a892" title="Tells whether dead nodes are counted towards triggering reordering.">Cudd_DeadAreCounted</a> </dd></dl>

</div>
</div>
<a id="af0b407453f68498df9b9783f88401cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b407453f68498df9b9783f88401cf5">&#9670;&nbsp;</a></span>Cudd_TurnOnCountDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_TurnOnCountDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the dead nodes to be counted towards triggering reordering. </p>
<p>This causes more frequent reorderings. By default dead nodes are not counted.</p>
<dl class="section user"><dt>Side effects\n Changes the manager.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5b822894a35380ffca9e555286213484" title="Causes the dead nodes not to be counted towards triggering reordering.">Cudd_TurnOffCountDead</a> <a class="el" href="cuddAPI_8c.html#ae34d186620ce66627e57bbccfa24a892" title="Tells whether dead nodes are counted towards triggering reordering.">Cudd_DeadAreCounted</a> </dd></dl>

</div>
</div>
<a id="a9381231f34573676e814bb696b2321c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9381231f34573676e814bb696b2321c9">&#9670;&nbsp;</a></span>Cudd_UnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_UnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with Shiple's underapproximation method. </p>
<p>This procedure uses a variant of Tom Shiple's underapproximation method. The main difference from the original method is that density is used as cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful; NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6966d8f04f26fd49495f3703a771ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6966d8f04f26fd49495f3703a771ce">&#9670;&nbsp;</a></span>Cudd_UnregisterOutOfMemoryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnregisterOutOfMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an out-of-memory callback. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> <a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> </dd></dl>

</div>
</div>
<a id="a8014219cc6794497d58c3eeb140db8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8014219cc6794497d58c3eeb140db8c8">&#9670;&nbsp;</a></span>Cudd_UnregisterTerminationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnregisterTerminationCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a termination callback. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a5dbdd1ef4d92a8f7d60304e2cc17ff6e" title="Installs a termination callback.">Cudd_RegisterTerminationCallback</a> </dd></dl>

</div>
</div>
<a id="aa497c8cb498833021f18813fb5813b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497c8cb498833021f18813fb5813b57">&#9670;&nbsp;</a></span>Cudd_UnsetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UnsetTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the time limit for the manager. </p>
<p>Actually, sets it to a very large value.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aeeb6240810097270fd1414536de17eb0" title="Updates the time limit for the manager.">Cudd_UpdateTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="aeeb6240810097270fd1414536de17eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb6240810097270fd1414536de17eb0">&#9670;&nbsp;</a></span>Cudd_UpdateTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_UpdateTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the time limit for the manager. </p>
<p>Updates the time limit for the manager by subtracting the elapsed time from it.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a855a253235b54ff16fd66c6e43241069" title="Returns the time limit for the manager.">Cudd_ReadTimeLimit</a> <a class="el" href="cuddAPI_8c.html#ac6e694e133632d34256646869f076ff5" title="Sets the time limit for the manager.">Cudd_SetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#aa497c8cb498833021f18813fb5813b57" title="Unsets the time limit for the manager.">Cudd_UnsetTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a333169d352f3ab54002eaae738a39d68" title="Increases the time limit for the manager.">Cudd_IncreaseTimeLimit</a> <a class="el" href="cuddAPI_8c.html#a7c3b2370790803f37aace1dfc0a7d1cc" title="Returns true if the time limit for the manager is set.">Cudd_TimeLimited</a> <a class="el" href="cuddAPI_8c.html#a2b42ab1fa12990140dbfd415bc7a6231" title="Sets the start time of the manager.">Cudd_SetStartTime</a> </dd></dl>

</div>
</div>
<a id="a9ebe62ac5ac8a49dc13bce839ae09c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebe62ac5ac8a49dc13bce839ae09c88">&#9670;&nbsp;</a></span>Cudd_V()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> Cudd_V </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a constant node. </p>
<p>If <code>node</code> is an internal node, the result is unpredictable.</p>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aeed52f5319f877acc6ac7c27490111b6" title="Returns the then child of an internal node.">Cudd_T</a> <a class="el" href="cuddAPI_8c.html#a601a736699b3e5c8eb7149e6049ea131" title="Returns the else child of an internal node.">Cudd_E</a> </dd></dl>

</div>
</div>
<a id="a30712f050737cb498a0e6572a7940bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30712f050737cb498a0e6572a7940bf3">&#9670;&nbsp;</a></span>Cudd_VarsAreSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_VarsAreSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether two variables are symmetric in a <a class="el" href="classBDD.html" title="Class for BDDs.">BDD</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the variables are symmetric; 0 if they are not.</dd></dl>
<p>No nodes are built during the check.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td><a class="el" href="classBDD.html" title="Class for BDDs.">BDD</a> whose variables are tested </td></tr>
    <tr><td class="paramname">index1</td><td>index of first variable </td></tr>
    <tr><td class="paramname">index2</td><td>index of second variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f6cf8a1719f76a3e121e7f61c406d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6cf8a1719f76a3e121e7f61c406d5b">&#9670;&nbsp;</a></span>Cudd_VectorSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_VectorSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>a BDD consisting of the product of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3a3eda5431ad0985605921d16c83067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a3eda5431ad0985605921d16c83067">&#9670;&nbsp;</a></span>Cudd_VectorSupportIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* Cudd_VectorSupportIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>an index array of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6fd4942d4c62cb3a539a8039084d571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd4942d4c62cb3a539a8039084d571">&#9670;&nbsp;</a></span>Cudd_VectorSupportIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_VectorSupportIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The indices of the support variables are returned as</dt><dd>side effects. If the function is constant, no array is allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>DD whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
    <tr><td class="paramname">indices</td><td>array containing (on return) the indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66da9c2c22b9bbb31120bd0a28fbf83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66da9c2c22b9bbb31120bd0a28fbf83c">&#9670;&nbsp;</a></span>Cudd_VectorSupportSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_VectorSupportSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables on which a set of DDs depends.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#a0e7cde5c4dfd8832de07de9b31e9469e" title="Counts the variables on which a DD depends.">Cudd_SupportSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a232cca2744915ebae9aecedb78a83dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232cca2744915ebae9aecedb78a83dd5">&#9670;&nbsp;</a></span>Cudd_VerifySol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_VerifySol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>bdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>yIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the solution of F(x,y) = 0. </p>
<p>This procedure substitutes the solution components for the unknowns of F and returns the resulting BDD for F.</p>
<dl class="section user"><dt>Side effects\n Frees the memory pointed by yIndex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSolve_8c.html#a5e6c21f42d3912604516687f47fd0f12" title="Implements the solution of F(x,y) = 0.">Cudd_SolveEqn</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdd</td><td>CUDD manager </td></tr>
    <tr><td class="paramname">F</td><td>the left-hand side of the equation </td></tr>
    <tr><td class="paramname">G</td><td>the array of solutions </td></tr>
    <tr><td class="paramname">yIndex</td><td>index of y variables </td></tr>
    <tr><td class="paramname">n</td><td>numbers of unknowns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9817150682e961ceac761a6055cbecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9817150682e961ceac761a6055cbecd">&#9670;&nbsp;</a></span>Cudd_Xeqy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Xeqy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function x==y. </p>
<p>This function generates a BDD for the function x==y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1]. The BDD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a13a3aade7bb40fe511c203dfee9c0f33" title="Generates an ADD for the function x==y.">Cudd_addXeqy</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x and y variables </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a931e96461db0102f8aea154caa3f516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e96461db0102f8aea154caa3f516a">&#9670;&nbsp;</a></span>Cudd_Xgty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Xgty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a BDD for the function x &gt; y. </p>
<p>This function generates a BDD for the function x &gt; y. Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most significant bit. The BDD is built bottom-up. It has 3*N-1 internal nodes, if the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1]. Argument z is not used by Cudd_Xgty: it is included to make it call-compatible to Cudd_Dxygtdxz and Cudd_Dxygtdyz.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> <a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">N</td><td>number of x and y variables </td></tr>
    <tr><td class="paramname">z</td><td>array of z variables: unused </td></tr>
    <tr><td class="paramname">x</td><td>array of x variables </td></tr>
    <tr><td class="paramname">y</td><td>array of y variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e29f906fd682376f4b15676c840fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e29f906fd682376f4b15676c840fe2">&#9670;&nbsp;</a></span>Cudd_zddChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes a variable with its complement in a ZDD. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a749226024982a86616474fede5544632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749226024982a86616474fede5544632">&#9670;&nbsp;</a></span>Cudd_zddComplement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddComplement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a complement cover for a ZDD node. </p>
<p>For lack of a better method, we first extract the function BDD from the ZDD cover, then make the complement of the ZDD cover from the complement of the BDD node by using ISOP. The result depends on current variable order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting cover if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The result depends on current variable order.</dt><dd></dd></dl>

</div>
</div>
<a id="a9c5ab3f05743b5f9c2516058bde45dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ab3f05743b5f9c2516058bde45dc9">&#9670;&nbsp;</a></span>Cudd_zddCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of minterms in a ZDD. </p>
<p>Returns an integer representing the number of minterms in a ZDD.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddCount_8c.html#aa4865c5d167f246c03b1442e8183bd0d" title="Counts the number of minterms of a ZDD.">Cudd_zddCountDouble</a> </dd></dl>

</div>
</div>
<a id="aa4865c5d167f246c03b1442e8183bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4865c5d167f246c03b1442e8183bd0d">&#9670;&nbsp;</a></span>Cudd_zddCountDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_zddCountDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of minterms of a ZDD. </p>
<p>This procedure is used in Cudd_zddCountMinterm.</p>
<dl class="section return"><dt>Returns</dt><dd>the count. If the procedure runs out of memory, it returns (double) CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddMisc_8c.html#a6e2ada301191a7910766596736ac5b0a" title="Counts the number of minterms of a ZDD.">Cudd_zddCountMinterm</a> <a class="el" href="cuddZddCount_8c.html#a9c5ab3f05743b5f9c2516058bde45dc9" title="Counts the number of minterms in a ZDD.">Cudd_zddCount</a> </dd></dl>

</div>
</div>
<a id="a6e2ada301191a7910766596736ac5b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2ada301191a7910766596736ac5b0a">&#9670;&nbsp;</a></span>Cudd_zddCountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_zddCountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of minterms of a ZDD. </p>
<p>Counts the number of minterms of the ZDD rooted at <code>node</code>. This procedure takes a parameter <code>path</code> that specifies how many variables are in the support of the function.</p>
<dl class="section return"><dt>Returns</dt><dd>the count. If the procedure runs out of memory, it returns (double) CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddCount_8c.html#aa4865c5d167f246c03b1442e8183bd0d" title="Counts the number of minterms of a ZDD.">Cudd_zddCountDouble</a> </dd></dl>

</div>
</div>
<a id="a3e197e31a92ab28d9fc7fcfb75b52e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e197e31a92ab28d9fc7fcfb75b52e96">&#9670;&nbsp;</a></span>Cudd_zddCoverPathToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cudd_zddCoverPathToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a path of a ZDD representing a cover to a string. </p>
<p>The string represents an implicant of the cover. The path is typically produced by Cudd_zddForeachPath. If the str input is NULL, it allocates a new string. The string passed to this function must have enough room for all variables and for the terminator.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the string if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a7afa2381aa1f60094b325b10c0a5baa1" title="Iterates over the paths of a ZDD.">Cudd_zddForeachPath</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zdd</td><td>DD manager </td></tr>
    <tr><td class="paramname">path</td><td>path of ZDD representing a cover </td></tr>
    <tr><td class="paramname">str</td><td>pointer to string to use if != NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7634b40c8a867ba64b3cedbbd0e206d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7634b40c8a867ba64b3cedbbd0e206d2">&#9670;&nbsp;</a></span>Cudd_zddDagSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddDagSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>p_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a ZDD. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function duplicates Cudd_DagSize and is only retained for compatibility.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>

</div>
</div>
<a id="adc73fc58a0086966fcec55169951b61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc73fc58a0086966fcec55169951b61d">&#9670;&nbsp;</a></span>Cudd_zddDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of two ZDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a59302de6443444bd5a0cc69e0eb09533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59302de6443444bd5a0cc69e0eb09533">&#9670;&nbsp;</a></span>Cudd_zddDiffConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddDiffConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the inclusion test for ZDDs (P implies Q). </p>
<p>No new nodes are generated by this procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>empty if true; a valid pointer different from empty or DD_NON_CONSTANT otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddSetop_8c.html#adc73fc58a0086966fcec55169951b61d" title="Computes the difference of two ZDDs.">Cudd_zddDiff</a> </dd></dl>

</div>
</div>
<a id="a43e1add8b7cebce529186f3940c095f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e1add8b7cebce529186f3940c095f8">&#9670;&nbsp;</a></span>Cudd_zddDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the quotient of two unate covers. </p>
<p>Computes the quotient of two unate covers represented by ZDDs. Unate covers use one ZDD variable for each BDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ZDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddFuncs_8c.html#a104e65b094b4cfe361a4344fd7746b11" title="Applies weak division to two covers.">Cudd_zddWeakDiv</a> </dd></dl>

</div>
</div>
<a id="a8acdb146297a02315d409b7c050a6d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acdb146297a02315d409b7c050a6d5a">&#9670;&nbsp;</a></span>Cudd_zddDivideF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddDivideF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified version of Cudd_zddDivide. </p>
<p>This function may disappear in future releases.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a88773e8e965dfbfc98eb3f4e35d7f905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88773e8e965dfbfc98eb3f4e35d7f905">&#9670;&nbsp;</a></span>Cudd_zddDumpDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddDumpDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>inames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const *&#160;</td>
          <td class="paramname"><em>onames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a dot file representing the argument ZDDs. </p>
<p>Writes a file representing the argument ZDDs in a format suitable for the graph drawing program dot. Cudd_zddDumpDot does not close the file: This is the caller responsibility. Cudd_zddDumpDot uses a minimal unique subset of the hexadecimal address of a node as name for it. If the argument inames is non-null, it is assumed to hold the pointers to the names of the inputs. Similarly for onames. Cudd_zddDumpDot uses the following convention to draw arcs: </p><ul>
<li>
solid line: THEN arcs; </li>
<li>
dashed line: ELSE arcs. </li>
</ul>
<p>The dot options are chosen so that the drawing fits on a letter-size sheet.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise (e.g., out-of-memory, file system full).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddExport_8c.html#a9dfdcf8b654eec068f30275ff3f3e1b6" title="Writes a dot file representing the argument DDs.">Cudd_DumpDot</a> <a class="el" href="cuddZddUtil_8c.html#a79817362adfa41e6086266203743a5b8" title="Prints to the standard output a ZDD and its statistics.">Cudd_zddPrintDebug</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">n</td><td>number of output nodes to be dumped </td></tr>
    <tr><td class="paramname">f</td><td>array of output nodes to be dumped </td></tr>
    <tr><td class="paramname">inames</td><td>array of input names (or NULL) </td></tr>
    <tr><td class="paramname">onames</td><td>array of output names (or NULL) </td></tr>
    <tr><td class="paramname">fp</td><td>pointer to the dump file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a191a6e2d60cca93f876d66e9bda6bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191a6e2d60cca93f876d66e9bda6bb6b">&#9670;&nbsp;</a></span>Cudd_zddFirstPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_zddFirstPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first path of a ZDD. </p>
<p>Defines an iterator on the paths of a ZDD and finds its first path.</p>
<p>A path is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents an else arc out of a node, 1 represents a then arc out of a node, and 2 stands for the absence of a node. The size of the array equals the number of variables in the manager at the time Cudd_zddFirstCube is called.</p>
<p>The paths that end in the empty terminal are not enumerated.</p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first path is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a7afa2381aa1f60094b325b10c0a5baa1" title="Iterates over the paths of a ZDD.">Cudd_zddForeachPath</a> <a class="el" href="cuddZddUtil_8c.html#aed8c3a1a1e5ce89ac7a24749c1568937" title="Generates the next path of a ZDD.">Cudd_zddNextPath</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> </dd></dl>

</div>
</div>
<a id="a8be281a73703e9d817bb3e497e35d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be281a73703e9d817bb3e497e35d0fd">&#9670;&nbsp;</a></span>Cudd_zddIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of two ZDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2b5124feb3accdd31cfeb287ffff59f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5124feb3accdd31cfeb287ffff59f7">&#9670;&nbsp;</a></span>Cudd_zddIsop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddIsop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>zdd_I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an ISOP in ZDD form from BDDs. </p>
<p>Computes an irredundant sum of products (ISOP) in ZDD form from BDDs. The two BDDs L and U represent the lower bound and the upper bound, respectively, of the function. The ISOP uses two ZDD variables for each BDD variable: One for the positive literal, and one for the negative literal. These two variables should be adjacent in the ZDD order. The two ZDD variables corresponding to BDD variable <code>i</code> should have indices <code>2i</code> and <code>2i+1</code>. The result of this procedure depends on the variable order. If successful, Cudd_zddIsop returns the BDD for the function chosen from the interval. The ZDD representing the irredundant cover is returned as a side effect in zdd_I. In case of failure, NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the BDD for the chosen function if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n zdd_I holds the pointer to the ZDD for the ISOP on</dt><dd>successful return.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddIsop_8c.html#a17691865ef8b69e1d04ce5651da841e0" title="Computes a BDD in the interval between L and U with a simple sum-of-product cover.">Cudd_bddIsop</a> <a class="el" href="cuddAPI_8c.html#a45d898e3087539ceaaf5ff86aa62c471" title="Creates one or more ZDD variables for each BDD variable.">Cudd_zddVarsFromBddVars</a> </dd></dl>

</div>
</div>
<a id="a41777e8aa4a688ac964ea2564e5ae4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41777e8aa4a688ac964ea2564e5ae4be">&#9670;&nbsp;</a></span>Cudd_zddIte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddIte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ITE of three ZDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="acbf8017813ae9a60790ae4f8a445800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf8017813ae9a60790ae4f8a445800d">&#9670;&nbsp;</a></span>Cudd_zddIthVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddIthVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ZDD variable with index i. </p>
<p>Retrieves the ZDD variable with index i if it already exists, or creates a new ZDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the variable if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#a19967d7c87650f63fc312f38c318e3e9" title="Returns the ADD variable with index i.">Cudd_addIthVar</a> </dd></dl>

</div>
</div>
<a id="aed8c3a1a1e5ce89ac7a24749c1568937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8c3a1a1e5ce89ac7a24749c1568937">&#9670;&nbsp;</a></span>Cudd_zddNextPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddNextPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the next path of a ZDD. </p>
<p>Generates the next path of a ZDD onset, using generator gen.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The path is returned as a side effect. The generator is</dt><dd>modified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a7afa2381aa1f60094b325b10c0a5baa1" title="Iterates over the paths of a ZDD.">Cudd_zddForeachPath</a> <a class="el" href="cuddZddUtil_8c.html#a191a6e2d60cca93f876d66e9bda6bb6b" title="Finds the first path of a ZDD.">Cudd_zddFirstPath</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> </dd></dl>

</div>
</div>
<a id="acf5f6cf86e962f2caef6492052039237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5f6cf86e962f2caef6492052039237">&#9670;&nbsp;</a></span>Cudd_zddPortFromBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddPortFromBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a BDD into a ZDD. </p>
<p>This function assumes that there is a one-to-one correspondence between the BDD variables and the ZDD variables, and that the variable order is the same for both types of variables. These conditions are established if the ZDD variables are created by one call to Cudd_zddVarsFromBddVars with multiplicity = 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ZDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a45d898e3087539ceaaf5ff86aa62c471" title="Creates one or more ZDD variables for each BDD variable.">Cudd_zddVarsFromBddVars</a> </dd></dl>

</div>
</div>
<a id="a4f3cdf0b63218f1adf43c59a29650d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3cdf0b63218f1adf43c59a29650d76">&#9670;&nbsp;</a></span>Cudd_zddPortToBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddPortToBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ZDD into a BDD. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resulting ZDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddPort_8c.html#acf5f6cf86e962f2caef6492052039237" title="Converts a BDD into a ZDD.">Cudd_zddPortFromBdd</a> </dd></dl>

</div>
</div>
<a id="ad9bcb316ffbbb024faeda00c8aea85bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bcb316ffbbb024faeda00c8aea85bf">&#9670;&nbsp;</a></span>Cudd_zddPrintCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddPrintCover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a sum of products from a ZDD representing a cover. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddUtil_8c.html#ac775341084fce61a34c46ecedd726075" title="Prints a disjoint sum of product form for a ZDD.">Cudd_zddPrintMinterm</a> </dd></dl>

</div>
</div>
<a id="a79817362adfa41e6086266203743a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79817362adfa41e6086266203743a5b8">&#9670;&nbsp;</a></span>Cudd_zddPrintDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddPrintDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to the standard output a ZDD and its statistics. </p>
<p>The statistics include the number of nodes and the number of minterms. (The number of minterms is also the number of combinations in the set.) The statistics are printed if pr &gt; 0. Specifically: </p><ul>
<li>
pr = 0 : prints nothing </li>
<li>
pr = 1 : prints counts of nodes and minterms </li>
<li>
pr = 2 : prints counts + disjoint sum of products </li>
<li>
pr = 3 : prints counts + list of nodes </li>
<li>
pr &gt; 3 : prints counts + disjoint sum of products + list of nodes </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ac775341084fce61a34c46ecedd726075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac775341084fce61a34c46ecedd726075">&#9670;&nbsp;</a></span>Cudd_zddPrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddPrintMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>zdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a disjoint sum of product form for a ZDD. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddUtil_8c.html#a79817362adfa41e6086266203743a5b8" title="Prints to the standard output a ZDD and its statistics.">Cudd_zddPrintDebug</a> <a class="el" href="cuddZddUtil_8c.html#ad9bcb316ffbbb024faeda00c8aea85bf" title="Prints a sum of products from a ZDD representing a cover.">Cudd_zddPrintCover</a> </dd></dl>

</div>
</div>
<a id="a42425fde9bd20de470d590dae86fe111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42425fde9bd20de470d590dae86fe111">&#9670;&nbsp;</a></span>Cudd_zddPrintSubtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddPrintSubtable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the ZDD table for debugging purposes. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a419b6b27fabd4f4994c1c5df0c5527cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419b6b27fabd4f4994c1c5df0c5527cb">&#9670;&nbsp;</a></span>Cudd_zddProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of two covers represented by ZDDs. </p>
<p>The result is also a ZDD. The covers on which Cudd_zddProduct operates use two ZDD variables for each function variable (one ZDD variable for each literal of the variable). Those two ZDD variables should be adjacent in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddFuncs_8c.html#a4eb4a8cdc966acd5bd4ddabc42c6fb8e" title="Computes the product of two unate covers represented as ZDDs.">Cudd_zddUnateProduct</a> </dd></dl>

</div>
</div>
<a id="a4c015c746d9c71fb9b57249f2a4ccd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c015c746d9c71fb9b57249f2a4ccd72">&#9670;&nbsp;</a></span>Cudd_zddReadNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cudd_zddReadNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of nodes in ZDDs. </p>
<p>This number always includes the two constants 1 and 0.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a39633df05be731b6b145d65f83aed572" title="Reports the peak number of nodes.">Cudd_ReadPeakNodeCount</a> <a class="el" href="cuddAPI_8c.html#a9ba2c88b8f70df51791c26ffde800fc7" title="Reports the number of nodes in BDDs and ADDs.">Cudd_ReadNodeCount</a> </dd></dl>

</div>
</div>
<a id="afea01466660ca226539a66a014a4da00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea01466660ca226539a66a014a4da00">&#9670;&nbsp;</a></span>Cudd_zddRealignDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddRealignDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables realignment of ZDD order to BDD order. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="aa57aff1886a1fea0cb8b5bf8d66cf50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57aff1886a1fea0cb8b5bf8d66cf50e">&#9670;&nbsp;</a></span>Cudd_zddRealignEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddRealignEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables realignment of ZDD order to BDD order. </p>
<p>Enables realignment of the ZDD variable order to the BDD variable order after the BDDs and ADDs have been reordered. The number of ZDD variables must be a multiple of the number of BDD variables for realignment to make sense. If this condition is not met, Cudd_ReduceHeap will return 0. Let <code>M</code> be the ratio of the two numbers. For the purpose of realignment, the ZDD variables from <code>M*i</code> to <code>(M+1)*i-1</code> are reagarded as corresponding to BDD variable <code>i</code>. Realignment is initially disabled.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddReorder_8c.html#a02a5a86dfb8ebc7726d6cf56b6a7eec1" title="Main dynamic reordering routine.">Cudd_ReduceHeap</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a34225975eef55170213a0a9efed5a891" title="Tells whether the realignment of ZDD order to BDD order is enabled.">Cudd_zddRealignmentEnabled</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a516183604a75b38337b81fd17c291826" title="Tells whether the realignment of BDD order to ZDD order is enabled.">Cudd_bddRealignmentEnabled</a> </dd></dl>

</div>
</div>
<a id="a34225975eef55170213a0a9efed5a891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34225975eef55170213a0a9efed5a891">&#9670;&nbsp;</a></span>Cudd_zddRealignmentEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddRealignmentEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the realignment of ZDD order to BDD order is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the realignment of ZDD order to BDD order is enabled; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#aa57aff1886a1fea0cb8b5bf8d66cf50e" title="Enables realignment of ZDD order to BDD order.">Cudd_zddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#afea01466660ca226539a66a014a4da00" title="Disables realignment of ZDD order to BDD order.">Cudd_zddRealignDisable</a> <a class="el" href="cuddAPI_8c.html#a2d0d34d836668fc62e7c7835fa95132d" title="Enables realignment of BDD order to ZDD order.">Cudd_bddRealignEnable</a> <a class="el" href="cuddAPI_8c.html#a3eb093bdd80db0b880f61017f3e36de2" title="Disables realignment of ZDD order to BDD order.">Cudd_bddRealignDisable</a> </dd></dl>

</div>
</div>
<a id="ab2a6a57fc8464e16e222c130aed593d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a6a57fc8464e16e222c130aed593d9">&#9670;&nbsp;</a></span>Cudd_zddReduceHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddReduceHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a8ff397cb64855989d6ad62a491e20dde">Cudd_ReorderingType</a>&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main dynamic reordering routine for ZDDs. </p>
<p>Calls one of the possible reordering procedures: </p><ul>
<li>
Swapping </li>
<li>
Sifting </li>
<li>
Symmetric Sifting </li>
</ul>
<p>For sifting and symmetric sifting it is possible to request reordering to convergence.</p>
<p>The core of all methods is the reordering procedure <a class="el" href="cuddZddReord_8c.html#a89a9fd8d4d09048463a62256b8dab6c9" title="Swaps two adjacent variables.">cuddZddSwapInPlace()</a> which swaps two adjacent variables. </p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise. In the case of symmetric sifting (with and without convergence) returns 1 plus the number of symmetric variables, in case of success.</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the variable order for all ZDDs and clears</dt><dd>the cache. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td><a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> manager </td></tr>
    <tr><td class="paramname">heuristic</td><td>method used for reordering </td></tr>
    <tr><td class="paramname">minsize</td><td>bound below which no reordering occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f07e5730ad04e0217b2b6a8e813042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f07e5730ad04e0217b2b6a8e813042">&#9670;&nbsp;</a></span>Cudd_zddShuffleHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddShuffleHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders ZDD variables according to given permutation. </p>
<p>The i-th entry of the permutation array contains the index of the variable that should be brought to the i-th level. The size of the array should be equal or greater to the number of variables currently in use.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n Changes the ZDD variable order for all diagrams and clears</dt><dd>the cache.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddReord_8c.html#ab2a6a57fc8464e16e222c130aed593d9" title="Main dynamic reordering routine for ZDDs.">Cudd_zddReduceHeap</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td><a class="el" href="classDD.html" title="Base class for all decision diagrams in CUDD.">DD</a> manager </td></tr>
    <tr><td class="paramname">permutation</td><td>required variable permutation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0822a83d4fd25d1e68969fe283886ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0822a83d4fd25d1e68969fe283886ac">&#9670;&nbsp;</a></span>Cudd_zddSubset0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddSubset0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the negative cofactor of a ZDD w.r.t. a variable. </p>
<p>In terms of combinations, the result is the set of all combinations in which the variable is negated.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddSetop_8c.html#a6ca2965bda4c37d1dbb881325644804b" title="Computes the positive cofactor of a ZDD w.r.t. a variable.">Cudd_zddSubset1</a> </dd></dl>

</div>
</div>
<a id="a6ca2965bda4c37d1dbb881325644804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2965bda4c37d1dbb881325644804b">&#9670;&nbsp;</a></span>Cudd_zddSubset1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddSubset1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the positive cofactor of a ZDD w.r.t. a variable. </p>
<p>In terms of combinations, the result is the set of all combinations in which the variable is asserted.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddSetop_8c.html#ad0822a83d4fd25d1e68969fe283886ac" title="Computes the negative cofactor of a ZDD w.r.t. a variable.">Cudd_zddSubset0</a> </dd></dl>

</div>
</div>
<a id="a402e14381ae82e3938e6323517cf5f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402e14381ae82e3938e6323517cf5f27">&#9670;&nbsp;</a></span>Cudd_zddSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a ZDD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>a BDD consisting of the product of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>ZDD whose support is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b65104f2aa3b0e5719e73ac8c20f12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b65104f2aa3b0e5719e73ac8c20f12e">&#9670;&nbsp;</a></span>Cudd_zddSymmProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_zddSymmProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints statistics on symmetric ZDD variables. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a4eb4a8cdc966acd5bd4ddabc42c6fb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb4a8cdc966acd5bd4ddabc42c6fb8e">&#9670;&nbsp;</a></span>Cudd_zddUnateProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddUnateProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of two unate covers represented as ZDDs. </p>
<p>Unate covers use one ZDD variable for each BDD variable.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddFuncs_8c.html#a419b6b27fabd4f4994c1c5df0c5527cb" title="Computes the product of two covers represented by ZDDs.">Cudd_zddProduct</a> </dd></dl>

</div>
</div>
<a id="a5fc0f519f9a3aa14a3ee376c3e65e13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc0f519f9a3aa14a3ee376c3e65e13b">&#9670;&nbsp;</a></span>Cudd_zddUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of two ZDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a45d898e3087539ceaaf5ff86aa62c471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d898e3087539ceaaf5ff86aa62c471">&#9670;&nbsp;</a></span>Cudd_zddVarsFromBddVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_zddVarsFromBddVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multiplicity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates one or more ZDD variables for each BDD variable. </p>
<p>If some ZDD variables already exist, only the missing variables are created. Parameter multiplicity allows the caller to control how many variables are created for each BDD variable in existence. For instance, if ZDDs are used to represent covers, two ZDD variables are required for each BDD variable. The order of the BDD variables is transferred to the ZDD variables. If a variable group tree exists for the BDD variables, a corresponding ZDD variable group tree is created by expanding the BDD variable tree. In any case, the ZDD variables derived from the same BDD variable are merged in a ZDD variable group. If a ZDD variable group tree exists, it is freed.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddAPI_8c.html#a475c50e1a273569cc0ffc19ab98c28ce" title="Returns a new BDD variable.">Cudd_bddNewVar</a> <a class="el" href="cuddAPI_8c.html#a40fd71665cde402bd5bc4f39015c09ae" title="Returns the BDD variable with index i.">Cudd_bddIthVar</a> <a class="el" href="cuddAPI_8c.html#ae35eac7df807101795efe0d582ff05fa" title="Returns a new BDD variable at a specified level.">Cudd_bddNewVarAtLevel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">multiplicity</td><td>how many ZDD variables are created for each BDD variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a104e65b094b4cfe361a4344fd7746b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104e65b094b4cfe361a4344fd7746b11">&#9670;&nbsp;</a></span>Cudd_zddWeakDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddWeakDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies weak division to two covers. </p>
<p>Applies weak division to two ZDDs representing two covers. The result of weak division depends on the variable order. The covers on which Cudd_zddWeakDiv operates use two ZDD variables for each function variable (one ZDD variable for each literal of the variable). Those two ZDD variables should be adjacent in the order.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the ZDD representing the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddFuncs_8c.html#a43e1add8b7cebce529186f3940c095f8" title="Computes the quotient of two unate covers.">Cudd_zddDivide</a> </dd></dl>

</div>
</div>
<a id="ae7919ec84ae5121722ca263298f81edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7919ec84ae5121722ca263298f81edb">&#9670;&nbsp;</a></span>Cudd_zddWeakDivF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_zddWeakDivF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified version of Cudd_zddWeakDiv. </p>
<p>This function may disappear in future releases.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddZddFuncs_8c.html#a104e65b094b4cfe361a4344fd7746b11" title="Applies weak division to two covers.">Cudd_zddWeakDiv</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2020 20:59:18 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
