<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddUtil.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddUtil.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;float.h&gt;</code><br />
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="epdInt_8h_source.html">epdInt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddUtil.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddUtil_8c__incl.png" border="0" usemap="#cudd_2cuddUtil_8c" alt=""/></div>
<map name="cudd_2cuddUtil_8c" id="cudd_2cuddUtil_8c">
<area shape="rect"  title="Utility functions." alt="" coords="352,5,475,32"/>
<area shape="rect"  title=" " alt="" coords="199,80,274,107"/>
<area shape="rect"  title=" " alt="" coords="298,80,362,107"/>
<area shape="rect"  href="util_8h.html" title="Low&#45;level utilities." alt="" coords="386,80,441,107"/>
<area shape="rect"  href="epdInt_8h.html" title="Internal header for the University of Colorado extended double precision package." alt="" coords="572,80,647,107"/>
<area shape="rect"  href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="746,80,828,107"/>
<area shape="rect"  title=" " alt="" coords="572,155,647,181"/>
<area shape="rect"  title=" " alt="" coords="39,155,114,181"/>
<area shape="rect"  title=" " alt="" coords="138,155,212,181"/>
<area shape="rect"  title=" " alt="" coords="706,229,772,256"/>
<area shape="rect"  title=" " alt="" coords="237,155,308,181"/>
<area shape="rect"  title=" " alt="" coords="332,155,402,181"/>
<area shape="rect"  title=" " alt="" coords="426,155,497,181"/>
<area shape="rect"  title=" " alt="" coords="378,229,465,256"/>
<area shape="rect"  href="epd_8h.html" title="The University of Colorado extended double precision package." alt="" coords="671,155,730,181"/>
<area shape="rect"  title=" " alt="" coords="996,155,1064,181"/>
<area shape="rect"  href="st_8h.html" title="Symbol table package." alt="" coords="844,155,890,181"/>
<area shape="rect"  href="mtr_8h.html" title="Multiway&#45;branch tree manipulation." alt="" coords="914,155,972,181"/>
<area shape="rect"  href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="754,155,820,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4b0bfe94cfc1d904f790b73ccbbcb618"><td class="memItemLeft" align="right" valign="top"><a id="a4b0bfe94cfc1d904f790b73ccbbcb618"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULUS1</b>&#160;&#160;&#160;2147483563</td></tr>
<tr class="separator:a4b0bfe94cfc1d904f790b73ccbbcb618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad536bbe3cf7c563beb632f9a2873ee74"><td class="memItemLeft" align="right" valign="top"><a id="ad536bbe3cf7c563beb632f9a2873ee74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQA1</b>&#160;&#160;&#160;40014</td></tr>
<tr class="separator:ad536bbe3cf7c563beb632f9a2873ee74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c8d2df6537ba8ca17782d2551cd39"><td class="memItemLeft" align="right" valign="top"><a id="ae51c8d2df6537ba8ca17782d2551cd39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQQ1</b>&#160;&#160;&#160;53668</td></tr>
<tr class="separator:ae51c8d2df6537ba8ca17782d2551cd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbaa4f61345fe29372903e5f46296ce"><td class="memItemLeft" align="right" valign="top"><a id="a9dbaa4f61345fe29372903e5f46296ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQR1</b>&#160;&#160;&#160;12211</td></tr>
<tr class="separator:a9dbaa4f61345fe29372903e5f46296ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18fd420e3aea20f837650582dd0ec2d"><td class="memItemLeft" align="right" valign="top"><a id="aa18fd420e3aea20f837650582dd0ec2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULUS2</b>&#160;&#160;&#160;2147483399</td></tr>
<tr class="separator:aa18fd420e3aea20f837650582dd0ec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1234a96cbc700be724f6b7123eee73b2"><td class="memItemLeft" align="right" valign="top"><a id="a1234a96cbc700be724f6b7123eee73b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQA2</b>&#160;&#160;&#160;40692</td></tr>
<tr class="separator:a1234a96cbc700be724f6b7123eee73b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922e3cbb3f5a996cdec86b57fd9cebb"><td class="memItemLeft" align="right" valign="top"><a id="a3922e3cbb3f5a996cdec86b57fd9cebb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQQ2</b>&#160;&#160;&#160;52774</td></tr>
<tr class="separator:a3922e3cbb3f5a996cdec86b57fd9cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc94b275fe971a3b3fa4f0961e3ddafd"><td class="memItemLeft" align="right" valign="top"><a id="acc94b275fe971a3b3fa4f0961e3ddafd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LEQR2</b>&#160;&#160;&#160;3791</td></tr>
<tr class="separator:acc94b275fe971a3b3fa4f0961e3ddafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f73d503bb99c5e8d750f9152caa5926"><td class="memItemLeft" align="right" valign="top"><a id="a2f73d503bb99c5e8d750f9152caa5926"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STAB_DIV</b>&#160;&#160;&#160;(1 + (MODULUS1 - 1) / <a class="el" href="cuddInt_8h.html#ab2d303f24064e7fe8aa868d2e8850ab2">STAB_SIZE</a>)</td></tr>
<tr class="separator:a2f73d503bb99c5e8d750f9152caa5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2c4a63badba1daf2d17524b546d120"><td class="memItemLeft" align="right" valign="top"><a id="a6c2c4a63badba1daf2d17524b546d120"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>bang</b>(f)&#160;&#160;&#160;((<a class="el" href="cudd_8h.html#a35322518c24f65f44eda9623083cb62c">Cudd_IsComplement</a>(f)) ? '!' : ' ')</td></tr>
<tr class="separator:a6c2c4a63badba1daf2d17524b546d120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeab82cceadafa2b81083e0467c102526"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aeab82cceadafa2b81083e0467c102526">Cudd_PrintMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:aeab82cceadafa2b81083e0467c102526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a disjoint sum of products.  <a href="#aeab82cceadafa2b81083e0467c102526">More...</a><br /></td></tr>
<tr class="separator:aeab82cceadafa2b81083e0467c102526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61fadaf6046697691b35fad8c9faf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a8b61fadaf6046697691b35fad8c9faf0">Cudd_bddPrintCover</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr class="memdesc:a8b61fadaf6046697691b35fad8c9faf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a sum of prime implicants of a BDD.  <a href="#a8b61fadaf6046697691b35fad8c9faf0">More...</a><br /></td></tr>
<tr class="separator:a8b61fadaf6046697691b35fad8c9faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46a1b9147411ce547a2e03305d6c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22">Cudd_PrintDebug</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int n, int pr)</td></tr>
<tr class="memdesc:a1e46a1b9147411ce547a2e03305d6c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to the manager standard output a DD and its statistics.  <a href="#a1e46a1b9147411ce547a2e03305d6c22">More...</a><br /></td></tr>
<tr class="separator:a1e46a1b9147411ce547a2e03305d6c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac610821afa1bb9ad8432a3c656eb81cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ac610821afa1bb9ad8432a3c656eb81cd">Cudd_PrintSummary</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int n, int mode)</td></tr>
<tr class="memdesc:ac610821afa1bb9ad8432a3c656eb81cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a one-line summary of an ADD or BDD to the manager stdout.  <a href="#ac610821afa1bb9ad8432a3c656eb81cd">More...</a><br /></td></tr>
<tr class="separator:ac610821afa1bb9ad8432a3c656eb81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf613390a7dbeaad14b3963d68de24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24">Cudd_DagSize</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a95cf613390a7dbeaad14b3963d68de24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a DD.  <a href="#a95cf613390a7dbeaad14b3963d68de24">More...</a><br /></td></tr>
<tr class="separator:a95cf613390a7dbeaad14b3963d68de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc492a365b6e11544b5b2bda4ac76a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#abc492a365b6e11544b5b2bda4ac76a34">Cudd_EstimateCofactor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i, int phase)</td></tr>
<tr class="memdesc:abc492a365b6e11544b5b2bda4ac76a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of nodes in a cofactor of a DD.  <a href="#abc492a365b6e11544b5b2bda4ac76a34">More...</a><br /></td></tr>
<tr class="separator:abc492a365b6e11544b5b2bda4ac76a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23b2111b9f214571866c6e88035a9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a3e23b2111b9f214571866c6e88035a9d">Cudd_EstimateCofactorSimple</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, int i)</td></tr>
<tr class="memdesc:a3e23b2111b9f214571866c6e88035a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of nodes in a cofactor of a DD.  <a href="#a3e23b2111b9f214571866c6e88035a9d">More...</a><br /></td></tr>
<tr class="separator:a3e23b2111b9f214571866c6e88035a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d57cfc6ede9ae452a40779b58a3bac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a49d57cfc6ede9ae452a40779b58a3bac">Cudd_SharingSize</a> (<a class="el" href="structDdNode.html">DdNode</a> **nodeArray, int n)</td></tr>
<tr class="memdesc:a49d57cfc6ede9ae452a40779b58a3bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in an array of DDs.  <a href="#a49d57cfc6ede9ae452a40779b58a3bac">More...</a><br /></td></tr>
<tr class="separator:a49d57cfc6ede9ae452a40779b58a3bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f187be7f86701d59f924860970a0b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9">Cudd_CountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:aa1f187be7f86701d59f924860970a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the minterms of an ADD or BDD.  <a href="#aa1f187be7f86701d59f924860970a0b9">More...</a><br /></td></tr>
<tr class="separator:aa1f187be7f86701d59f924860970a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95929aeb92541971db3e5798920e6882"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882">Cudd_CountPath</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a95929aeb92541971db3e5798920e6882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the paths of a DD.  <a href="#a95929aeb92541971db3e5798920e6882">More...</a><br /></td></tr>
<tr class="separator:a95929aeb92541971db3e5798920e6882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ee5461ed7f497f7b43fb643b517c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99">Cudd_EpdCountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars, <a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *epd)</td></tr>
<tr class="memdesc:a91ee5461ed7f497f7b43fb643b517c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the minterms of an ADD or BDD with extended range.  <a href="#a91ee5461ed7f497f7b43fb643b517c99">More...</a><br /></td></tr>
<tr class="separator:a91ee5461ed7f497f7b43fb643b517c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb9e0fde5043297b133ce6516e9a99"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a91cb9e0fde5043297b133ce6516e9a99">Cudd_LdblCountMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:a91cb9e0fde5043297b133ce6516e9a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of minterms of aa ADD or BDD as a long double.  <a href="#a91cb9e0fde5043297b133ce6516e9a99">More...</a><br /></td></tr>
<tr class="separator:a91cb9e0fde5043297b133ce6516e9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a38e134284702f2455b5454ff0ece5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa5a38e134284702f2455b5454ff0ece5">Cudd_EpdPrintMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> const *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars)</td></tr>
<tr class="memdesc:aa5a38e134284702f2455b5454ff0ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of minterms of an ADD or BDD with extended range.  <a href="#aa5a38e134284702f2455b5454ff0ece5">More...</a><br /></td></tr>
<tr class="separator:aa5a38e134284702f2455b5454ff0ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1533ac1641e3ee3260d336e863052c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2b1533ac1641e3ee3260d336e863052c">Cudd_CountPathsToNonZero</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a2b1533ac1641e3ee3260d336e863052c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the paths to a non-zero terminal of a DD.  <a href="#a2b1533ac1641e3ee3260d336e863052c">More...</a><br /></td></tr>
<tr class="separator:a2b1533ac1641e3ee3260d336e863052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e317288c1b57e0097013d52435d23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a455e317288c1b57e0097013d52435d23">Cudd_SupportIndices</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int **indices)</td></tr>
<tr class="memdesc:a455e317288c1b57e0097013d52435d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#a455e317288c1b57e0097013d52435d23">More...</a><br /></td></tr>
<tr class="separator:a455e317288c1b57e0097013d52435d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f8e5b8efe97330f8650e1378ad172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172">Cudd_Support</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a9e1f8e5b8efe97330f8650e1378ad172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#a9e1f8e5b8efe97330f8650e1378ad172">More...</a><br /></td></tr>
<tr class="separator:a9e1f8e5b8efe97330f8650e1378ad172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc898f0fe024bece58bb9e992845bb73"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73">Cudd_SupportIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:adc898f0fe024bece58bb9e992845bb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a DD depends.  <a href="#adc898f0fe024bece58bb9e992845bb73">More...</a><br /></td></tr>
<tr class="separator:adc898f0fe024bece58bb9e992845bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a0e7cde5c4dfd8832de07de9b31e9469e">Cudd_SupportSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the variables on which a DD depends.  <a href="#a0e7cde5c4dfd8832de07de9b31e9469e">More...</a><br /></td></tr>
<tr class="separator:a0e7cde5c4dfd8832de07de9b31e9469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd4942d4c62cb3a539a8039084d571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571">Cudd_VectorSupportIndices</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n, int **indices)</td></tr>
<tr class="memdesc:ac6fd4942d4c62cb3a539a8039084d571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#ac6fd4942d4c62cb3a539a8039084d571">More...</a><br /></td></tr>
<tr class="separator:ac6fd4942d4c62cb3a539a8039084d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b">Cudd_VectorSupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#a8f6cf8a1719f76a3e121e7f61c406d5b">More...</a><br /></td></tr>
<tr class="separator:a8f6cf8a1719f76a3e121e7f61c406d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a3eda5431ad0985605921d16c83067"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa3a3eda5431ad0985605921d16c83067">Cudd_VectorSupportIndex</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:aa3a3eda5431ad0985605921d16c83067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the variables on which a set of DDs depends.  <a href="#aa3a3eda5431ad0985605921d16c83067">More...</a><br /></td></tr>
<tr class="separator:aa3a3eda5431ad0985605921d16c83067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a66da9c2c22b9bbb31120bd0a28fbf83c">Cudd_VectorSupportSize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **F, int n)</td></tr>
<tr class="memdesc:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the variables on which a set of DDs depends.  <a href="#a66da9c2c22b9bbb31120bd0a28fbf83c">More...</a><br /></td></tr>
<tr class="separator:a66da9c2c22b9bbb31120bd0a28fbf83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf3183bbb7822b76bacd8b70aebc94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94">Cudd_ClassifySupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> **common, <a class="el" href="structDdNode.html">DdNode</a> **onlyF, <a class="el" href="structDdNode.html">DdNode</a> **onlyG)</td></tr>
<tr class="memdesc:a2caf3183bbb7822b76bacd8b70aebc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies the variables in the support of two DDs.  <a href="#a2caf3183bbb7822b76bacd8b70aebc94">More...</a><br /></td></tr>
<tr class="separator:a2caf3183bbb7822b76bacd8b70aebc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af4867b046a794f5db312c69922790d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2af4867b046a794f5db312c69922790d">Cudd_CountLeaves</a> (<a class="el" href="structDdNode.html">DdNode</a> *node)</td></tr>
<tr class="memdesc:a2af4867b046a794f5db312c69922790d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of leaves in a DD.  <a href="#a2af4867b046a794f5db312c69922790d">More...</a><br /></td></tr>
<tr class="separator:a2af4867b046a794f5db312c69922790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc47738ff8b49602d4e1442fd55576f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#adcc47738ff8b49602d4e1442fd55576f">Cudd_bddPickOneCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *ddm, <a class="el" href="structDdNode.html">DdNode</a> *node, char *string)</td></tr>
<tr class="memdesc:adcc47738ff8b49602d4e1442fd55576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks one on-set cube randomly from the given DD.  <a href="#adcc47738ff8b49602d4e1442fd55576f">More...</a><br /></td></tr>
<tr class="separator:adcc47738ff8b49602d4e1442fd55576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f68528887c0feb428d010c2173a59b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a57f68528887c0feb428d010c2173a59b">Cudd_bddPickOneMinterm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int n)</td></tr>
<tr class="memdesc:a57f68528887c0feb428d010c2173a59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks one on-set minterm randomly from the given DD.  <a href="#a57f68528887c0feb428d010c2173a59b">More...</a><br /></td></tr>
<tr class="separator:a57f68528887c0feb428d010c2173a59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a57c4e8e8d0b9ec3101e117629a2a459d">Cudd_bddPickArbitraryMinterms</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int n, int k)</td></tr>
<tr class="memdesc:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks k on-set minterms evenly distributed from given DD.  <a href="#a57c4e8e8d0b9ec3101e117629a2a459d">More...</a><br /></td></tr>
<tr class="separator:a57c4e8e8d0b9ec3101e117629a2a459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7410606294a5fb0896c8787019db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ab8e7410606294a5fb0896c8787019db1">Cudd_SubsetWithMaskVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vars, int nvars, <a class="el" href="structDdNode.html">DdNode</a> **maskVars, int mvars)</td></tr>
<tr class="memdesc:ab8e7410606294a5fb0896c8787019db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a subset from a BDD.  <a href="#ab8e7410606294a5fb0896c8787019db1">More...</a><br /></td></tr>
<tr class="separator:ab8e7410606294a5fb0896c8787019db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4">Cudd_FirstCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int **cube, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *value)</td></tr>
<tr class="memdesc:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first cube of a decision diagram.  <a href="#a139d8dd64955ecf3e2fd4c5d6ceeebb4">More...</a><br /></td></tr>
<tr class="separator:a139d8dd64955ecf3e2fd4c5d6ceeebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8">Cudd_NextCube</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, int **cube, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *value)</td></tr>
<tr class="memdesc:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next cube of a decision diagram onset.  <a href="#a05f1698806d45eaba7f4a5721dd5c3c8">More...</a><br /></td></tr>
<tr class="separator:a05f1698806d45eaba7f4a5721dd5c3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65691b560210512cf1f8d92f0c1ece9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a65691b560210512cf1f8d92f0c1ece9a">Cudd_FirstPrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u, int **cube)</td></tr>
<tr class="memdesc:a65691b560210512cf1f8d92f0c1ece9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first prime of a Boolean function.  <a href="#a65691b560210512cf1f8d92f0c1ece9a">More...</a><br /></td></tr>
<tr class="separator:a65691b560210512cf1f8d92f0c1ece9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73">Cudd_NextPrime</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, int **cube)</td></tr>
<tr class="memdesc:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next prime of a Boolean function.  <a href="#ae9c8ccb352d96ca9bde4ab97a1ee8e73">More...</a><br /></td></tr>
<tr class="separator:ae9c8ccb352d96ca9bde4ab97a1ee8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581">Cudd_bddComputeCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **vars, int *phase, int n)</td></tr>
<tr class="memdesc:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cube of an array of BDD variables.  <a href="#ab538e936fe0bdfe380f0ad2ecd2c6581">More...</a><br /></td></tr>
<tr class="separator:ab538e936fe0bdfe380f0ad2ecd2c6581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7d0901cba492671c25ee816510867c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2e7d0901cba492671c25ee816510867c">Cudd_addComputeCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **vars, int *phase, int n)</td></tr>
<tr class="memdesc:a2e7d0901cba492671c25ee816510867c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cube of an array of ADD variables.  <a href="#a2e7d0901cba492671c25ee816510867c">More...</a><br /></td></tr>
<tr class="separator:a2e7d0901cba492671c25ee816510867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2d2f87d831cfe727250103fc880da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da">Cudd_CubeArrayToBdd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int *array)</td></tr>
<tr class="memdesc:a4ac2d2f87d831cfe727250103fc880da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the BDD of a cube from a positional array.  <a href="#a4ac2d2f87d831cfe727250103fc880da">More...</a><br /></td></tr>
<tr class="separator:a4ac2d2f87d831cfe727250103fc880da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53ebc58628a5a659b86025e6ed9c492"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ab53ebc58628a5a659b86025e6ed9c492">Cudd_BddToCubeArray</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, int *array)</td></tr>
<tr class="memdesc:ab53ebc58628a5a659b86025e6ed9c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a positional array from the BDD of a cube.  <a href="#ab53ebc58628a5a659b86025e6ed9c492">More...</a><br /></td></tr>
<tr class="separator:ab53ebc58628a5a659b86025e6ed9c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f">Cudd_FirstNode</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **node)</td></tr>
<tr class="memdesc:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first node of a decision diagram.  <a href="#a0cbbad0f18b5767a4924ff6b069bbc7f">More...</a><br /></td></tr>
<tr class="separator:a0cbbad0f18b5767a4924ff6b069bbc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f04ddcd448e741233d5bc16562171"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171">Cudd_NextNode</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen, <a class="el" href="structDdNode.html">DdNode</a> **node)</td></tr>
<tr class="memdesc:a627f04ddcd448e741233d5bc16562171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next node of a decision diagram.  <a href="#a627f04ddcd448e741233d5bc16562171">More...</a><br /></td></tr>
<tr class="separator:a627f04ddcd448e741233d5bc16562171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16a8509f9959aff3a0c553a0427e656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656">Cudd_GenFree</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen)</td></tr>
<tr class="memdesc:aa16a8509f9959aff3a0c553a0427e656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a CUDD generator.  <a href="#aa16a8509f9959aff3a0c553a0427e656">More...</a><br /></td></tr>
<tr class="separator:aa16a8509f9959aff3a0c553a0427e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46290c6915c9d64fbe24a3faf40ced5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d">Cudd_IsGenEmpty</a> (<a class="el" href="structDdGen.html">DdGen</a> *gen)</td></tr>
<tr class="memdesc:a46290c6915c9d64fbe24a3faf40ced5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the status of a generator.  <a href="#a46290c6915c9d64fbe24a3faf40ced5d">More...</a><br /></td></tr>
<tr class="separator:a46290c6915c9d64fbe24a3faf40ced5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2815667bcad915fac2620161a577c46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2815667bcad915fac2620161a577c46b">Cudd_IndicesToCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int *array, int n)</td></tr>
<tr class="memdesc:a2815667bcad915fac2620161a577c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a cube of BDD variables from an array of indices.  <a href="#a2815667bcad915fac2620161a577c46b">More...</a><br /></td></tr>
<tr class="separator:a2815667bcad915fac2620161a577c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#acd64fd5ed246def2ad791e7b0ddeec2b">Cudd_PrintVersion</a> (FILE *fp)</td></tr>
<tr class="memdesc:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the package version number.  <a href="#acd64fd5ed246def2ad791e7b0ddeec2b">More...</a><br /></td></tr>
<tr class="separator:acd64fd5ed246def2ad791e7b0ddeec2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a0af9f50ad2f6430d354193497c16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a142a0af9f50ad2f6430d354193497c16">Cudd_AverageDistance</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a142a0af9f50ad2f6430d354193497c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average distance between adjacent nodes in the manager.  <a href="#a142a0af9f50ad2f6430d354193497c16">More...</a><br /></td></tr>
<tr class="separator:a142a0af9f50ad2f6430d354193497c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a7aca63dd70f27ea0245f0c269ffff6d1">Cudd_Random</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd)</td></tr>
<tr class="memdesc:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable random number generator.  <a href="#a7aca63dd70f27ea0245f0c269ffff6d1">More...</a><br /></td></tr>
<tr class="separator:a7aca63dd70f27ea0245f0c269ffff6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a20c2b03a12919a3d146c7e02b4f3e4bd">Cudd_Srandom</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int32_t seed)</td></tr>
<tr class="memdesc:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for the portable random number generator.  <a href="#a20c2b03a12919a3d146c7e02b4f3e4bd">More...</a><br /></td></tr>
<tr class="separator:a20c2b03a12919a3d146c7e02b4f3e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d6258d2a451f8d852941de13d623dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a31d6258d2a451f8d852941de13d623dc">Cudd_Density</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars)</td></tr>
<tr class="memdesc:a31d6258d2a451f8d852941de13d623dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the density of a BDD or ADD.  <a href="#a31d6258d2a451f8d852941de13d623dc">More...</a><br /></td></tr>
<tr class="separator:a31d6258d2a451f8d852941de13d623dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cf07a23729b7f2621c74bf1e2ff830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830">Cudd_OutOfMem</a> (size_t size)</td></tr>
<tr class="memdesc:a77cf07a23729b7f2621c74bf1e2ff830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warns that a memory allocation failed.  <a href="#a77cf07a23729b7f2621c74bf1e2ff830">More...</a><br /></td></tr>
<tr class="separator:a77cf07a23729b7f2621c74bf1e2ff830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e655bc7b71ea719534f40fb8faa393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393">Cudd_OutOfMemSilent</a> (size_t size)</td></tr>
<tr class="memdesc:aa6e655bc7b71ea719534f40fb8faa393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doesn not warn that a memory allocation failed.  <a href="#aa6e655bc7b71ea719534f40fb8faa393">More...</a><br /></td></tr>
<tr class="separator:aa6e655bc7b71ea719534f40fb8faa393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbc595b0dac192924c21ee5fadc8383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a4bbc595b0dac192924c21ee5fadc8383">cuddP</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:a4bbc595b0dac192924c21ee5fadc8383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a DD to the standard output. One line per node is printed.  <a href="#a4bbc595b0dac192924c21ee5fadc8383">More...</a><br /></td></tr>
<tr class="separator:a4bbc595b0dac192924c21ee5fadc8383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78384a7e34f75dc23d686c572c8488d7"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a78384a7e34f75dc23d686c572c8488d7">cuddStCountfree</a> (void *key, void *value, void *arg)</td></tr>
<tr class="memdesc:a78384a7e34f75dc23d686c572c8488d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used to store the minterm counts recorded in the visited table.  <a href="#a78384a7e34f75dc23d686c572c8488d7">More...</a><br /></td></tr>
<tr class="separator:a78384a7e34f75dc23d686c572c8488d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3fcfdf91a36cd66978d4f7201c468"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2cf3fcfdf91a36cd66978d4f7201c468">cuddCollectNodes</a> (<a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structst__table.html">st_table</a> *visited)</td></tr>
<tr class="memdesc:a2cf3fcfdf91a36cd66978d4f7201c468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively collects all the nodes of a DD in a symbol table.  <a href="#a2cf3fcfdf91a36cd66978d4f7201c468">More...</a><br /></td></tr>
<tr class="separator:a2cf3fcfdf91a36cd66978d4f7201c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa089ce201a38140aa26db5fbe0347c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudd_8h.html#a6cee862ffaa35c53ec0e1b5afeca632c">DdNodePtr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa089ce201a38140aa26db5fbe0347c4a">cuddNodeArray</a> (<a class="el" href="structDdNode.html">DdNode</a> *f, int *n)</td></tr>
<tr class="memdesc:aa089ce201a38140aa26db5fbe0347c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively collects all the nodes of a DD in an array.  <a href="#aa089ce201a38140aa26db5fbe0347c4a">More...</a><br /></td></tr>
<tr class="separator:aa089ce201a38140aa26db5fbe0347c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080be670e3403d8e4ab391fcb3a6adae"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a080be670e3403d8e4ab391fcb3a6adae">dp2</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structst__table.html">st_table</a> *t)</td></tr>
<tr class="memdesc:a080be670e3403d8e4ab391fcb3a6adae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of cuddP.  <a href="#a080be670e3403d8e4ab391fcb3a6adae">More...</a><br /></td></tr>
<tr class="separator:a080be670e3403d8e4ab391fcb3a6adae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af7ecd96899781204300c0164b30799"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a3af7ecd96899781204300c0164b30799">ddPrintMintermAux</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int *list)</td></tr>
<tr class="memdesc:a3af7ecd96899781204300c0164b30799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_PrintMinterm.  <a href="#a3af7ecd96899781204300c0164b30799">More...</a><br /></td></tr>
<tr class="separator:a3af7ecd96899781204300c0164b30799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfa54017e8ca22ee3ad1da33c079d3a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2bfa54017e8ca22ee3ad1da33c079d3a">ddDagInt</a> (<a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a2bfa54017e8ca22ee3ad1da33c079d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_DagSize.  <a href="#a2bfa54017e8ca22ee3ad1da33c079d3a">More...</a><br /></td></tr>
<tr class="separator:a2bfa54017e8ca22ee3ad1da33c079d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4c6dac57d4b1643ea4097a95a9109"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aafa4c6dac57d4b1643ea4097a95a9109">cuddNodeArrayRecur</a> (<a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="cudd_8h.html#a6cee862ffaa35c53ec0e1b5afeca632c">DdNodePtr</a> *table, int index)</td></tr>
<tr class="memdesc:aafa4c6dac57d4b1643ea4097a95a9109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of cuddNodeArray.  <a href="#aafa4c6dac57d4b1643ea4097a95a9109">More...</a><br /></td></tr>
<tr class="separator:aafa4c6dac57d4b1643ea4097a95a9109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb135bf14d1a9a4725ec5372ab271490"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#abb135bf14d1a9a4725ec5372ab271490">cuddEstimateCofactor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structst__table.html">st_table</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *node, int i, int phase, <a class="el" href="structDdNode.html">DdNode</a> **ptr)</td></tr>
<tr class="memdesc:abb135bf14d1a9a4725ec5372ab271490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CofactorEstimate.  <a href="#abb135bf14d1a9a4725ec5372ab271490">More...</a><br /></td></tr>
<tr class="separator:abb135bf14d1a9a4725ec5372ab271490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea5eee9f91c07601e2c7b8d0d98715"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a10ea5eee9f91c07601e2c7b8d0d98715">cuddUniqueLookup</a> (<a class="el" href="structDdManager.html">DdManager</a> *unique, int index, <a class="el" href="structDdNode.html">DdNode</a> *T, <a class="el" href="structDdNode.html">DdNode</a> *E)</td></tr>
<tr class="memdesc:a10ea5eee9f91c07601e2c7b8d0d98715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the unique table for the existence of an internal node.  <a href="#a10ea5eee9f91c07601e2c7b8d0d98715">More...</a><br /></td></tr>
<tr class="separator:a10ea5eee9f91c07601e2c7b8d0d98715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de9b65852f26110cf7ff447c15d04c7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2de9b65852f26110cf7ff447c15d04c7">cuddEstimateCofactorSimple</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, int i)</td></tr>
<tr class="memdesc:a2de9b65852f26110cf7ff447c15d04c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CofactorEstimateSimple.  <a href="#a2de9b65852f26110cf7ff447c15d04c7">More...</a><br /></td></tr>
<tr class="separator:a2de9b65852f26110cf7ff447c15d04c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d0b98eb41e0e83d9f609eab8418e9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a5f0d0b98eb41e0e83d9f609eab8418e9">ddCountMintermAux</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, double max, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table)</td></tr>
<tr class="memdesc:a5f0d0b98eb41e0e83d9f609eab8418e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CountMinterm.  <a href="#a5f0d0b98eb41e0e83d9f609eab8418e9">More...</a><br /></td></tr>
<tr class="separator:a5f0d0b98eb41e0e83d9f609eab8418e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3952a88467bdbd83cb4e06f1fe7a2"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aeba3952a88467bdbd83cb4e06f1fe7a2">ddCountPathAux</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:aeba3952a88467bdbd83cb4e06f1fe7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CountPath.  <a href="#aeba3952a88467bdbd83cb4e06f1fe7a2">More...</a><br /></td></tr>
<tr class="separator:aeba3952a88467bdbd83cb4e06f1fe7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b009ba274a602eb92b7facf59cebe"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a5a2b009ba274a602eb92b7facf59cebe">ddEpdCountMintermAux</a> (<a class="el" href="structDdManager.html">DdManager</a> const *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *max, <a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *epd, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:a5a2b009ba274a602eb92b7facf59cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_EpdCountMinterm.  <a href="#a5a2b009ba274a602eb92b7facf59cebe">More...</a><br /></td></tr>
<tr class="separator:a5a2b009ba274a602eb92b7facf59cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1563c34798156ac087fe4f499e3a7d"><td class="memItemLeft" align="right" valign="top">static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#adb1563c34798156ac087fe4f499e3a7d">ddLdblCountMintermAux</a> (<a class="el" href="structDdManager.html">DdManager</a> const *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, long double max, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:adb1563c34798156ac087fe4f499e3a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_LdblCountMinterm.  <a href="#adb1563c34798156ac087fe4f499e3a7d">More...</a><br /></td></tr>
<tr class="separator:adb1563c34798156ac087fe4f499e3a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b544a171dabbf7a64f6efb38dcde65"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a24b544a171dabbf7a64f6efb38dcde65">ddCountPathsToNonZero</a> (<a class="el" href="structDdNode.html">DdNode</a> *N, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr class="memdesc:a24b544a171dabbf7a64f6efb38dcde65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CountPathsToNonZero.  <a href="#a24b544a171dabbf7a64f6efb38dcde65">More...</a><br /></td></tr>
<tr class="separator:a24b544a171dabbf7a64f6efb38dcde65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83031f46206023ac78fea5a34d7547cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a83031f46206023ac78fea5a34d7547cf">ddSupportStep</a> (<a class="el" href="structDdNode.html">DdNode</a> *f, int *support)</td></tr>
<tr class="memdesc:a83031f46206023ac78fea5a34d7547cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_Support.  <a href="#a83031f46206023ac78fea5a34d7547cf">More...</a><br /></td></tr>
<tr class="separator:a83031f46206023ac78fea5a34d7547cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69f928c3cca42f5b1330803de1d9199"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ab69f928c3cca42f5b1330803de1d9199">ddClearFlag</a> (<a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr class="memdesc:ab69f928c3cca42f5b1330803de1d9199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a DFS from f, clearing the LSB of the next pointers.  <a href="#ab69f928c3cca42f5b1330803de1d9199">More...</a><br /></td></tr>
<tr class="separator:ab69f928c3cca42f5b1330803de1d9199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947e1124a73ac4cc1867ad1263b5305a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a947e1124a73ac4cc1867ad1263b5305a">ddLeavesInt</a> (<a class="el" href="structDdNode.html">DdNode</a> *n)</td></tr>
<tr class="memdesc:a947e1124a73ac4cc1867ad1263b5305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_CountLeaves.  <a href="#a947e1124a73ac4cc1867ad1263b5305a">More...</a><br /></td></tr>
<tr class="separator:a947e1124a73ac4cc1867ad1263b5305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa809bfd1adf107190cf7513566db0395"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#aa809bfd1adf107190cf7513566db0395">ddPickArbitraryMinterms</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int nvars, int nminterms, char **string)</td></tr>
<tr class="memdesc:aa809bfd1adf107190cf7513566db0395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddPickArbitraryMinterms.  <a href="#aa809bfd1adf107190cf7513566db0395">More...</a><br /></td></tr>
<tr class="separator:aa809bfd1adf107190cf7513566db0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d85026346c4325dec79383aa618a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#ac37d85026346c4325dec79383aa618a8">ddPickRepresentativeCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, double *weight, char *string)</td></tr>
<tr class="memdesc:ac37d85026346c4325dec79383aa618a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a representative cube of a BDD.  <a href="#ac37d85026346c4325dec79383aa618a8">More...</a><br /></td></tr>
<tr class="separator:ac37d85026346c4325dec79383aa618a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af508529f9bb5353b2f2ce12f259fb161"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#af508529f9bb5353b2f2ce12f259fb161">ddEpdFree</a> (void *key, void *value, void *arg)</td></tr>
<tr class="memdesc:af508529f9bb5353b2f2ce12f259fb161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used to store the minterm counts recorded in the visited table.  <a href="#af508529f9bb5353b2f2ce12f259fb161">More...</a><br /></td></tr>
<tr class="separator:af508529f9bb5353b2f2ce12f259fb161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54b57929f015ebda5cd678a39916639"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#af54b57929f015ebda5cd678a39916639">ddFindSupport</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *SP)</td></tr>
<tr class="memdesc:af54b57929f015ebda5cd678a39916639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively find the support of f.  <a href="#af54b57929f015ebda5cd678a39916639">More...</a><br /></td></tr>
<tr class="separator:af54b57929f015ebda5cd678a39916639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d56c83e38886efa5eea4da327a71171"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a2d56c83e38886efa5eea4da327a71171">ddClearVars</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, int SP)</td></tr>
<tr class="memdesc:a2d56c83e38886efa5eea4da327a71171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears visited flags for variables.  <a href="#a2d56c83e38886efa5eea4da327a71171">More...</a><br /></td></tr>
<tr class="separator:a2d56c83e38886efa5eea4da327a71171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec37711131f93528b45386efe8ae79c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a8ec37711131f93528b45386efe8ae79c">indexCompare</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:a8ec37711131f93528b45386efe8ae79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares indices for qsort.  <a href="#a8ec37711131f93528b45386efe8ae79c">More...</a><br /></td></tr>
<tr class="separator:a8ec37711131f93528b45386efe8ae79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779b3f8cd4522324600adca88b9053bb"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddUtil_8c.html#a779b3f8cd4522324600adca88b9053bb">ddLdblFree</a> (void *key, void *value, void *arg)</td></tr>
<tr class="memdesc:a779b3f8cd4522324600adca88b9053bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used to store the minterm counts recorded in the visited table by Cudd_LdblCountMinterm.  <a href="#a779b3f8cd4522324600adca88b9053bb">More...</a><br /></td></tr>
<tr class="separator:a779b3f8cd4522324600adca88b9053bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions. </p>
<dl class="section author"><dt>Author</dt><dd>Fabio Somenzi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2e7d0901cba492671c25ee816510867c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7d0901cba492671c25ee816510867c">&#9670;&nbsp;</a></span>Cudd_addComputeCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addComputeCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cube of an array of ADD variables. </p>
<p>If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> </dd></dl>

</div>
</div>
<a id="a142a0af9f50ad2f6430d354193497c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a0af9f50ad2f6430d354193497c16">&#9670;&nbsp;</a></span>Cudd_AverageDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_AverageDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average distance between adjacent nodes in the manager. </p>
<p>Adjacent nodes are node pairs such that the second node is the then child, else child, or next node in the collision list.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="ab538e936fe0bdfe380f0ad2ecd2c6581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab538e936fe0bdfe380f0ad2ecd2c6581">&#9670;&nbsp;</a></span>Cudd_bddComputeCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddComputeCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cube of an array of BDD variables. </p>
<p>If non-null, the phase argument indicates which literal of each variable should appear in the cube. If phase[i] is nonzero, then the positive literal is used. If phase is NULL, the cube is positive unate.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a2e7d0901cba492671c25ee816510867c" title="Computes the cube of an array of ADD variables.">Cudd_addComputeCube</a> <a class="el" href="cuddUtil_8c.html#a2815667bcad915fac2620161a577c46b" title="Builds a cube of BDD variables from an array of indices.">Cudd_IndicesToCube</a> <a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="a57c4e8e8d0b9ec3101e117629a2a459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c4e8e8d0b9ec3101e117629a2a459d">&#9670;&nbsp;</a></span>Cudd_bddPickArbitraryMinterms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddPickArbitraryMinterms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks k on-set minterms evenly distributed from given DD. </p>
<p>The minterms are in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterms built by this procedure may not be contained in <code>f</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>an array of BDDs for the minterms if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul>
<li>
It may run out of memory; </li>
<li>
the function <code>f</code> may be the constant 0; </li>
<li>
the minterms may not be contained in <code>f</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a57f68528887c0feb428d010c2173a59b" title="Picks one on-set minterm randomly from the given DD.">Cudd_bddPickOneMinterm</a> <a class="el" href="cuddUtil_8c.html#adcc47738ff8b49602d4e1442fd55576f" title="Picks one on-set cube randomly from the given DD.">Cudd_bddPickOneCube</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick k minterms </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">n</td><td>size of <code>vars</code> </td></tr>
    <tr><td class="paramname">k</td><td>number of minterms to find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc47738ff8b49602d4e1442fd55576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc47738ff8b49602d4e1442fd55576f">&#9670;&nbsp;</a></span>Cudd_bddPickOneCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddPickOneCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>ddm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks one on-set cube randomly from the given DD. </p>
<p>The cube is written into an array of characters. The array must have at least as many entries as there are variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a57f68528887c0feb428d010c2173a59b" title="Picks one on-set minterm randomly from the given DD.">Cudd_bddPickOneMinterm</a> </dd></dl>

</div>
</div>
<a id="a57f68528887c0feb428d010c2173a59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f68528887c0feb428d010c2173a59b">&#9670;&nbsp;</a></span>Cudd_bddPickOneMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddPickOneMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks one on-set minterm randomly from the given DD. </p>
<p>The minterm is in terms of <code>vars</code>. The array <code>vars</code> should contain at least all variables in the support of <code>f</code>; if this condition is not met the minterm built by this procedure may not be contained in <code>f</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the minterm if successful; NULL otherwise. There are three reasons why the procedure may fail: <ul>
<li>
It may run out of memory; </li>
<li>
the function <code>f</code> may be the constant 0; </li>
<li>
the minterm may not be contained in <code>f</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#adcc47738ff8b49602d4e1442fd55576f" title="Picks one on-set cube randomly from the given DD.">Cudd_bddPickOneCube</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick one minterm </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">n</td><td>size of <code>vars</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b61fadaf6046697691b35fad8c9faf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b61fadaf6046697691b35fad8c9faf0">&#9670;&nbsp;</a></span>Cudd_bddPrintCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddPrintCover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a sum of prime implicants of a BDD. </p>
<p>Prints a sum of product cover for an incompletely specified function given by a lower bound and an upper bound. Each product is a prime implicant obtained by expanding the product corresponding to a path from node to the constant one. Uses the package default output file.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aeab82cceadafa2b81083e0467c102526" title="Prints a disjoint sum of products.">Cudd_PrintMinterm</a> </dd></dl>

</div>
</div>
<a id="ab53ebc58628a5a659b86025e6ed9c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53ebc58628a5a659b86025e6ed9c492">&#9670;&nbsp;</a></span>Cudd_BddToCubeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_BddToCubeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a positional array from the BDD of a cube. </p>
<p>Array must have one entry for each BDD variable. The positional array has 1 in i-th position if the variable of index i appears in true form in the cube; it has 0 in i-th position if the variable of index i appears in complemented form in the cube; finally, it has 2 in i-th position if the variable of index i does not appear in the cube.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful (the BDD is indeed a cube); 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The result is in the array passed by reference.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="a2caf3183bbb7822b76bacd8b70aebc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caf3183bbb7822b76bacd8b70aebc94">&#9670;&nbsp;</a></span>Cudd_ClassifySupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ClassifySupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>onlyF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>onlyG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classifies the variables in the support of two DDs. </p>
<p>Classifies the variables in the support of two DDs <code>f</code> and <code>g</code>, depending on whether they appear in both DDs, only in <code>f</code>, or only in <code>g</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cubes of the three classes of variables are</dt><dd>returned as side effects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first DD </td></tr>
    <tr><td class="paramname">g</td><td>second DD </td></tr>
    <tr><td class="paramname">common</td><td>cube of shared variables </td></tr>
    <tr><td class="paramname">onlyF</td><td>cube of variables only in f </td></tr>
    <tr><td class="paramname">onlyG</td><td>cube of variables only in g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2af4867b046a794f5db312c69922790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af4867b046a794f5db312c69922790d">&#9670;&nbsp;</a></span>Cudd_CountLeaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_CountLeaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of leaves in a DD. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of leaves in the DD rooted at node if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> </dd></dl>

</div>
</div>
<a id="aa1f187be7f86701d59f924860970a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f187be7f86701d59f924860970a0b9">&#9670;&nbsp;</a></span>Cudd_CountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the minterms of an ADD or BDD. </p>
<p>The function is assumed to depend on <code>nvars</code> variables. The minterm count is represented as a double; hence overflow is possible. For functions with many variables (more than 1023 if floating point conforms to IEEE 754), one should consider <a class="el" href="cudd_8h.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm()</a> or <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of minterms of the function rooted at node if successful; +infinity if the number of minterms is known to be larger than the maximum value representable as a double; <code>(double) CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApa_8c.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91cb9e0fde5043297b133ce6516e9a99" title="Returns the number of minterms of aa ADD or BDD as a long double.">Cudd_LdblCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882" title="Counts the paths of a DD.">Cudd_CountPath</a> </dd></dl>

</div>
</div>
<a id="a95929aeb92541971db3e5798920e6882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95929aeb92541971db3e5798920e6882">&#9670;&nbsp;</a></span>Cudd_CountPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the paths of a DD. </p>
<p>Paths to all terminal nodes are counted. The path count is represented as a double; hence overflow is possible.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node if successful; <code>(double) CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> </dd></dl>

</div>
</div>
<a id="a2b1533ac1641e3ee3260d336e863052c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1533ac1641e3ee3260d336e863052c">&#9670;&nbsp;</a></span>Cudd_CountPathsToNonZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_CountPathsToNonZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the paths to a non-zero terminal of a DD. </p>
<p>The path count is represented as a double; hence overflow is possible.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882" title="Counts the paths of a DD.">Cudd_CountPath</a> </dd></dl>

</div>
</div>
<a id="a4ac2d2f87d831cfe727250103fc880da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac2d2f87d831cfe727250103fc880da">&#9670;&nbsp;</a></span>Cudd_CubeArrayToBdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_CubeArrayToBdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the BDD of a cube from a positional array. </p>
<p>The array must have one integer entry for each BDD variable. If the i-th entry is 1, the variable of index i appears in true form in the cube; If the i-th entry is 0, the variable of index i appears complemented in the cube; otherwise the variable does not appear in the cube.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD for the cube if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> <a class="el" href="cuddUtil_8c.html#a2815667bcad915fac2620161a577c46b" title="Builds a cube of BDD variables from an array of indices.">Cudd_IndicesToCube</a> <a class="el" href="cuddUtil_8c.html#ab53ebc58628a5a659b86025e6ed9c492" title="Builds a positional array from the BDD of a cube.">Cudd_BddToCubeArray</a> </dd></dl>

</div>
</div>
<a id="a95cf613390a7dbeaad14b3963d68de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cf613390a7dbeaad14b3963d68de24">&#9670;&nbsp;</a></span>Cudd_DagSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_DagSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a DD. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes in the graph rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a49d57cfc6ede9ae452a40779b58a3bac" title="Counts the number of nodes in an array of DDs.">Cudd_SharingSize</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> </dd></dl>

</div>
</div>
<a id="a31d6258d2a451f8d852941de13d623dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d6258d2a451f8d852941de13d623dc">&#9670;&nbsp;</a></span>Cudd_Density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cudd_Density </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the density of a BDD or ADD. </p>
<p>The density is the ratio of the number of minterms to the number of nodes. If 0 is passed as number of variables, the number of variables existing in the manager is used.</p>
<dl class="section return"><dt>Returns</dt><dd>the density if successful; (double) CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function whose density is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>size of the support of f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ee5461ed7f497f7b43fb643b517c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ee5461ed7f497f7b43fb643b517c99">&#9670;&nbsp;</a></span>Cudd_EpdCountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EpdCountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *&#160;</td>
          <td class="paramname"><em>epd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the minterms of an ADD or BDD with extended range. </p>
<p>The function is assumed to depend on <code>nvars</code> variables. The minterm count is represented as an <code>EpDouble</code>, to allow for any number of variables.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful; <code>CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91cb9e0fde5043297b133ce6516e9a99" title="Returns the number of minterms of aa ADD or BDD as a long double.">Cudd_LdblCountMinterm</a> <a class="el" href="cuddApa_8c.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm</a> <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddUtil_8c.html#a95929aeb92541971db3e5798920e6882" title="Counts the paths of a DD.">Cudd_CountPath</a> </dd></dl>

</div>
</div>
<a id="aa5a38e134284702f2455b5454ff0ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a38e134284702f2455b5454ff0ece5">&#9670;&nbsp;</a></span>Cudd_EpdPrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EpdPrintMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the number of minterms of an ADD or BDD with extended range. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddApa_8c.html#aa30cec86f65e23284b10f288f98f2e43" title="Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithme...">Cudd_ApaPrintMintermExp</a> </dd></dl>

</div>
</div>
<a id="abc492a365b6e11544b5b2bda4ac76a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc492a365b6e11544b5b2bda4ac76a34">&#9670;&nbsp;</a></span>Cudd_EstimateCofactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EstimateCofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of nodes in a cofactor of a DD. </p>
<p>This function uses a refinement of the algorithm of Cabodi et al. (ICCAD96). The refinement allows the procedure to account for part of the recombination that may occur in the part of the cofactor above the cofactoring variable. This procedure does not create any new node. It does keep a small table of results; therefore it may run out of memory. If this is a concern, one should use Cudd_EstimateCofactorSimple, which is faster, does not allocate any memory, but is less accurate.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of nodes in a cofactor of the graph rooted at node with respect to the variable whose index is i. In case of failure, returns CUDD_OUT_OF_MEM.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> <a class="el" href="cuddUtil_8c.html#a3e23b2111b9f214571866c6e88035a9d" title="Estimates the number of nodes in a cofactor of a DD.">Cudd_EstimateCofactorSimple</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">i</td><td>index of variable </td></tr>
    <tr><td class="paramname">phase</td><td>1: positive; 0: negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e23b2111b9f214571866c6e88035a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23b2111b9f214571866c6e88035a9d">&#9670;&nbsp;</a></span>Cudd_EstimateCofactorSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EstimateCofactorSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of nodes in a cofactor of a DD. </p>
<p>Returns an estimate of the number of nodes in the positive cofactor of the graph rooted at node with respect to the variable whose index is i. This procedure implements with minor changes the algorithm of Cabodi et al. (ICCAD96). It does not allocate any memory, it does not change the state of the manager, and it is fast. However, it has been observed to overestimate the size of the cofactor by as much as a factor of 2.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>

</div>
</div>
<a id="a139d8dd64955ecf3e2fd4c5d6ceeebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139d8dd64955ecf3e2fd4c5d6ceeebb4">&#9670;&nbsp;</a></span>Cudd_FirstCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first cube of a decision diagram. </p>
<p>Defines an iterator on the onset of a decision diagram and finds its first cube.</p>
<p>A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a disjoint cover of the function associated with the diagram. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.</p>
<p>For each cube, a value is also returned. This value is always 1 for a BDD, while it may be different from 1 for an ADD. For BDDs, the offset is the set of cubes whose value is the logical zero. For ADDs, the offset is the set of cubes whose value is the background value. The cubes of the offset are not enumerated.</p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first cube and its value are returned as side effects.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> </dd></dl>

</div>
</div>
<a id="a0cbbad0f18b5767a4924ff6b069bbc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbbad0f18b5767a4924ff6b069bbc7f">&#9670;&nbsp;</a></span>Cudd_FirstNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first node of a decision diagram. </p>
<p>Defines an iterator on the nodes of a decision diagram and finds its first node. The nodes are enumerated in a reverse topological order, so that a node is always preceded in the enumeration by its descendants.</p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first node is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> </dd></dl>

</div>
</div>
<a id="a65691b560210512cf1f8d92f0c1ece9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65691b560210512cf1f8d92f0c1ece9a">&#9670;&nbsp;</a></span>Cudd_FirstPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdGen.html">DdGen</a>* Cudd_FirstPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first prime of a Boolean function. </p>
<p>Defines an iterator on a pair of BDDs describing a (possibly incompletely specified) Boolean functions and finds the first cube of a cover of the function.</p>
<p>The two argument BDDs are the lower and upper bounds of an interval. It is a mistake to call this function with a lower bound that is not less than or equal to the upper bound.</p>
<p>A cube is represented as an array of literals, which are integers in {0, 1, 2}; 0 represents a complemented literal, 1 represents an uncomplemented literal, and 2 stands for don't care. The enumeration produces a prime and irredundant cover of the function associated with the two BDDs. The size of the array equals the number of variables in the manager at the time Cudd_FirstCube is called.</p>
<p>This iterator can only be used on BDDs. </p>
<dl class="section return"><dt>Returns</dt><dd>a generator that contains the information necessary to continue the enumeration if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The first cube is returned as side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a6b1ce1bc5df95326f9eabcfeca1e7ded" title="Iterates over the primes of a Boolean function.">Cudd_ForeachPrime</a> <a class="el" href="cuddUtil_8c.html#ae9c8ccb352d96ca9bde4ab97a1ee8e73" title="Generates the next prime of a Boolean function.">Cudd_NextPrime</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> </dd></dl>

</div>
</div>
<a id="aa16a8509f9959aff3a0c553a0427e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16a8509f9959aff3a0c553a0427e656">&#9670;&nbsp;</a></span>Cudd_GenFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_GenFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a CUDD generator. </p>
<dl class="section return"><dt>Returns</dt><dd>always 0.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> </dd></dl>

</div>
</div>
<a id="a2815667bcad915fac2620161a577c46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2815667bcad915fac2620161a577c46b">&#9670;&nbsp;</a></span>Cudd_IndicesToCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_IndicesToCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a cube of BDD variables from an array of indices. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab538e936fe0bdfe380f0ad2ecd2c6581" title="Computes the cube of an array of BDD variables.">Cudd_bddComputeCube</a> <a class="el" href="cuddUtil_8c.html#a4ac2d2f87d831cfe727250103fc880da" title="Builds the BDD of a cube from a positional array.">Cudd_CubeArrayToBdd</a> </dd></dl>

</div>
</div>
<a id="a46290c6915c9d64fbe24a3faf40ced5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46290c6915c9d64fbe24a3faf40ced5d">&#9670;&nbsp;</a></span>Cudd_IsGenEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_IsGenEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the status of a generator. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the generator is empty or NULL; 0 otherswise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> </dd></dl>

</div>
</div>
<a id="a91cb9e0fde5043297b133ce6516e9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb9e0fde5043297b133ce6516e9a99">&#9670;&nbsp;</a></span>Cudd_LdblCountMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double Cudd_LdblCountMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of minterms of aa ADD or BDD as a long double. </p>
<p>On systems where double and long double are the same type, <a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm()</a> is preferable. On systems where long double values have 15-bit exponents, this function avoids overflow for up to 16383 variables. It applies scaling to try to avoid overflow when the number of variables is larger than 16383, but smaller than 32764.</p>
<dl class="section return"><dt>Returns</dt><dd>The nimterm count if successful; +infinity if the number is known to be too large for representation as a long double; <code>(long double)CUDD_OUT_OF_MEM</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#a91ee5461ed7f497f7b43fb643b517c99" title="Counts the minterms of an ADD or BDD with extended range.">Cudd_EpdCountMinterm</a> <a class="el" href="cuddApa_8c.html#a86d07f6e04e77467e44c0d209c3b450d" title="Counts the number of minterms of a DD.">Cudd_ApaCountMinterm</a> </dd></dl>

</div>
</div>
<a id="a05f1698806d45eaba7f4a5721dd5c3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1698806d45eaba7f4a5721dd5c3c8">&#9670;&nbsp;</a></span>Cudd_NextCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the next cube of a decision diagram onset. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cube and its value are returned as side effects. The</dt><dd>generator is modified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#af13069593b0d4de4d16493b956de38a6" title="Iterates over the cubes of a decision diagram.">Cudd_ForeachCube</a> <a class="el" href="cuddUtil_8c.html#a139d8dd64955ecf3e2fd4c5d6ceeebb4" title="Finds the first cube of a decision diagram.">Cudd_FirstCube</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> </dd></dl>

</div>
</div>
<a id="a627f04ddcd448e741233d5bc16562171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f04ddcd448e741233d5bc16562171">&#9670;&nbsp;</a></span>Cudd_NextNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next node of a decision diagram. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The next node is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#aeeb7e015a5d710dc3086b194193549f2" title="Iterates over the nodes of a decision diagram.">Cudd_ForeachNode</a> <a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> </dd></dl>

</div>
</div>
<a id="ae9c8ccb352d96ca9bde4ab97a1ee8e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c8ccb352d96ca9bde4ab97a1ee8e73">&#9670;&nbsp;</a></span>Cudd_NextPrime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_NextPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdGen.html">DdGen</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the next prime of a Boolean function. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the enumeration is completed; 1 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The cube and is returned as side effects. The</dt><dd>generator is modified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cudd_8h.html#a6b1ce1bc5df95326f9eabcfeca1e7ded" title="Iterates over the primes of a Boolean function.">Cudd_ForeachPrime</a> <a class="el" href="cuddUtil_8c.html#a65691b560210512cf1f8d92f0c1ece9a" title="Finds the first prime of a Boolean function.">Cudd_FirstPrime</a> <a class="el" href="cuddUtil_8c.html#aa16a8509f9959aff3a0c553a0427e656" title="Frees a CUDD generator.">Cudd_GenFree</a> <a class="el" href="cuddUtil_8c.html#a46290c6915c9d64fbe24a3faf40ced5d" title="Queries the status of a generator.">Cudd_IsGenEmpty</a> <a class="el" href="cuddUtil_8c.html#a05f1698806d45eaba7f4a5721dd5c3c8" title="Generates the next cube of a decision diagram onset.">Cudd_NextCube</a> <a class="el" href="cuddUtil_8c.html#a627f04ddcd448e741233d5bc16562171" title="Finds the next node of a decision diagram.">Cudd_NextNode</a> </dd></dl>

</div>
</div>
<a id="a77cf07a23729b7f2621c74bf1e2ff830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cf07a23729b7f2621c74bf1e2ff830">&#9670;&nbsp;</a></span>Cudd_OutOfMem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_OutOfMem </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warns that a memory allocation failed. </p>
<p>This function can be used as replacement of MMout_of_memory to prevent the safe_mem functions of the util package from exiting when malloc returns NULL. One possible use is in case of discretionary allocations; for instance, an allocation of memory to enlarge the computed table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#aa6e655bc7b71ea719534f40fb8faa393" title="Doesn not warn that a memory allocation failed.">Cudd_OutOfMemSilent</a> <a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the allocation that failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6e655bc7b71ea719534f40fb8faa393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e655bc7b71ea719534f40fb8faa393">&#9670;&nbsp;</a></span>Cudd_OutOfMemSilent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_OutOfMemSilent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Doesn not warn that a memory allocation failed. </p>
<p>This function can be used as replacement of MMout_of_memory to prevent the safe_mem functions of the util package from exiting when malloc returns NULL. One possible use is in case of discretionary allocations; for instance, an allocation of memory to enlarge the computed table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a77cf07a23729b7f2621c74bf1e2ff830" title="Warns that a memory allocation failed.">Cudd_OutOfMem</a> <a class="el" href="cuddAPI_8c.html#a6aa76d8075f1af649c8741af26369836" title="Installs an out-of-memory callback.">Cudd_RegisterOutOfMemoryCallback</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the allocation that failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e46a1b9147411ce547a2e03305d6c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e46a1b9147411ce547a2e03305d6c22">&#9670;&nbsp;</a></span>Cudd_PrintDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to the manager standard output a DD and its statistics. </p>
<p>The statistics include the number of nodes, the number of leaves, and the number of minterms. (The number of minterms is the number of assignments to the variables that cause the function to be different from the logical zero (for BDDs) and from the background value (for ADDs.) The statistics are printed if pr &gt; 0. Specifically: </p><ul>
<li>
pr = 0 : prints nothing </li>
<li>
pr = 1 : prints counts of nodes and minterms </li>
<li>
pr = 2 : prints counts + disjoint sum of product </li>
<li>
pr = 3 : prints counts + list of nodes </li>
<li>
pr &gt; 3 : prints counts + disjoint sum of product + list of nodes </li>
</ul>
<p>For the purpose of counting the number of minterms, the function is supposed to depend on n variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> <a class="el" href="cuddUtil_8c.html#a2af4867b046a794f5db312c69922790d" title="Counts the number of leaves in a DD.">Cudd_CountLeaves</a> <a class="el" href="cuddUtil_8c.html#aa1f187be7f86701d59f924860970a0b9" title="Counts the minterms of an ADD or BDD.">Cudd_CountMinterm</a> <a class="el" href="cuddUtil_8c.html#aeab82cceadafa2b81083e0467c102526" title="Prints a disjoint sum of products.">Cudd_PrintMinterm</a> </dd></dl>

</div>
</div>
<a id="aeab82cceadafa2b81083e0467c102526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab82cceadafa2b81083e0467c102526">&#9670;&nbsp;</a></span>Cudd_PrintMinterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintMinterm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a disjoint sum of products. </p>
<p>Prints a disjoint sum of product cover for the function rooted at node. Each product corresponds to a path from node to a leaf node different from the logical zero, and different from the background value. Uses the package default output file.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddUtil_8c.html#a8b61fadaf6046697691b35fad8c9faf0" title="Prints a sum of prime implicants of a BDD.">Cudd_bddPrintCover</a> </dd></dl>

</div>
</div>
<a id="ac610821afa1bb9ad8432a3c656eb81cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac610821afa1bb9ad8432a3c656eb81cd">&#9670;&nbsp;</a></span>Cudd_PrintSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_PrintSummary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a one-line summary of an ADD or BDD to the manager stdout. </p>
<p>The summary includes the number of nodes, the number of leaves, and the number of minterms. The number of minterms is computed with arbitrary precision unlike <a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug()</a>. For the purpose of counting minterms, the function <code>f</code> is supposed to depend on <code>n</code> variables.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> <a class="el" href="cuddApa_8c.html#a0594a9f95c1b1935685cbf922d3d59af" title="Prints the number of minterms of a BDD or ADD using arbitrary precision arithmetic.">Cudd_ApaPrintMinterm</a> <a class="el" href="cuddApa_8c.html#aa30cec86f65e23284b10f288f98f2e43" title="Prints the number of minterms of a BDD or ADD in exponential format using arbitrary precision arithme...">Cudd_ApaPrintMintermExp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD to be summarized </td></tr>
    <tr><td class="paramname">n</td><td>number of variables for minterm computation </td></tr>
    <tr><td class="paramname">mode</td><td>integer (0) or exponential (1) format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd64fd5ed246def2ad791e7b0ddeec2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd64fd5ed246def2ad791e7b0ddeec2b">&#9670;&nbsp;</a></span>Cudd_PrintVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_PrintVersion </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the package version number. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a7aca63dd70f27ea0245f0c269ffff6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aca63dd70f27ea0245f0c269ffff6d1">&#9670;&nbsp;</a></span>Cudd_Random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Cudd_Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable random number generator. </p>
<p>Based on ran2 from "Numerical Recipes in C." It is a long period (&gt; 2 * 10^18) random number generator of L'Ecuyer with Bays-Durham shuffle. The random generator can be explicitly initialized by calling Cudd_Srandom. If no explicit initialization is performed, then the seed 1 is assumed.</p>
<dl class="section return"><dt>Returns</dt><dd>a long integer uniformly distributed between 0 and 2147483561 (inclusive of the endpoint values).</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a20c2b03a12919a3d146c7e02b4f3e4bd" title="Initializer for the portable random number generator.">Cudd_Srandom</a> </dd></dl>

</div>
</div>
<a id="a49d57cfc6ede9ae452a40779b58a3bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d57cfc6ede9ae452a40779b58a3bac">&#9670;&nbsp;</a></span>Cudd_SharingSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SharingSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>nodeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in an array of DDs. </p>
<p>Shared nodes are counted only once.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of nodes.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a95cf613390a7dbeaad14b3963d68de24" title="Counts the number of nodes in a DD.">Cudd_DagSize</a> </dd></dl>

</div>
</div>
<a id="a20c2b03a12919a3d146c7e02b4f3e4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c2b03a12919a3d146c7e02b4f3e4bd">&#9670;&nbsp;</a></span>Cudd_Srandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cudd_Srandom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for the portable random number generator. </p>
<p>Based on ran2 in "Numerical Recipes in C." The input is the seed for the generator. If it is negative, its absolute value is taken as seed. If it is 0, then 1 is taken as seed. The initialized sets up the two recurrences used to generate a long-period stream, and sets up the shuffle table.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a7aca63dd70f27ea0245f0c269ffff6d1" title="Portable random number generator.">Cudd_Random</a> </dd></dl>

</div>
</div>
<a id="ab8e7410606294a5fb0896c8787019db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7410606294a5fb0896c8787019db1">&#9670;&nbsp;</a></span>Cudd_SubsetWithMaskVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetWithMaskVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>maskVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a subset from a BDD. </p>
<p>Extracts a subset from a BDD in the following procedure.</p><ol type="1">
<li>Compute the weight for each mask variable by counting the number of minterms for both positive and negative cofactors of the BDD with respect to each mask variable. (weight = # positive - # negative)</li>
<li>Find a representative cube of the BDD by using the weight. From the top variable of the BDD, for each variable, if the weight is greater than 0.0, choose THEN branch, othereise ELSE branch, until meeting the constant 1.</li>
<li>Quantify out the variables not in maskVars from the representative cube and if a variable in maskVars is don't care, replace the variable with a constant(1 or 0) depending on the weight.</li>
<li>Make a subset of the BDD by multiplying with the modified cube.</li>
</ol>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function from which to pick a cube </td></tr>
    <tr><td class="paramname">vars</td><td>array of variables </td></tr>
    <tr><td class="paramname">nvars</td><td>size of <code>vars</code> </td></tr>
    <tr><td class="paramname">maskVars</td><td>array of variables </td></tr>
    <tr><td class="paramname">mvars</td><td>size of <code>maskVars</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e1f8e5b8efe97330f8650e1378ad172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1f8e5b8efe97330f8650e1378ad172">&#9670;&nbsp;</a></span>Cudd_Support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>a BDD consisting of the product of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc898f0fe024bece58bb9e992845bb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc898f0fe024bece58bb9e992845bb73">&#9670;&nbsp;</a></span>Cudd_SupportIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* Cudd_SupportIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>an index array of the variables if successful; NULL otherwise. The size of the array equals the number of variables in the manager. Each entry of the array is 1 if the corresponding variable is in the support of the DD and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a455e317288c1b57e0097013d52435d23" title="Finds the variables on which a DD depends.">Cudd_SupportIndices</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a455e317288c1b57e0097013d52435d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455e317288c1b57e0097013d52435d23">&#9670;&nbsp;</a></span>Cudd_SupportIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SupportIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The indices of the support variables are returned as</dt><dd>side effects. If the function is constant, no array is allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support is sought </td></tr>
    <tr><td class="paramname">indices</td><td>array containing (on return) the indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e7cde5c4dfd8832de07de9b31e9469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7cde5c4dfd8832de07de9b31e9469e">&#9670;&nbsp;</a></span>Cudd_SupportSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SupportSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the variables on which a DD depends. </p>
<dl class="section return"><dt>Returns</dt><dd>the variables on which a DD depends.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a455e317288c1b57e0097013d52435d23" title="Finds the variables on which a DD depends.">Cudd_SupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>DD whose support size is sought </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f6cf8a1719f76a3e121e7f61c406d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6cf8a1719f76a3e121e7f61c406d5b">&#9670;&nbsp;</a></span>Cudd_VectorSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_VectorSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>a BDD consisting of the product of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#a2caf3183bbb7822b76bacd8b70aebc94" title="Classifies the variables in the support of two DDs.">Cudd_ClassifySupport</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3a3eda5431ad0985605921d16c83067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a3eda5431ad0985605921d16c83067">&#9670;&nbsp;</a></span>Cudd_VectorSupportIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* Cudd_VectorSupportIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>an index array of the variables if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6fd4942d4c62cb3a539a8039084d571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd4942d4c62cb3a539a8039084d571">&#9670;&nbsp;</a></span>Cudd_VectorSupportIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_VectorSupportIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The indices of the support variables are returned as</dt><dd>side effects. If the function is constant, no array is allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a9e1f8e5b8efe97330f8650e1378ad172" title="Finds the variables on which a DD depends.">Cudd_Support</a> <a class="el" href="cuddUtil_8c.html#adc898f0fe024bece58bb9e992845bb73" title="Finds the variables on which a DD depends.">Cudd_SupportIndex</a> <a class="el" href="cuddUtil_8c.html#ac6fd4942d4c62cb3a539a8039084d571" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupportIndices</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>DD whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
    <tr><td class="paramname">indices</td><td>array containing (on return) the indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66da9c2c22b9bbb31120bd0a28fbf83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66da9c2c22b9bbb31120bd0a28fbf83c">&#9670;&nbsp;</a></span>Cudd_VectorSupportSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_VectorSupportSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the variables on which a set of DDs depends. </p>
<p>The set must contain either BDDs and ADDs, or ZDDs.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables on which a set of DDs depends.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a8f6cf8a1719f76a3e121e7f61c406d5b" title="Finds the variables on which a set of DDs depends.">Cudd_VectorSupport</a> <a class="el" href="cuddUtil_8c.html#a0e7cde5c4dfd8832de07de9b31e9469e" title="Counts the variables on which a DD depends.">Cudd_SupportSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">F</td><td>array of DDs whose support is sought </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf3fcfdf91a36cd66978d4f7201c468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3fcfdf91a36cd66978d4f7201c468">&#9670;&nbsp;</a></span>cuddCollectNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cuddCollectNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively collects all the nodes of a DD in a symbol table. </p>
<p>Traverses the DD f and collects all its nodes in a symbol table. f is assumed to be a regular pointer and cuddCollectNodes guarantees this assumption in the recursive calls.</p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="abb135bf14d1a9a4725ec5372ab271490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb135bf14d1a9a4725ec5372ab271490">&#9670;&nbsp;</a></span>cuddEstimateCofactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddEstimateCofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CofactorEstimate. </p>
<p>Uses the least significant bit of the next field as visited flag. node is supposed to be regular; the invariant is maintained by this procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of nodes in the DD of a cofactor of node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2de9b65852f26110cf7ff447c15d04c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de9b65852f26110cf7ff447c15d04c7">&#9670;&nbsp;</a></span>cuddEstimateCofactorSimple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddEstimateCofactorSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CofactorEstimateSimple. </p>
<p>Uses the least significant bit of the next field as visited flag. node is supposed to be regular; the invariant is maintained by this procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of nodes in the DD of the positive cofactor of node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="aa089ce201a38140aa26db5fbe0347c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa089ce201a38140aa26db5fbe0347c4a">&#9670;&nbsp;</a></span>cuddNodeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudd_8h.html#a6cee862ffaa35c53ec0e1b5afeca632c">DdNodePtr</a>* cuddNodeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively collects all the nodes of a DD in an array. </p>
<p>Traverses the DD f and collects all its nodes in an array. The caller should free the array returned by cuddNodeArray. The nodes are collected in reverse topological order, so that a node is always preceded in the array by all its descendants.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array of nodes in case of success; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The number of nodes is returned as a side effect.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a0cbbad0f18b5767a4924ff6b069bbc7f" title="Finds the first node of a decision diagram.">Cudd_FirstNode</a> </dd></dl>

</div>
</div>
<a id="aafa4c6dac57d4b1643ea4097a95a9109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa4c6dac57d4b1643ea4097a95a9109">&#9670;&nbsp;</a></span>cuddNodeArrayRecur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddNodeArrayRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a6cee862ffaa35c53ec0e1b5afeca632c">DdNodePtr</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of cuddNodeArray. </p>
<p>node is supposed to be regular; the invariant is maintained by this procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>an the number of nodes in the DD.</dd></dl>
<dl class="section user"><dt>Side effects\n Clears the least significant bit of the next field that</dt><dd>was used as visited flag by cuddNodeArrayRecur when counting the nodes. </dd></dl>

</div>
</div>
<a id="a4bbc595b0dac192924c21ee5fadc8383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbc595b0dac192924c21ee5fadc8383">&#9670;&nbsp;</a></span>cuddP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cuddP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a DD to the standard output. One line per node is printed. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a1e46a1b9147411ce547a2e03305d6c22" title="Prints to the manager standard output a DD and its statistics.">Cudd_PrintDebug</a> </dd></dl>

</div>
</div>
<a id="a78384a7e34f75dc23d686c572c8488d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78384a7e34f75dc23d686c572c8488d7">&#9670;&nbsp;</a></span>cuddStCountfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> cuddStCountfree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory used to store the minterm counts recorded in the visited table. </p>
<dl class="section return"><dt>Returns</dt><dd>ST_CONTINUE.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a10ea5eee9f91c07601e2c7b8d0d98715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ea5eee9f91c07601e2c7b8d0d98715">&#9670;&nbsp;</a></span>cuddUniqueLookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddUniqueLookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the unique table for the existence of an internal node. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node if it is in the table; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddTable_8c.html#a767e31fbbfdbddc623396dde86249497" title="Checks the unique table for the existence of an internal node.">cuddUniqueInter</a> </dd></dl>

</div>
</div>
<a id="ab69f928c3cca42f5b1330803de1d9199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f928c3cca42f5b1330803de1d9199">&#9670;&nbsp;</a></span>ddClearFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ddClearFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a DFS from f, clearing the LSB of the next pointers. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a83031f46206023ac78fea5a34d7547cf" title="Performs the recursive step of Cudd_Support.">ddSupportStep</a> <a class="el" href="cuddUtil_8c.html#af54b57929f015ebda5cd678a39916639" title="Recursively find the support of f.">ddFindSupport</a> <a class="el" href="cuddUtil_8c.html#a947e1124a73ac4cc1867ad1263b5305a" title="Performs the recursive step of Cudd_CountLeaves.">ddLeavesInt</a> <a class="el" href="cuddUtil_8c.html#a2bfa54017e8ca22ee3ad1da33c079d3a" title="Performs the recursive step of Cudd_DagSize.">ddDagInt</a> </dd></dl>

</div>
</div>
<a id="a2d56c83e38886efa5eea4da327a71171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d56c83e38886efa5eea4da327a71171">&#9670;&nbsp;</a></span>ddClearVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ddClearVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears visited flags for variables. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a5f0d0b98eb41e0e83d9f609eab8418e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0d0b98eb41e0e83d9f609eab8418e9">&#9670;&nbsp;</a></span>ddCountMintermAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ddCountMintermAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CountMinterm. </p>
<p>It is based on the following identity. Let |f| be the number of minterms of f. Then: </p><pre class="fragment">|f| = (|f0|+|f1|)/2
</pre><p>where f0 and f1 are the two cofactors of f. Does not use the identity |f'| = max - |f|, to minimize loss of accuracy due to roundoff.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of minterms of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="aeba3952a88467bdbd83cb4e06f1fe7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba3952a88467bdbd83cb4e06f1fe7a2">&#9670;&nbsp;</a></span>ddCountPathAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ddCountPathAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CountPath. </p>
<p>It is based on the following identity. Let |f| be the number of paths of f. Then: </p><pre class="fragment">|f| = |f0|+|f1|
</pre><p>where f0 and f1 are the two cofactors of f. Uses the identity |f'| = |f|, to improve the utilization of the (local) cache.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a24b544a171dabbf7a64f6efb38dcde65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b544a171dabbf7a64f6efb38dcde65">&#9670;&nbsp;</a></span>ddCountPathsToNonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ddCountPathsToNonZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CountPathsToNonZero. </p>
<p>It is based on the following identity. Let |f| be the number of paths of f. Then: </p><pre class="fragment">|f| = |f0|+|f1|
</pre><p>where f0 and f1 are the two cofactors of f.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of paths of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a2bfa54017e8ca22ee3ad1da33c079d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfa54017e8ca22ee3ad1da33c079d3a">&#9670;&nbsp;</a></span>ddDagInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddDagInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_DagSize. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes in the graph rooted at n.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a5a2b009ba274a602eb92b7facf59cebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2b009ba274a602eb92b7facf59cebe">&#9670;&nbsp;</a></span>ddEpdCountMintermAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddEpdCountMintermAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="epd_8h.html#a6da609fee802d939cf57b73a8c2656b5">EpDouble</a> *&#160;</td>
          <td class="paramname"><em>epd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_EpdCountMinterm. </p>
<p>It is based on the following identity. Let |f| be the number of minterms of f. Then: </p><pre class="fragment">|f| = (|f0|+|f1|)/2
</pre><p>where f0 and f1 are the two cofactors of f. Does not use the identity |f'| = max - |f|, to minimize loss of accuracy due to roundoff.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of minterms of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af508529f9bb5353b2f2ce12f259fb161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af508529f9bb5353b2f2ce12f259fb161">&#9670;&nbsp;</a></span>ddEpdFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> ddEpdFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used to store the minterm counts recorded in the visited table. </p>
<dl class="section return"><dt>Returns</dt><dd>ST_CONTINUE.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="af54b57929f015ebda5cd678a39916639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54b57929f015ebda5cd678a39916639">&#9670;&nbsp;</a></span>ddFindSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ddFindSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>SP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively find the support of f. </p>
<p>This function uses the LSB of the next field of the nodes of f as visited flag. It also uses the LSB of the next field of the variables as flag to remember whether a certain index has already been seen. Finally, it uses the manager stack to record all seen indices.</p>
<dl class="section user"><dt>Side effects\n The stack pointer SP is modified by side-effect. The next</dt><dd>fields are changed and need to be reset. </dd></dl>

</div>
</div>
<a id="adb1563c34798156ac087fe4f499e3a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1563c34798156ac087fe4f499e3a7d">&#9670;&nbsp;</a></span>ddLdblCountMintermAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long double ddLdblCountMintermAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> const *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_LdblCountMinterm. </p>
<p>It is based on the following identity. Let |f| be the number of minterms of f. Then: </p><pre class="fragment">|f| = (|f0|+|f1|)/2
</pre><p>where f0 and f1 are the two cofactors of f. Does not use the identity |f'| = max - |f|, to minimize loss of accuracy due to roundoff.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of minterms of the function rooted at node.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a779b3f8cd4522324600adca88b9053bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779b3f8cd4522324600adca88b9053bb">&#9670;&nbsp;</a></span>ddLdblFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> ddLdblFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used to store the minterm counts recorded in the visited table by Cudd_LdblCountMinterm. </p>
<dl class="section return"><dt>Returns</dt><dd>ST_CONTINUE.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a947e1124a73ac4cc1867ad1263b5305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947e1124a73ac4cc1867ad1263b5305a">&#9670;&nbsp;</a></span>ddLeavesInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddLeavesInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_CountLeaves. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of leaves in the DD rooted at n.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a2af4867b046a794f5db312c69922790d" title="Counts the number of leaves in a DD.">Cudd_CountLeaves</a> </dd></dl>

</div>
</div>
<a id="aa809bfd1adf107190cf7513566db0395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa809bfd1adf107190cf7513566db0395">&#9670;&nbsp;</a></span>ddPickArbitraryMinterms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddPickArbitraryMinterms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nminterms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_bddPickArbitraryMinterms. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n none</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#a57c4e8e8d0b9ec3101e117629a2a459d" title="Picks k on-set minterms evenly distributed from given DD.">Cudd_bddPickArbitraryMinterms</a> </dd></dl>

</div>
</div>
<a id="ac37d85026346c4325dec79383aa618a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37d85026346c4325dec79383aa618a8">&#9670;&nbsp;</a></span>ddPickRepresentativeCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ddPickRepresentativeCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a representative cube of a BDD. </p>
<p>Finds a representative cube of a BDD with the weight of each variable. From the top variable, if the weight is greater than or equal to 0.0, choose THEN branch unless the child is the constant 0. Otherwise, choose ELSE branch unless the child is the constant 0.</p>
<dl class="section user"><dt>Side effects\n Cudd_SubsetWithMaskVars Cudd_bddPickOneCube</dt><dd></dd></dl>

</div>
</div>
<a id="a3af7ecd96899781204300c0164b30799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af7ecd96899781204300c0164b30799">&#9670;&nbsp;</a></span>ddPrintMintermAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ddPrintMintermAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_PrintMinterm. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">node</td><td>current node </td></tr>
    <tr><td class="paramname">list</td><td>current recursion path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83031f46206023ac78fea5a34d7547cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83031f46206023ac78fea5a34d7547cf">&#9670;&nbsp;</a></span>ddSupportStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ddSupportStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of Cudd_Support. </p>
<p>Performs a DFS from f. The support is accumulated in supp as a side effect. Uses the LSB of the then pointer as visited flag.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddUtil_8c.html#ab69f928c3cca42f5b1330803de1d9199" title="Performs a DFS from f, clearing the LSB of the next pointers.">ddClearFlag</a> </dd></dl>

</div>
</div>
<a id="a080be670e3403d8e4ab391fcb3a6adae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080be670e3403d8e4ab391fcb3a6adae">&#9670;&nbsp;</a></span>dp2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int dp2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the recursive step of cuddP. </p>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a8ec37711131f93528b45386efe8ae79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec37711131f93528b45386efe8ae79c">&#9670;&nbsp;</a></span>indexCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int indexCompare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares indices for qsort. </p>
<p>Subtracting these integers cannot produce overflow, because they are non-negative.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2020 20:59:19 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
