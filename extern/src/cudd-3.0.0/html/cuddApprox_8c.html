<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddApprox.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddApprox.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Procedures to approximate a given BDD.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddApprox.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddApprox_8c__incl.png" border="0" usemap="#cudd_2cuddApprox_8c" alt=""/></div>
<map name="cudd_2cuddApprox_8c" id="cudd_2cuddApprox_8c">
<area shape="rect"  title="Procedures to approximate a given BDD." alt="" coords="405,5,551,32"/>
<area shape="rect"  href="util_8h.html" title="Low&#45;level utilities." alt="" coords="655,80,709,107"/>
<area shape="rect"  href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="234,80,317,107"/>
<area shape="rect"  title=" " alt="" coords="423,155,498,181"/>
<area shape="rect"  title=" " alt="" coords="910,155,985,181"/>
<area shape="rect"  title=" " alt="" coords="1009,155,1083,181"/>
<area shape="rect"  title=" " alt="" coords="309,229,375,256"/>
<area shape="rect"  title=" " alt="" coords="573,155,644,181"/>
<area shape="rect"  title=" " alt="" coords="720,155,791,181"/>
<area shape="rect"  title=" " alt="" coords="815,155,885,181"/>
<area shape="rect"  title=" " alt="" coords="480,229,567,256"/>
<area shape="rect"  title=" " alt="" coords="241,155,309,181"/>
<area shape="rect"  href="st_8h.html" title="Symbol table package." alt="" coords="5,155,52,181"/>
<area shape="rect"  href="mtr_8h.html" title="Multiway&#45;branch tree manipulation." alt="" coords="76,155,133,181"/>
<area shape="rect"  href="epd_8h.html" title="The University of Colorado extended double precision package." alt="" coords="158,155,217,181"/>
<area shape="rect"  href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="333,155,399,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeData.html">NodeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to store the information on each node.  <a href="structNodeData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structApproxInfo.html">ApproxInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main bookkeeping data structure for approximation algorithms.  <a href="structApproxInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGlobalQueueItem.html">GlobalQueueItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item of the queue used in the levelized traversal of the BDD.  <a href="structGlobalQueueItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocalQueueItem.html">LocalQueueItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the item of the local queue.  <a href="structLocalQueueItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a539f2dd258b96fac8f4dc9bc139d75c9"><td class="memItemLeft" align="right" valign="top"><a id="a539f2dd258b96fac8f4dc9bc139d75c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DBL_MAX_EXP</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a539f2dd258b96fac8f4dc9bc139d75c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4a7ebff687dc5228cc3fd4d25067f2"><td class="memItemLeft" align="right" valign="top"><a id="aad4a7ebff687dc5228cc3fd4d25067f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOTHING</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aad4a7ebff687dc5228cc3fd4d25067f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdeecb8041ec64c51bf6ac8ada9b85f"><td class="memItemLeft" align="right" valign="top"><a id="abfdeecb8041ec64c51bf6ac8ada9b85f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPLACE_T</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:abfdeecb8041ec64c51bf6ac8ada9b85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f4c5f60b46c48f9ba8d940e91e936b"><td class="memItemLeft" align="right" valign="top"><a id="ac0f4c5f60b46c48f9ba8d940e91e936b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPLACE_E</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac0f4c5f60b46c48f9ba8d940e91e936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8730fda1e81e2be695fc98b7ea56b1d0"><td class="memItemLeft" align="right" valign="top"><a id="a8730fda1e81e2be695fc98b7ea56b1d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPLACE_N</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a8730fda1e81e2be695fc98b7ea56b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328b37c5dce977e36a8cad72a5a5075"><td class="memItemLeft" align="right" valign="top"><a id="af328b37c5dce977e36a8cad72a5a5075"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPLACE_TT</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:af328b37c5dce977e36a8cad72a5a5075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887382ed988ce99032ca7190eb6cc0c8"><td class="memItemLeft" align="right" valign="top"><a id="a887382ed988ce99032ca7190eb6cc0c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REPLACE_TE</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a887382ed988ce99032ca7190eb6cc0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc326bd5037b2251e62f398ab1b48d1"><td class="memItemLeft" align="right" valign="top"><a id="afdc326bd5037b2251e62f398ab1b48d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DONT_CARE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:afdc326bd5037b2251e62f398ab1b48d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6aef9340c072016ab76545623c234"><td class="memItemLeft" align="right" valign="top"><a id="ac4b6aef9340c072016ab76545623c234"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CARE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac4b6aef9340c072016ab76545623c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b99ae0b8c217b6026b3a21c5d8087e5"><td class="memItemLeft" align="right" valign="top"><a id="a2b99ae0b8c217b6026b3a21c5d8087e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TOTAL_CARE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a2b99ae0b8c217b6026b3a21c5d8087e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0719cbe48fbd438b529ae22512a79077"><td class="memItemLeft" align="right" valign="top"><a id="a0719cbe48fbd438b529ae22512a79077"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CARE_ERROR</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a0719cbe48fbd438b529ae22512a79077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a810f9fea8d8fab2b926c102f36d6fa0c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structNodeData.html">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a810f9fea8d8fab2b926c102f36d6fa0c">NodeData</a></td></tr>
<tr class="memdesc:a810f9fea8d8fab2b926c102f36d6fa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to store the information on each node.  <a href="#a810f9fea8d8fab2b926c102f36d6fa0c">More...</a><br /></td></tr>
<tr class="separator:a810f9fea8d8fab2b926c102f36d6fa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61870783e08d5fd544037e967436bf6e"><td class="memItemLeft" align="right" valign="top"><a id="a61870783e08d5fd544037e967436bf6e"></a>
typedef struct <a class="el" href="structApproxInfo.html">ApproxInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a61870783e08d5fd544037e967436bf6e">ApproxInfo</a></td></tr>
<tr class="memdesc:a61870783e08d5fd544037e967436bf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main bookkeeping data structure for approximation algorithms. <br /></td></tr>
<tr class="separator:a61870783e08d5fd544037e967436bf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275817d243d823d5c56343b0d103ea8a"><td class="memItemLeft" align="right" valign="top"><a id="a275817d243d823d5c56343b0d103ea8a"></a>
typedef struct <a class="el" href="structGlobalQueueItem.html">GlobalQueueItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a275817d243d823d5c56343b0d103ea8a">GlobalQueueItem</a></td></tr>
<tr class="memdesc:a275817d243d823d5c56343b0d103ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item of the queue used in the levelized traversal of the BDD. <br /></td></tr>
<tr class="separator:a275817d243d823d5c56343b0d103ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4b9bf8d0c5c942cff733765c8acd98"><td class="memItemLeft" align="right" valign="top"><a id="aca4b9bf8d0c5c942cff733765c8acd98"></a>
typedef struct <a class="el" href="structLocalQueueItem.html">LocalQueueItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#aca4b9bf8d0c5c942cff733765c8acd98">LocalQueueItem</a></td></tr>
<tr class="memdesc:aca4b9bf8d0c5c942cff733765c8acd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the item of the local queue. <br /></td></tr>
<tr class="separator:aca4b9bf8d0c5c942cff733765c8acd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9381231f34573676e814bb696b2321c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9">Cudd_UnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a9381231f34573676e814bb696b2321c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with Shiple's underapproximation method.  <a href="#a9381231f34573676e814bb696b2321c9">More...</a><br /></td></tr>
<tr class="separator:a9381231f34573676e814bb696b2321c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e725e579f19ac3e946c04cfdde95f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a09e725e579f19ac3e946c04cfdde95f0">Cudd_OverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a09e725e579f19ac3e946c04cfdde95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with Shiple's underapproximation method.  <a href="#a09e725e579f19ac3e946c04cfdde95f0">More...</a><br /></td></tr>
<tr class="separator:a09e725e579f19ac3e946c04cfdde95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3">Cudd_RemapUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr class="memdesc:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the remapping underapproximation method.  <a href="#a05f3e8b16e5df2eb681a68e6ee6906f3">More...</a><br /></td></tr>
<tr class="separator:a05f3e8b16e5df2eb681a68e6ee6906f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88270c8ded877c10677d563b7041df38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38">Cudd_RemapOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr class="memdesc:a88270c8ded877c10677d563b7041df38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the remapping underapproximation method.  <a href="#a88270c8ded877c10677d563b7041df38">More...</a><br /></td></tr>
<tr class="separator:a88270c8ded877c10677d563b7041df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe204aedfdf7705234573d8781729e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2">Cudd_BiasedUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:a9fe204aedfdf7705234573d8781729e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense subset from a BDD with the biased underapproximation method.  <a href="#a9fe204aedfdf7705234573d8781729e2">More...</a><br /></td></tr>
<tr class="separator:a9fe204aedfdf7705234573d8781729e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#ab6ecb253ad0a11cc9430f0d527e6eaa0">Cudd_BiasedOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a dense superset from a BDD with the biased underapproximation method.  <a href="#ab6ecb253ad0a11cc9430f0d527e6eaa0">More...</a><br /></td></tr>
<tr class="separator:ab6ecb253ad0a11cc9430f0d527e6eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ad4116db7673ca7b4b829ecb7197b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b">cuddUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a9f4ad4116db7673ca7b4b829ecb7197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies Tom Shiple's underappoximation algorithm.  <a href="#a9f4ad4116db7673ca7b4b829ecb7197b">More...</a><br /></td></tr>
<tr class="separator:a9f4ad4116db7673ca7b4b829ecb7197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6a96316d8465015470b02486ffaa86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86">cuddRemapUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr class="memdesc:afd6a96316d8465015470b02486ffaa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the remapping underappoximation algorithm.  <a href="#afd6a96316d8465015470b02486ffaa86">More...</a><br /></td></tr>
<tr class="separator:afd6a96316d8465015470b02486ffaa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bdad03bfa7e367b6b3efa7aa1e4c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37">cuddBiasedUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:a60bdad03bfa7e367b6b3efa7aa1e4c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the biased remapping underappoximation algorithm.  <a href="#a60bdad03bfa7e367b6b3efa7aa1e4c37">More...</a><br /></td></tr>
<tr class="separator:a60bdad03bfa7e367b6b3efa7aa1e4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a1a3993926ee9220dd8871202b9c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a786a1a3993926ee9220dd8871202b9c0">updateParity</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int newparity)</td></tr>
<tr class="memdesc:a786a1a3993926ee9220dd8871202b9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively update the parity of the paths reaching a node.  <a href="#a786a1a3993926ee9220dd8871202b9c0">More...</a><br /></td></tr>
<tr class="separator:a786a1a3993926ee9220dd8871202b9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef9bff746f26b7676a9b6bf306aff0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structNodeData.html">NodeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0">gatherInfoAux</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int parity)</td></tr>
<tr class="memdesc:a52ef9bff746f26b7676a9b6bf306aff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively counts minterms and computes reference counts of each node in the BDD.  <a href="#a52ef9bff746f26b7676a9b6bf306aff0">More...</a><br /></td></tr>
<tr class="separator:a52ef9bff746f26b7676a9b6bf306aff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b2baafcdc4ec512e949ca16c527e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#ae44b2baafcdc4ec512e949ca16c527e8">gatherInfo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int numVars, int parity)</td></tr>
<tr class="memdesc:ae44b2baafcdc4ec512e949ca16c527e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers information about each node.  <a href="#ae44b2baafcdc4ec512e949ca16c527e8">More...</a><br /></td></tr>
<tr class="separator:ae44b2baafcdc4ec512e949ca16c527e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfefa6bdb3878c328ba8fafa81794d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#afdfefa6bdb3878c328ba8fafa81794d1">computeSavings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *skip, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *queue)</td></tr>
<tr class="memdesc:afdfefa6bdb3878c328ba8fafa81794d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the nodes that would be eliminated if a given node were replaced by zero.  <a href="#afdfefa6bdb3878c328ba8fafa81794d1">More...</a><br /></td></tr>
<tr class="separator:afdfefa6bdb3878c328ba8fafa81794d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db9c0f4accec76346cfba7cf37070a3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a8db9c0f4accec76346cfba7cf37070a3">updateRefs</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *skip, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *queue)</td></tr>
<tr class="memdesc:a8db9c0f4accec76346cfba7cf37070a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update function reference counts to account for replacement.  <a href="#a8db9c0f4accec76346cfba7cf37070a3">More...</a><br /></td></tr>
<tr class="separator:a8db9c0f4accec76346cfba7cf37070a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725a9cfe2c41f58f7f9f6ef1476965a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8">UAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, int safe, double quality)</td></tr>
<tr class="memdesc:a725a9cfe2c41f58f7f9f6ef1476965a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks nodes for replacement by zero.  <a href="#a725a9cfe2c41f58f7f9f6ef1476965a8">More...</a><br /></td></tr>
<tr class="separator:a725a9cfe2c41f58f7f9f6ef1476965a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7917aa7316c2bd90322cd38efe86043"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#aa7917aa7316c2bd90322cd38efe86043">UAbuildSubset</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info)</td></tr>
<tr class="memdesc:aa7917aa7316c2bd90322cd38efe86043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the subset BDD.  <a href="#aa7917aa7316c2bd90322cd38efe86043">More...</a><br /></td></tr>
<tr class="separator:aa7917aa7316c2bd90322cd38efe86043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc7c83d55240241ce3316405b46a7a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a">RAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, double quality)</td></tr>
<tr class="memdesc:a5cbc7c83d55240241ce3316405b46a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks nodes for remapping.  <a href="#a5cbc7c83d55240241ce3316405b46a7a">More...</a><br /></td></tr>
<tr class="separator:a5cbc7c83d55240241ce3316405b46a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f29212597e4553e259c59cb052c4e5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5">BAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, double quality1, double quality0)</td></tr>
<tr class="memdesc:af7f29212597e4553e259c59cb052c4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks nodes for remapping.  <a href="#af7f29212597e4553e259c59cb052c4e5">More...</a><br /></td></tr>
<tr class="separator:af7f29212597e4553e259c59cb052c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86508a00e350303c4d38de496dc03f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a2a86508a00e350303c4d38de496dc03f">RAbuildSubset</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info)</td></tr>
<tr class="memdesc:a2a86508a00e350303c4d38de496dc03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the subset BDD for cuddRemapUnderApprox.  <a href="#a2a86508a00e350303c4d38de496dc03f">More...</a><br /></td></tr>
<tr class="separator:a2a86508a00e350303c4d38de496dc03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d043119bb74e254d28502e00124165"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a89d043119bb74e254d28502e00124165">BAapplyBias</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdHashTable.html">DdHashTable</a> *cache)</td></tr>
<tr class="memdesc:a89d043119bb74e254d28502e00124165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds don't care nodes by traversing f and b in parallel.  <a href="#a89d043119bb74e254d28502e00124165">More...</a><br /></td></tr>
<tr class="separator:a89d043119bb74e254d28502e00124165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Procedures to approximate a given BDD. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html" title="Procedure to subset the given BDD by choosing the heavier branches.">cuddSubsetHB.c</a> <a class="el" href="cuddSubsetSP_8c.html" title="Procedure to subset the given BDD choosing the shortest paths (largest cubes) in the BDD.">cuddSubsetSP.c</a> <a class="el" href="cuddGenCof_8c.html" title="Generalized cofactors for BDDs and ADDs.">cuddGenCof.c</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Fabio Somenzi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a810f9fea8d8fab2b926c102f36d6fa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f9fea8d8fab2b926c102f36d6fa0c">&#9670;&nbsp;</a></span>NodeData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structNodeData.html">NodeData</a>  <a class="el" href="structNodeData.html">NodeData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data structure to store the information on each node. </p>
<p>It keeps the number of minterms of the function rooted at this node in terms of the number of variables specified by the user; the number of minterms of the complement; the impact of the number of minterms of this function on the number of minterms of the root function; the reference count of the node from within the root function; the flag that says whether the node intersects the care set; the flag that says whether the node should be replaced and how; the results of subsetting in both phases. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a89d043119bb74e254d28502e00124165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d043119bb74e254d28502e00124165">&#9670;&nbsp;</a></span>BAapplyBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int BAapplyBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds don't care nodes by traversing f and b in parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>the care status of the visited f node if successful; CARE_ERROR otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37" title="Applies the biased remapping underappoximation algorithm.">cuddBiasedUnderApprox</a> </dd></dl>

</div>
</div>
<a id="af7f29212597e4553e259c59cb052c4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f29212597e4553e259c59cb052c4e5">&#9670;&nbsp;</a></span>BAmarkNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int BAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks nodes for remapping. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37" title="Applies the biased remapping underappoximation algorithm.">cuddBiasedUnderApprox</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be analyzed </td></tr>
    <tr><td class="paramname">info</td><td>info on BDD </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximating </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdfefa6bdb3878c328ba8fafa81794d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfefa6bdb3878c328ba8fafa81794d1">&#9670;&nbsp;</a></span>computeSavings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int computeSavings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the nodes that would be eliminated if a given node were replaced by zero. </p>
<p>This procedure uses a queue passed by the caller for efficiency: since the queue is left empty at the endof the search, it can be reused as is by the next search.</p>
<dl class="section return"><dt>Returns</dt><dd>the count (always striclty positive) if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8" title="Marks nodes for replacement by zero.">UAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a" title="Marks nodes for remapping.">RAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5" title="Marks nodes for remapping.">BAmarkNodes</a> </dd></dl>

</div>
</div>
<a id="ab6ecb253ad0a11cc9430f0d527e6eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ecb253ad0a11cc9430f0d527e6eaa0">&#9670;&nbsp;</a></span>Cudd_BiasedOverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the biased underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2" title="Extracts a dense subset from a BDD with the biased underapproximation method.">Cudd_BiasedUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">b</td><td>bias function </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fe204aedfdf7705234573d8781729e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe204aedfdf7705234573d8781729e2">&#9670;&nbsp;</a></span>Cudd_BiasedUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the biased underapproximation method. </p>
<p>This procedure uses a biased remapping technique and density as the cost function. The bias is a function. This procedure tries to approximate where the bias is 0 and preserve the given function where the bias is 1. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">b</td><td>bias function </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e725e579f19ac3e946c04cfdde95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e725e579f19ac3e946c04cfdde95f0">&#9670;&nbsp;</a></span>Cudd_OverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_OverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with Shiple's underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88270c8ded877c10677d563b7041df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88270c8ded877c10677d563b7041df38">&#9670;&nbsp;</a></span>Cudd_RemapOverApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense superset from a BDD with the remapping underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be superset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f3e8b16e5df2eb681a68e6ee6906f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f3e8b16e5df2eb681a68e6ee6906f3">&#9670;&nbsp;</a></span>Cudd_RemapUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with the remapping underapproximation method. </p>
<p>This procedure uses a remapping technique and density as the cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9381231f34573676e814bb696b2321c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9381231f34573676e814bb696b2321c9">&#9670;&nbsp;</a></span>Cudd_UnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_UnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a dense subset from a BDD with Shiple's underapproximation method. </p>
<p>This procedure uses a variant of Tom Shiple's underapproximation method. The main difference from the original method is that density is used as cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the BDD of the subset if successful; NULL if the procedure runs out of memory.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be subset </td></tr>
    <tr><td class="paramname">numVars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximation </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60bdad03bfa7e367b6b3efa7aa1e4c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bdad03bfa7e367b6b3efa7aa1e4c37">&#9670;&nbsp;</a></span>cuddBiasedUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBiasedUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the biased remapping underappoximation algorithm. </p>
<p>Proceeds in three phases: </p><ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether remapping increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2" title="Extracts a dense subset from a BDD with the biased underapproximation method.">Cudd_BiasedUnderApprox</a> </dd></dl>
<p>&lt; readable true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>current DD </td></tr>
    <tr><td class="paramname">b</td><td>bias function </td></tr>
    <tr><td class="paramname">numVars</td><td>maximum number of variables </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold under which approximation stops </td></tr>
    <tr><td class="paramname">quality1</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td class="paramname">quality0</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd6a96316d8465015470b02486ffaa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6a96316d8465015470b02486ffaa86">&#9670;&nbsp;</a></span>cuddRemapUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddRemapUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the remapping underappoximation algorithm. </p>
<p>Proceeds in three phases: </p><ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether remapping increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> </dd></dl>
<p>&lt; readable true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>current DD </td></tr>
    <tr><td class="paramname">numVars</td><td>maximum number of variables </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold under which approximation stops </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f4ad4116db7673ca7b4b829ecb7197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4ad4116db7673ca7b4b829ecb7197b">&#9670;&nbsp;</a></span>cuddUnderApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies Tom Shiple's underappoximation algorithm. </p>
<p>Proceeds in three phases: </p><ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether its elimination increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>current DD </td></tr>
    <tr><td class="paramname">numVars</td><td>maximum number of variables </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold under which approximation stops </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae44b2baafcdc4ec512e949ca16c527e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b2baafcdc4ec512e949ca16c527e8">&#9670;&nbsp;</a></span>gatherInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structApproxInfo.html">ApproxInfo</a>* gatherInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers information about each node. </p>
<p>Counts minterms and computes reference counts of each node in the BDD. The minterm count is separately computed for the node and its complement. This is to avoid cancellation errors.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data structure holding the information gathered if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> <a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0" title="Recursively counts minterms and computes reference counts of each node in the BDD.">gatherInfoAux</a> </dd></dl>

</div>
</div>
<a id="a52ef9bff746f26b7676a9b6bf306aff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef9bff746f26b7676a9b6bf306aff0">&#9670;&nbsp;</a></span>gatherInfoAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structNodeData.html">NodeData</a>* gatherInfoAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively counts minterms and computes reference counts of each node in the BDD. </p>
<p>Similar to the cuddCountMintermAux which recursively counts the number of minterms for the dag rooted at each node in terms of the total number of variables (max). It assumes that the node pointer passed to it is regular and it maintains the invariant.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#ae44b2baafcdc4ec512e949ca16c527e8" title="Gathers information about each node.">gatherInfo</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>function to analyze </td></tr>
    <tr><td class="paramname">info</td><td>info on BDD </td></tr>
    <tr><td class="paramname">parity</td><td>gather parity information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a86508a00e350303c4d38de496dc03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a86508a00e350303c4d38de496dc03f">&#9670;&nbsp;</a></span>RAbuildSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* RAbuildSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the subset BDD for cuddRemapUnderApprox. </p>
<p>Based on the info table, performs remapping or replacement at selected nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86" title="Applies the remapping underappoximation algorithm.">cuddRemapUnderApprox</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">node</td><td>current node </td></tr>
    <tr><td class="paramname">info</td><td>node info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cbc7c83d55240241ce3316405b46a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbc7c83d55240241ce3316405b46a7a">&#9670;&nbsp;</a></span>RAmarkNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int RAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks nodes for remapping. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86" title="Applies the remapping underappoximation algorithm.">cuddRemapUnderApprox</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be analyzed </td></tr>
    <tr><td class="paramname">info</td><td>info on BDD </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximating </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7917aa7316c2bd90322cd38efe86043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7917aa7316c2bd90322cd38efe86043">&#9670;&nbsp;</a></span>UAbuildSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* UAbuildSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the subset BDD. </p>
<p>Based on the info table, replaces selected nodes by zero.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> </dd></dl>
<p>&lt; readable true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">node</td><td>current node </td></tr>
    <tr><td class="paramname">info</td><td>node info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a725a9cfe2c41f58f7f9f6ef1476965a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725a9cfe2c41f58f7f9f6ef1476965a8">&#9670;&nbsp;</a></span>UAmarkNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks nodes for replacement by zero. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> </dd></dl>
<p>&lt; readable true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be analyzed </td></tr>
    <tr><td class="paramname">info</td><td>info on BDD </td></tr>
    <tr><td class="paramname">threshold</td><td>when to stop approximating </td></tr>
    <tr><td class="paramname">safe</td><td>enforce safe approximation </td></tr>
    <tr><td class="paramname">quality</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a786a1a3993926ee9220dd8871202b9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786a1a3993926ee9220dd8871202b9c0">&#9670;&nbsp;</a></span>updateParity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void updateParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newparity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively update the parity of the paths reaching a node. </p>
<p>Assumes that node is regular and propagates the invariant.</p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0" title="Recursively counts minterms and computes reference counts of each node in the BDD.">gatherInfoAux</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>function to analyze </td></tr>
    <tr><td class="paramname">info</td><td>info on BDD </td></tr>
    <tr><td class="paramname">newparity</td><td>new parity for node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db9c0f4accec76346cfba7cf37070a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db9c0f4accec76346cfba7cf37070a3">&#9670;&nbsp;</a></span>updateRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int updateRefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update function reference counts to account for replacement. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes saved if successful; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8" title="Marks nodes for replacement by zero.">UAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a" title="Marks nodes for remapping.">RAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5" title="Marks nodes for remapping.">BAmarkNodes</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2020 20:59:18 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
