<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cudd: cudd/cuddDecomp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cudd
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3b2091e045759846649695fb574cbfc8.html">cudd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cuddDecomp.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for BDD decomposition.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddDecomp.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddDecomp_8c__incl.png" border="0" usemap="#cudd_2cuddDecomp_8c" alt=""/></div>
<map name="cudd_2cuddDecomp_8c" id="cudd_2cuddDecomp_8c">
<area shape="rect"  title="Functions for BDD decomposition." alt="" coords="401,5,555,32"/>
<area shape="rect"  href="util_8h.html" title="Low&#45;level utilities." alt="" coords="655,80,709,107"/>
<area shape="rect"  href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="234,80,317,107"/>
<area shape="rect"  title=" " alt="" coords="423,155,498,181"/>
<area shape="rect"  title=" " alt="" coords="910,155,985,181"/>
<area shape="rect"  title=" " alt="" coords="1009,155,1083,181"/>
<area shape="rect"  title=" " alt="" coords="309,229,375,256"/>
<area shape="rect"  title=" " alt="" coords="573,155,644,181"/>
<area shape="rect"  title=" " alt="" coords="720,155,791,181"/>
<area shape="rect"  title=" " alt="" coords="815,155,885,181"/>
<area shape="rect"  title=" " alt="" coords="480,229,567,256"/>
<area shape="rect"  title=" " alt="" coords="241,155,309,181"/>
<area shape="rect"  href="st_8h.html" title="Symbol table package." alt="" coords="5,155,52,181"/>
<area shape="rect"  href="mtr_8h.html" title="Multiway&#45;branch tree manipulation." alt="" coords="76,155,133,181"/>
<area shape="rect"  href="epd_8h.html" title="The University of Colorado extended double precision package." alt="" coords="158,155,217,181"/>
<area shape="rect"  href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="333,155,399,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConjuncts.html">Conjuncts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pair of conjoined BDDs.  <a href="structConjuncts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeStat.html">NodeStat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for one node.  <a href="structNodeStat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a50267d552ca6f788254032e40046b770"><td class="memItemLeft" align="right" valign="top"><a id="a50267d552ca6f788254032e40046b770"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a50267d552ca6f788254032e40046b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4679d8ea8690999a6c6c7c0cb245c879"><td class="memItemLeft" align="right" valign="top"><a id="a4679d8ea8690999a6c6c7c0cb245c879"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a4679d8ea8690999a6c6c7c0cb245c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655c84af1b0034986ff56e12e84f983d"><td class="memItemLeft" align="right" valign="top"><a id="a655c84af1b0034986ff56e12e84f983d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NONE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a655c84af1b0034986ff56e12e84f983d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0324bc023993d04644f4914ca00e99"><td class="memItemLeft" align="right" valign="top"><a id="a9d0324bc023993d04644f4914ca00e99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PAIR_ST</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a9d0324bc023993d04644f4914ca00e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e4e1e01aae91b6337bd0cf5bd5c65f"><td class="memItemLeft" align="right" valign="top"><a id="a57e4e1e01aae91b6337bd0cf5bd5c65f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PAIR_CR</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a57e4e1e01aae91b6337bd0cf5bd5c65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdccfbacfcbec51d7ab394bcffb4bd6"><td class="memItemLeft" align="right" valign="top"><a id="a4cdccfbacfcbec51d7ab394bcffb4bd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>G_ST</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a4cdccfbacfcbec51d7ab394bcffb4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1281cf32367f04a8b5d44c34d9c89302"><td class="memItemLeft" align="right" valign="top"><a id="a1281cf32367f04a8b5d44c34d9c89302"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>G_CR</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a1281cf32367f04a8b5d44c34d9c89302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bd6b0372e14f14782c818fbb778520"><td class="memItemLeft" align="right" valign="top"><a id="a01bd6b0372e14f14782c818fbb778520"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>H_ST</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a01bd6b0372e14f14782c818fbb778520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22a343f5591b834c0175d43bd0592b"><td class="memItemLeft" align="right" valign="top"><a id="a3c22a343f5591b834c0175d43bd0592b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>H_CR</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a3c22a343f5591b834c0175d43bd0592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4637f90ba7bba70e9644293f654c913"><td class="memItemLeft" align="right" valign="top"><a id="ad4637f90ba7bba70e9644293f654c913"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOTH_G</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:ad4637f90ba7bba70e9644293f654c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f174c91e99d36c1a2ca2f683dab432"><td class="memItemLeft" align="right" valign="top"><a id="a09f174c91e99d36c1a2ca2f683dab432"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOTH_H</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a09f174c91e99d36c1a2ca2f683dab432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ab001141d9916c63d700aafbf406a"><td class="memItemLeft" align="right" valign="top"><a id="a955ab001141d9916c63d700aafbf406a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsNotStored</b>(factors)&#160;&#160;&#160;((int)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) &amp; 01))</td></tr>
<tr class="separator:a955ab001141d9916c63d700aafbf406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf70e0ff9741c9a77b785163774a2c"><td class="memItemLeft" align="right" valign="top"><a id="a5faf70e0ff9741c9a77b785163774a2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsComplement</b>(factors)&#160;&#160;&#160;((<a class="el" href="structConjuncts.html">Conjuncts</a> *)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) | 01))</td></tr>
<tr class="separator:a5faf70e0ff9741c9a77b785163774a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2222d3e7efefe33aeb8329cfdf27cfbf"><td class="memItemLeft" align="right" valign="top"><a id="a2222d3e7efefe33aeb8329cfdf27cfbf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsUncomplement</b>(factors)&#160;&#160;&#160;((<a class="el" href="structConjuncts.html">Conjuncts</a> *)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) ^ 01))</td></tr>
<tr class="separator:a2222d3e7efefe33aeb8329cfdf27cfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac91468d32645ee617c931a873c918588"><td class="memItemLeft" align="right" valign="top"><a id="ac91468d32645ee617c931a873c918588"></a>
typedef struct <a class="el" href="structConjuncts.html">Conjuncts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac91468d32645ee617c931a873c918588">Conjuncts</a></td></tr>
<tr class="memdesc:ac91468d32645ee617c931a873c918588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pair of conjoined BDDs. <br /></td></tr>
<tr class="separator:ac91468d32645ee617c931a873c918588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127ed5f95b1fc2aea16d0ecb322798f"><td class="memItemLeft" align="right" valign="top"><a id="ac127ed5f95b1fc2aea16d0ecb322798f"></a>
typedef struct <a class="el" href="structNodeStat.html">NodeStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac127ed5f95b1fc2aea16d0ecb322798f">NodeStat</a></td></tr>
<tr class="memdesc:ac127ed5f95b1fc2aea16d0ecb322798f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for one node. <br /></td></tr>
<tr class="separator:ac127ed5f95b1fc2aea16d0ecb322798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a536e36dac9b4ddf90edb3a48934b7886"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886">Cudd_bddApproxConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:a536e36dac9b4ddf90edb3a48934b7886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a536e36dac9b4ddf90edb3a48934b7886">More...</a><br /></td></tr>
<tr class="separator:a536e36dac9b4ddf90edb3a48934b7886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e">Cudd_bddApproxDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#aa9d8d2d24ef2842db6b6ab5794d2bb6e">More...</a><br /></td></tr>
<tr class="separator:aa9d8d2d24ef2842db6b6ab5794d2bb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa">Cudd_bddIterConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#ad7b54f1fae0417dcb3eeab6f1be792fa">More...</a><br /></td></tr>
<tr class="separator:ad7b54f1fae0417dcb3eeab6f1be792fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac716bb2411a608764d34404fadf09379"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379">Cudd_bddIterDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:ac716bb2411a608764d34404fadf09379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#ac716bb2411a608764d34404fadf09379">More...</a><br /></td></tr>
<tr class="separator:ac716bb2411a608764d34404fadf09379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de1749d0e92e061d1b3edafc56956b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3">Cudd_bddGenConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:a8de1749d0e92e061d1b3edafc56956b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a8de1749d0e92e061d1b3edafc56956b3">More...</a><br /></td></tr>
<tr class="separator:a8de1749d0e92e061d1b3edafc56956b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952">Cudd_bddGenDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a0f7cc1a34d26e9bbf9d3919e258dd952">More...</a><br /></td></tr>
<tr class="separator:a0f7cc1a34d26e9bbf9d3919e258dd952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21da753c8a5798886891fed4baaaa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4">Cudd_bddVarConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr class="memdesc:aaa21da753c8a5798886891fed4baaaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#aaa21da753c8a5798886891fed4baaaa4">More...</a><br /></td></tr>
<tr class="separator:aaa21da753c8a5798886891fed4baaaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057207ca7a87e980a040bb1183db3645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645">Cudd_bddVarDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr class="memdesc:a057207ca7a87e980a040bb1183db3645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a057207ca7a87e980a040bb1183db3645">More...</a><br /></td></tr>
<tr class="separator:a057207ca7a87e980a040bb1183db3645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677a13bad737b71a8cbbf3791f0a6f9b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structNodeStat.html">NodeStat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a677a13bad737b71a8cbbf3791f0a6f9b">CreateBotDist</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structst__table.html">st_table</a> *distanceTable)</td></tr>
<tr class="memdesc:a677a13bad737b71a8cbbf3791f0a6f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get longest distance of node from constant.  <a href="#a677a13bad737b71a8cbbf3791f0a6f9b">More...</a><br /></td></tr>
<tr class="separator:a677a13bad737b71a8cbbf3791f0a6f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9789f1cd2562a9398a9a8aef7fcbddac"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a9789f1cd2562a9398a9a8aef7fcbddac">CountMinterms</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, double max, <a class="el" href="structst__table.html">st_table</a> *mintermTable, FILE *fp)</td></tr>
<tr class="memdesc:a9789f1cd2562a9398a9a8aef7fcbddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of minterms of each node ina a BDD and store it in a hash table.  <a href="#a9789f1cd2562a9398a9a8aef7fcbddac">More...</a><br /></td></tr>
<tr class="separator:a9789f1cd2562a9398a9a8aef7fcbddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4526827b5d326a789805110e7937559"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#af4526827b5d326a789805110e7937559">ConjunctsFree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structConjuncts.html">Conjuncts</a> *factors)</td></tr>
<tr class="memdesc:af4526827b5d326a789805110e7937559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free factors structure.  <a href="#af4526827b5d326a789805110e7937559">More...</a><br /></td></tr>
<tr class="separator:af4526827b5d326a789805110e7937559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf0babf23592ac86844a69942f019d8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a3cf0babf23592ac86844a69942f019d8">PairInTables</a> (<a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, <a class="el" href="structst__table.html">st_table</a> *ghTable)</td></tr>
<tr class="memdesc:a3cf0babf23592ac86844a69942f019d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given pair is in the tables.  <a href="#a3cf0babf23592ac86844a69942f019d8">More...</a><br /></td></tr>
<tr class="separator:a3cf0babf23592ac86844a69942f019d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3774902b34268e043e475e206795736d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a3774902b34268e043e475e206795736d">CheckTablesCacheAndReturn</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable)</td></tr>
<tr class="memdesc:a3774902b34268e043e475e206795736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the tables for the existence of pair and return one combination, cache the result.  <a href="#a3774902b34268e043e475e206795736d">More...</a><br /></td></tr>
<tr class="separator:a3774902b34268e043e475e206795736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e65ca848499b8f665a0a94447ec406f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a2e65ca848499b8f665a0a94447ec406f">PickOnePair</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g1, <a class="el" href="structDdNode.html">DdNode</a> *h1, <a class="el" href="structDdNode.html">DdNode</a> *g2, <a class="el" href="structDdNode.html">DdNode</a> *h2, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable)</td></tr>
<tr class="memdesc:a2e65ca848499b8f665a0a94447ec406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the tables for the existence of pair and return one combination, store in cache.  <a href="#a2e65ca848499b8f665a0a94447ec406f">More...</a><br /></td></tr>
<tr class="separator:a2e65ca848499b8f665a0a94447ec406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fe277b7a73c473a990393fb269a508"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a92fe277b7a73c473a990393fb269a508">CheckInTables</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g1, <a class="el" href="structDdNode.html">DdNode</a> *h1, <a class="el" href="structDdNode.html">DdNode</a> *g2, <a class="el" href="structDdNode.html">DdNode</a> *h2, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int *outOfMem)</td></tr>
<tr class="memdesc:a92fe277b7a73c473a990393fb269a508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two pairs exist in the table.  <a href="#a92fe277b7a73c473a990393fb269a508">More...</a><br /></td></tr>
<tr class="separator:a92fe277b7a73c473a990393fb269a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4026d82c5fdbea92f4e8cda0311f2d28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28">ZeroCase</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structConjuncts.html">Conjuncts</a> *factorsNv, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int switched)</td></tr>
<tr class="memdesc:a4026d82c5fdbea92f4e8cda0311f2d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">If one child is zero, do explicitly what Restrict does or better.  <a href="#a4026d82c5fdbea92f4e8cda0311f2d28">More...</a><br /></td></tr>
<tr class="separator:a4026d82c5fdbea92f4e8cda0311f2d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc7ad841707491ef81d19e3dbef0794"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794">BuildConjuncts</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structst__table.html">st_table</a> *distanceTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int approxDistance, int maxLocalRef, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *mintermTable, int32_t *lastTimeG)</td></tr>
<tr class="memdesc:a8fc7ad841707491ef81d19e3dbef0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the conjuncts recursively, bottom up.  <a href="#a8fc7ad841707491ef81d19e3dbef0794">More...</a><br /></td></tr>
<tr class="separator:a8fc7ad841707491ef81d19e3dbef0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccdb7a449913b1e570ae336f34e665"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ad7ccdb7a449913b1e570ae336f34e665">cuddConjunctsAux</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **c1, <a class="el" href="structDdNode.html">DdNode</a> **c2)</td></tr>
<tr class="memdesc:ad7ccdb7a449913b1e570ae336f34e665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes two conjunctive factors of f and places them in *c1 and *c2.  <a href="#ad7ccdb7a449913b1e570ae336f34e665">More...</a><br /></td></tr>
<tr class="separator:ad7ccdb7a449913b1e570ae336f34e665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for BDD decomposition. </p>
<dl class="section author"><dt>Author</dt><dd>Kavita Ravi, Fabio Somenzi</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><p class="startdd">Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p class="interdd">All rights reserved.</p>
<p class="interdd">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p class="interdd">Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p class="interdd">Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p class="interdd">Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p class="enddd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8fc7ad841707491ef81d19e3dbef0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc7ad841707491ef81d19e3dbef0794">&#9670;&nbsp;</a></span>BuildConjuncts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* BuildConjuncts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>distanceTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>approxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLocalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>mintermTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>lastTimeG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the conjuncts recursively, bottom up. </p>
<p>Constants are returned as (f, f). The cache is checked for previously computed result. The decomposition points are determined by the local reference count of this node and the longest distance from the constant. At the decomposition point, the factors returned are (f, 1). Recur on the two children. The order is determined by the heavier branch. Combine the factors of the two children and pick the one that already occurs in the gh table. Occurence in g is indicated by value 1, occurence in h by 2, occurence in both by 3.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#ad7ccdb7a449913b1e570ae336f34e665" title="Computes two conjunctive factors of f and places them in *c1 and *c2.">cuddConjunctsAux</a> </dd></dl>

</div>
</div>
<a id="a92fe277b7a73c473a990393fb269a508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fe277b7a73c473a990393fb269a508">&#9670;&nbsp;</a></span>CheckInTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* CheckInTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outOfMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the two pairs exist in the table. </p>
<p>If any of the conjuncts do exist, store in the cache and return the corresponding pair.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> <a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
<a id="a3774902b34268e043e475e206795736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3774902b34268e043e475e206795736d">&#9670;&nbsp;</a></span>CheckTablesCacheAndReturn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* CheckTablesCacheAndReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the tables for the existence of pair and return one combination, cache the result. </p>
<p>The assumption is that one of the conjuncts is already in the tables.</p>
<dl class="section user"><dt>Side effects\n g and h referenced for the cache</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> </dd></dl>

</div>
</div>
<a id="af4526827b5d326a789805110e7937559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4526827b5d326a789805110e7937559">&#9670;&nbsp;</a></span>ConjunctsFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ConjunctsFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free factors structure. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a9789f1cd2562a9398a9a8aef7fcbddac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9789f1cd2562a9398a9a8aef7fcbddac">&#9670;&nbsp;</a></span>CountMinterms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double CountMinterms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>mintermTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of minterms of each node ina a BDD and store it in a hash table. </p>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a677a13bad737b71a8cbbf3791f0a6f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677a13bad737b71a8cbbf3791f0a6f9b">&#9670;&nbsp;</a></span>CreateBotDist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structNodeStat.html">NodeStat</a>* CreateBotDist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>distanceTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get longest distance of node from constant. </p>
<dl class="section return"><dt>Returns</dt><dd>the distance of the root from the constant if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n None</dt><dd></dd></dl>

</div>
</div>
<a id="a536e36dac9b4ddf90edb3a48934b7886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e36dac9b4ddf90edb3a48934b7886">&#9670;&nbsp;</a></span>Cudd_bddApproxConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the use of supersetting to obtain an initial factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the first factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9d8d2d24ef2842db6b6ab5794d2bb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d8d2d24ef2842db6b6ab5794d2bb6e">&#9670;&nbsp;</a></span>Cudd_bddApproxDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de1749d0e92e061d1b3edafc56956b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de1749d0e92e061d1b3edafc56956b3">&#9670;&nbsp;</a></span>Cudd_bddGenConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the fact tht it generalizes the decomposition based on the cofactors with respect to one variable. The conjuncts produced by this procedure tend to be balanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7cc1a34d26e9bbf9d3919e258dd952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7cc1a34d26e9bbf9d3919e258dd952">&#9670;&nbsp;</a></span>Cudd_bddGenDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be balanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7b54f1fae0417dcb3eeab6f1be792fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b54f1fae0417dcb3eeab6f1be792fa">&#9670;&nbsp;</a></span>Cudd_bddIterConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the iterated use of supersetting to obtain a factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac716bb2411a608764d34404fadf09379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac716bb2411a608764d34404fadf09379">&#9670;&nbsp;</a></span>Cudd_bddIterDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa21da753c8a5798886891fed4baaaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa21da753c8a5798886891fed4baaaa4">&#9670;&nbsp;</a></span>Cudd_bddVarConjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>Conjunctively decomposes one BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>(f+x)(f+x')</code>. The variable is chosen so as to balance the sizes of the two conjuncts and to keep them small.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two factors are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a057207ca7a87e980a040bb1183db3645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057207ca7a87e980a040bb1183db3645">&#9670;&nbsp;</a></span>Cudd_bddVarDisjDecomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>Performs two-way disjunctive decomposition of a BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>f*x + f*x'</code>. The variable is chosen so as to balance the sizes of the two disjuncts and to keep them small.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="section user"><dt>Side effects\n The two disjuncts are returned in an array as side effects.</dt><dd>The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7ccdb7a449913b1e570ae336f34e665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ccdb7a449913b1e570ae336f34e665">&#9670;&nbsp;</a></span>cuddConjunctsAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddConjunctsAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes two conjunctive factors of f and places them in *c1 and *c2. </p>
<p>Sets up the required data - table of distances from the constant and local reference count. Also minterm table. </p>

</div>
</div>
<a id="a3cf0babf23592ac86844a69942f019d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf0babf23592ac86844a69942f019d8">&#9670;&nbsp;</a></span>PairInTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int PairInTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the given pair is in the tables. </p>
<p>gTable and hTable are combined. absence in both is indicated by 0, presence in gTable is indicated by 1, presence in hTable by 2 and presence in both by 3. The values returned by this function are PAIR_ST, PAIR_CR, G_ST, G_CR, H_ST, H_CR, BOTH_G, BOTH_H, NONE. PAIR_ST implies g in gTable and h in hTable PAIR_CR implies g in hTable and h in gTable G_ST implies g in gTable and h not in any table G_CR implies g in hTable and h not in any table H_ST implies h in hTable and g not in any table H_CR implies h in gTable and g not in any table BOTH_G implies both in gTable BOTH_H implies both in hTable NONE implies none in table;</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a3774902b34268e043e475e206795736d" title="Check the tables for the existence of pair and return one combination, cache the result.">CheckTablesCacheAndReturn</a> <a class="el" href="cuddDecomp_8c.html#a92fe277b7a73c473a990393fb269a508" title="Check if the two pairs exist in the table.">CheckInTables</a> </dd></dl>

</div>
</div>
<a id="a2e65ca848499b8f665a0a94447ec406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e65ca848499b8f665a0a94447ec406f">&#9670;&nbsp;</a></span>PickOnePair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* PickOnePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the tables for the existence of pair and return one combination, store in cache. </p>
<p>The pair that has more pointers to it is picked. An approximation of the number of local pointers is made by taking the reference count of the pairs sent.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> <a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
<a id="a4026d82c5fdbea92f4e8cda0311f2d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4026d82c5fdbea92f4e8cda0311f2d28">&#9670;&nbsp;</a></span>ZeroCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* ZeroCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td>
          <td class="paramname"><em>factorsNv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>switched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If one child is zero, do explicitly what Restrict does or better. </p>
<p>First separate a variable and its child in the base case. In case of a cube times a function, separate the cube and function. As a last resort, look in tables.</p>
<dl class="section user"><dt>Side effects\n Frees the BDDs in factorsNv. factorsNv itself is not freed</dt><dd>because it is freed above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 26 2020 20:59:18 for cudd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
